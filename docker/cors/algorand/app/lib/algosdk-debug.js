(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.algosdk = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.MessagePack=t():e.MessagePack=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);var n=function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return s},i=function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e},o="undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function s(e){for(var t=e.length,r=0,n=0;n<t;){var i=e.charCodeAt(n++);if(0!=(4294967168&i))if(0==(4294965248&i))r+=2;else{if(i>=55296&&i<=56319&&n<t){var o=e.charCodeAt(n);56320==(64512&o)&&(++n,i=((1023&i)<<10)+(1023&o)+65536)}r+=0==(4294901760&i)?3:4}else r++}return r}var a=o?new TextEncoder:void 0;var h=a&&a.encodeInto?function(e,t,r){a.encodeInto(e,t.subarray(r))}:function(e,t,r){t.set(a.encode(e),r)},u=65536;function c(e,t,r){for(var n=t,o=n+r,s=[],a="";n<o;){var h=e[n++];if(0==(128&h))s.push(h);else if(192==(224&h)){var c=63&e[n++];s.push((31&h)<<6|c)}else if(224==(240&h)){c=63&e[n++];var f=63&e[n++];s.push((31&h)<<12|c<<6|f)}else if(240==(248&h)){var l=(7&h)<<18|(c=63&e[n++])<<12|(f=63&e[n++])<<6|63&e[n++];l>65535&&(l-=65536,s.push(l>>>10&1023|55296),l=56320|1023&l),s.push(l)}else s.push(h);s.length-4>=u&&(a+=String.fromCharCode.apply(String,i(s)),s.length=0)}return s.length>0&&(a+=String.fromCharCode.apply(String,i(s))),a}var f=o?new TextDecoder:null;var l=function(e,t){this.type=e,this.data=t};function p(e,t,r){var n=Math.floor(r/4294967296),i=r;e.setUint32(t,n),e.setUint32(t+4,i)}function d(e,t){return 4294967296*e.getInt32(t)+e.getUint32(t+4)}var y=4294967295,w=17179869183;function v(e){var t=e.sec,r=e.nsec;if(t>=0&&r>=0&&t<=w){if(0===r&&t<=y){var n=new Uint8Array(4);return(s=new DataView(n.buffer)).setUint32(0,t),n}var i=t/4294967296,o=4294967295&t;n=new Uint8Array(8);return(s=new DataView(n.buffer)).setUint32(0,r<<2|3&i),s.setUint32(4,o),n}var s;n=new Uint8Array(12);return(s=new DataView(n.buffer)).setUint32(0,r),p(s,4,t),n}function g(e){var t=e.getTime(),r=Math.floor(t/1e3),n=1e6*(t-1e3*r),i=Math.floor(n/1e9);return{sec:r+i,nsec:n-1e9*i}}function b(e){return e instanceof Date?v(g(e)):null}function m(e){var t=new DataView(e.buffer,e.byteOffset,e.byteLength);switch(e.byteLength){case 4:return{sec:t.getUint32(0),nsec:0};case 8:var r=t.getUint32(0);return{sec:4294967296*(3&r)+t.getUint32(4),nsec:r>>>2};case 12:return{sec:d(t,4),nsec:t.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+e.length)}}function U(e){var t=m(e);return new Date(1e3*t.sec+t.nsec/1e6)}var x={type:-1,encode:b,decode:U},S=function(){function e(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(x)}return e.prototype.register=function(e){var t=e.type,r=e.encode,n=e.decode;if(t>=0)this.encoders[t]=r,this.decoders[t]=n;else{var i=1+t;this.builtInEncoders[i]=r,this.builtInDecoders[i]=n}},e.prototype.tryToEncode=function(e){for(var t=0;t<this.builtInEncoders.length;t++){if(null!=(r=this.builtInEncoders[t]))if(null!=(n=r(e)))return new l(-1-t,n)}for(t=0;t<this.encoders.length;t++){var r,n;if(null!=(r=this.encoders[t]))if(null!=(n=r(e)))return new l(t,n)}return e instanceof l?e:null},e.prototype.decode=function(e,t){var r=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return r?r(e,t):new l(t,e)},e.defaultCodec=new e,e}();function E(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Uint8Array.from(e)}var B=null,A=!!B;function L(e,t,r){var n=e.length,i=2*n,o=B.malloc(i);!function(e,t,r,n){for(var i=new DataView(B.memory.buffer,e,t),o=0;o<n;o++)i.setUint16(2*o,r.charCodeAt(o))}(o,i,e,n);var s=B.malloc(5+4*n);try{var a=B.utf8EncodeUint16Array(s,o,n);return t.set(new Uint8Array(B.memory.buffer,s,a),r),a}finally{B.free(o),B.free(s)}}var T=65536;function I(e,t,r){var n,i,o,s=B.malloc(r),a=B.malloc(2*r);try{n=s,i=e.subarray(t,t+r),o=r,new Uint8Array(B.memory.buffer,n,o).set(i);var h=B.utf8DecodeToUint16Array(a,s,r);return function(e){if(e.length<=T)return String.fromCharCode.apply(String,e);for(var t="",r=0;r<e.length;r++){var n=e.subarray(r*T,(r+1)*T);t+=String.fromCharCode.apply(String,n)}return t}(new Uint16Array(B.memory.buffer,a,h))}finally{B.free(s),B.free(a)}}var k=function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},M=100,z=2048,C=function(){function e(e,t,r,n,i){void 0===e&&(e=S.defaultCodec),void 0===t&&(t=M),void 0===r&&(r=z),void 0===n&&(n=!1),void 0===i&&(i=!1),this.extensionCodec=e,this.maxDepth=t,this.initialBufferSize=r,this.sortKeys=n,this.forceFloat32=i,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return e.prototype.encode=function(e,t){if(t>this.maxDepth)throw new Error("Too deep objects in depth "+t);null==e?this.encodeNil():"boolean"==typeof e?this.encodeBoolean(e):"number"==typeof e?this.encodeNumber(e):"string"==typeof e?this.encodeString(e):this.encodeObject(e,t)},e.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},e.prototype.ensureBufferSizeToWrite=function(e){var t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(2*t)},e.prototype.resizeBuffer=function(e){var t=new ArrayBuffer(e),r=new Uint8Array(t),n=new DataView(t);r.set(this.bytes),this.view=n,this.bytes=r},e.prototype.encodeNil=function(){this.writeU8(192)},e.prototype.encodeBoolean=function(e){!1===e?this.writeU8(194):this.writeU8(195)},e.prototype.encodeNumber=function(e){Number.isSafeInteger(e)?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))},e.prototype.writeStringHeader=function(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too long string: "+e+" bytes in UTF-8");this.writeU8(219),this.writeU32(e)}},e.prototype.encodeString=function(e){var t=e.length;if(o&&t>200){var r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),h(e,this.bytes,this.pos),this.pos+=r}else{if(A&&t>1024){var n=5+4*t;this.ensureBufferSizeToWrite(n);var i=L(e,this.bytes,this.pos);return void(this.pos+=i)}r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),function(e,t,r){for(var n=e.length,i=r,o=0;o<n;){var s=e.charCodeAt(o++);if(0!=(4294967168&s)){if(0==(4294965248&s))t[i++]=s>>6&31|192;else{if(s>=55296&&s<=56319&&o<n){var a=e.charCodeAt(o);56320==(64512&a)&&(++o,s=((1023&s)<<10)+(1023&a)+65536)}0==(4294901760&s)?(t[i++]=s>>12&15|224,t[i++]=s>>6&63|128):(t[i++]=s>>18&7|240,t[i++]=s>>12&63|128,t[i++]=s>>6&63|128)}t[i++]=63&s|128}else t[i++]=s}}(e,this.bytes,this.pos),this.pos+=r}},e.prototype.encodeObject=function(e,t){var r=this.extensionCodec.tryToEncode(e);if(null!=r)this.encodeExtension(r);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else{if("object"!=typeof e)throw new Error("Unrecognized object: "+Object.prototype.toString.apply(e));this.encodeMap(e,t)}},e.prototype.encodeBinary=function(e){var t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large binary: "+t);this.writeU8(198),this.writeU32(t)}var r=E(e);this.writeU8a(r)},e.prototype.encodeArray=function(e,t){var r,n,i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else{if(!(i<4294967296))throw new Error("Too large array: "+i);this.writeU8(221),this.writeU32(i)}try{for(var o=k(e),s=o.next();!s.done;s=o.next()){var a=s.value;this.encode(a,t+1)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}},e.prototype.encodeMap=function(e,t){var r=Object.keys(e);this.sortKeys&&r.sort();var n=r.length;if(n<16)this.writeU8(128+n);else if(n<65536)this.writeU8(222),this.writeU16(n);else{if(!(n<4294967296))throw new Error("Too large map object: "+n);this.writeU8(223),this.writeU32(n)}for(var i=0;i<n;i++){var o=r[i];this.encodeString(o),this.encode(e[o],t+1)}},e.prototype.encodeExtension=function(e){var t=e.data.length;if(1===t)this.writeU8(212);else if(2===t)this.writeU8(213);else if(4===t)this.writeU8(214);else if(8===t)this.writeU8(215);else if(16===t)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large extension object: "+t);this.writeU8(201),this.writeU32(t)}this.writeI8(e.type),this.writeU8a(e.data)},e.prototype.writeU8=function(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++},e.prototype.writeU8a=function(e){var t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t},e.prototype.writeI8=function(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++},e.prototype.writeU16=function(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2},e.prototype.writeI16=function(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2},e.prototype.writeU32=function(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4},e.prototype.writeI32=function(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4},e.prototype.writeF32=function(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4},e.prototype.writeF64=function(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8},e.prototype.writeU64=function(e){this.ensureBufferSizeToWrite(8),function(e,t,r){var n=r/4294967296,i=r;e.setUint32(t,n),e.setUint32(t+4,i)}(this.view,this.pos,e),this.pos+=8},e.prototype.writeI64=function(e){this.ensureBufferSizeToWrite(8),p(this.view,this.pos,e),this.pos+=8},e}(),D={};function P(e,t){void 0===t&&(t=D);var r=new C(t.extensionCodec,t.maxDepth,t.initialBufferSize,t.sortKeys,t.forceFloat32);return r.encode(e,1),r.getUint8Array()}function j(e){return(e<0?"-":"")+"0x"+Math.abs(e).toString(16).padStart(2,"0")}var F=16,W=16,O=function(){function e(e,t){void 0===e&&(e=F),void 0===t&&(t=W),this.maxKeyLength=e,this.maxLengthPerKey=t,this.caches=[];for(var r=0;r<this.maxKeyLength;r++)this.caches.push([])}return e.prototype.canBeCached=function(e){return e>0&&e<=this.maxKeyLength},e.prototype.get=function(e,t,r){var n=this.caches[r-1],i=n.length;e:for(var o=0;o<i;o++){for(var s=n[o],a=s.bytes,h=0;h<r;h++)if(a[h]!==e[t+h])continue e;return s.value}return null},e.prototype.store=function(e,t){var r=this.caches[e.length-1],n={bytes:e,value:t};r.length>=this.maxLengthPerKey?r[Math.random()*r.length|0]=n:r.push(n)},e.prototype.decode=function(e,t,r){var n=this.get(e,t,r);if(n)return n;var i=c(e,t,r),o=Uint8Array.prototype.slice.call(e,t,t+r);return this.store(o,i),i},e}(),K=function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function s(e){try{h(n.next(e))}catch(e){o(e)}}function a(e){try{h(n.throw(e))}catch(e){o(e)}}function h(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r(function(e){e(t)})).then(s,a)}h((n=n.apply(e,t||[])).next())})},_=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},V=function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=function(){return this},t);function n(r){t[r]=e[r]&&function(t){return new Promise(function(n,i){(function(e,t,r,n){Promise.resolve(n).then(function(t){e({value:t,done:r})},t)})(n,i,(t=e[r](t)).done,t.value)})}}},N=function(e){return this instanceof N?(this.v=e,this):new N(e)},R=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise(function(r,n){o.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{(r=i[e](t)).value instanceof N?Promise.resolve(r.value.v).then(h,u):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function h(e){a("next",e)}function u(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}},H=-1,G=new DataView(new ArrayBuffer(0)),X=new Uint8Array(G.buffer),q=function(){try{G.getInt8(0)}catch(e){return e.constructor}throw new Error("never reached")}(),J=new q("Insufficient data"),Q=4294967295,Y=new O,Z=function(){function e(e,t,r,n,i,o,s){void 0===e&&(e=S.defaultCodec),void 0===t&&(t=Q),void 0===r&&(r=Q),void 0===n&&(n=Q),void 0===i&&(i=Q),void 0===o&&(o=Q),void 0===s&&(s=Y),this.extensionCodec=e,this.maxStrLength=t,this.maxBinLength=r,this.maxArrayLength=n,this.maxMapLength=i,this.maxExtLength=o,this.cachedKeyDecoder=s,this.totalPos=0,this.pos=0,this.view=G,this.bytes=X,this.headByte=H,this.stack=[]}return e.prototype.setBuffer=function(e){this.bytes=E(e),this.view=function(e){if(e instanceof ArrayBuffer)return new DataView(e);var t=E(e);return new DataView(t.buffer,t.byteOffset,t.byteLength)}(this.bytes),this.pos=0},e.prototype.appendBuffer=function(e){if(this.headByte!==H||this.hasRemaining()){var t=this.bytes.subarray(this.pos),r=E(e),n=new Uint8Array(t.length+r.length);n.set(t),n.set(r,t.length),this.setBuffer(n)}else this.setBuffer(e)},e.prototype.hasRemaining=function(e){return void 0===e&&(e=1),this.view.byteLength-this.pos>=e},e.prototype.createNoExtraBytesError=function(e){var t=this.view,r=this.pos;return new RangeError("Extra "+(t.byteLength-r)+" byte(s) found at buffer["+e+"]")},e.prototype.decodeSingleSync=function(){var e=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return e},e.prototype.decodeSingleAsync=function(e){var t,r,n,i;return K(this,void 0,void 0,function(){var o,s,a,h,u,c,f,l;return _(this,function(p){switch(p.label){case 0:o=!1,p.label=1;case 1:p.trys.push([1,6,7,12]),t=V(e),p.label=2;case 2:return[4,t.next()];case 3:if((r=p.sent()).done)return[3,5];if(a=r.value,o)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(a);try{s=this.decodeSync(),o=!0}catch(e){if(!(e instanceof q))throw e}this.totalPos+=this.pos,p.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return h=p.sent(),n={error:h},[3,12];case 7:return p.trys.push([7,,10,11]),r&&!r.done&&(i=t.return)?[4,i.call(t)]:[3,9];case 8:p.sent(),p.label=9;case 9:return[3,11];case 10:if(n)throw n.error;return[7];case 11:return[7];case 12:if(o){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,s]}throw c=(u=this).headByte,f=u.pos,l=u.totalPos,new RangeError("Insufficient data in parcing "+j(c)+" at "+l+" ("+f+" in the current buffer)")}})})},e.prototype.decodeArrayStream=function(e){return this.decodeMultiAsync(e,!0)},e.prototype.decodeStream=function(e){return this.decodeMultiAsync(e,!1)},e.prototype.decodeMultiAsync=function(e,t){return R(this,arguments,function(){var r,n,i,o,s,a,h,u,c;return _(this,function(f){switch(f.label){case 0:r=t,n=-1,f.label=1;case 1:f.trys.push([1,13,14,19]),i=V(e),f.label=2;case 2:return[4,N(i.next())];case 3:if((o=f.sent()).done)return[3,12];if(s=o.value,t&&0===n)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(s),r&&(n=this.readArraySize(),r=!1,this.complete()),f.label=4;case 4:f.trys.push([4,9,,10]),f.label=5;case 5:return[4,N(this.decodeSync())];case 6:return[4,f.sent()];case 7:return f.sent(),0==--n?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((a=f.sent())instanceof q))throw a;return[3,10];case 10:this.totalPos+=this.pos,f.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return h=f.sent(),u={error:h},[3,19];case 14:return f.trys.push([14,,17,18]),o&&!o.done&&(c=i.return)?[4,N(c.call(i))]:[3,16];case 15:f.sent(),f.label=16;case 16:return[3,18];case 17:if(u)throw u.error;return[7];case 18:return[7];case 19:return[2]}})})},e.prototype.decodeSync=function(){e:for(;;){var e=this.readHeadByte(),t=void 0;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){if(0!==(n=e-128)){this.pushMapState(n),this.complete();continue e}t={}}else if(e<160){if(0!==(n=e-144)){this.pushArrayState(n),this.complete();continue e}t=[]}else{var r=e-160;t=this.decodeUtf8String(r,0)}else if(192===e)t=null;else if(194===e)t=!1;else if(195===e)t=!0;else if(202===e)t=this.readF32();else if(203===e)t=this.readF64();else if(204===e)t=this.readU8();else if(205===e)t=this.readU16();else if(206===e)t=this.readU32();else if(207===e)t=this.readU64();else if(208===e)t=this.readI8();else if(209===e)t=this.readI16();else if(210===e)t=this.readI32();else if(211===e)t=this.readI64();else if(217===e){r=this.lookU8();t=this.decodeUtf8String(r,1)}else if(218===e){r=this.lookU16();t=this.decodeUtf8String(r,2)}else if(219===e){r=this.lookU32();t=this.decodeUtf8String(r,4)}else if(220===e){if(0!==(n=this.readU16())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(221===e){if(0!==(n=this.readU32())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(222===e){if(0!==(n=this.readU16())){this.pushMapState(n),this.complete();continue e}t={}}else if(223===e){if(0!==(n=this.readU32())){this.pushMapState(n),this.complete();continue e}t={}}else if(196===e){var n=this.lookU8();t=this.decodeBinary(n,1)}else if(197===e){n=this.lookU16();t=this.decodeBinary(n,2)}else if(198===e){n=this.lookU32();t=this.decodeBinary(n,4)}else if(212===e)t=this.decodeExtension(1,0);else if(213===e)t=this.decodeExtension(2,0);else if(214===e)t=this.decodeExtension(4,0);else if(215===e)t=this.decodeExtension(8,0);else if(216===e)t=this.decodeExtension(16,0);else if(199===e){n=this.lookU8();t=this.decodeExtension(n,1)}else if(200===e){n=this.lookU16();t=this.decodeExtension(n,2)}else{if(201!==e)throw new Error("Unrecognized type byte: "+j(e));n=this.lookU32();t=this.decodeExtension(n,4)}this.complete();for(var i=this.stack;i.length>0;){var o=i[i.length-1];if(0===o.type){if(o.array[o.position]=t,o.position++,o.position!==o.size)continue e;i.pop(),t=o.array}else{if(1===o.type){if(s=void 0,"string"!==(s=typeof t)&&"number"!==s)throw new Error("The type of key must be string or number but "+typeof t);o.key=t,o.type=2;continue e}if(2===o.type){if(o.map[o.key]=t,o.readCount++,o.readCount!==o.size){o.key=null,o.type=1;continue e}i.pop(),t=o.map}}}return t}var s},e.prototype.readHeadByte=function(){return this.headByte===H&&(this.headByte=this.readU8()),this.headByte},e.prototype.complete=function(){this.headByte=H},e.prototype.readArraySize=function(){var e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:if(e<160)return e-144;throw new Error("Unrecognized array type byte: "+j(e))}},e.prototype.pushMapState=function(e){if(e>this.maxMapLength)throw new Error("Max length exceeded: map length ("+e+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:e,key:null,readCount:0,map:{}})},e.prototype.pushArrayState=function(e){if(e>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+e+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:e,array:new Array(e),position:0})},e.prototype.decodeUtf8String=function(e,t){if(e>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+e+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+t+e)throw J;var r,n=this.pos+t;return r=this.cachedKeyDecoder&&this.stateIsMapKey()&&this.cachedKeyDecoder.canBeCached(e)?this.cachedKeyDecoder.decode(this.bytes,n,e):o&&e>200?function(e,t,r){var n=e.subarray(t,t+r);return f.decode(n)}(this.bytes,n,e):A&&e>1024?I(this.bytes,n,e):c(this.bytes,n,e),this.pos+=t+e,r},e.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},e.prototype.decodeBinary=function(e,t){if(e>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+e+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(e+t))throw J;var r=this.pos+t,n=this.bytes.subarray(r,r+e);return this.pos+=t+e,n},e.prototype.decodeExtension=function(e,t){if(e>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+e+") > maxExtLength ("+this.maxExtLength+")");var r=this.view.getInt8(this.pos+t),n=this.decodeBinary(e,t+1);return this.extensionCodec.decode(n,r)},e.prototype.lookU8=function(){return this.view.getUint8(this.pos)},e.prototype.lookU16=function(){return this.view.getUint16(this.pos)},e.prototype.lookU32=function(){return this.view.getUint32(this.pos)},e.prototype.readU8=function(){var e=this.view.getUint8(this.pos);return this.pos++,e},e.prototype.readI8=function(){var e=this.view.getInt8(this.pos);return this.pos++,e},e.prototype.readU16=function(){var e=this.view.getUint16(this.pos);return this.pos+=2,e},e.prototype.readI16=function(){var e=this.view.getInt16(this.pos);return this.pos+=2,e},e.prototype.readU32=function(){var e=this.view.getUint32(this.pos);return this.pos+=4,e},e.prototype.readI32=function(){var e=this.view.getInt32(this.pos);return this.pos+=4,e},e.prototype.readU64=function(){var e,t,r=(e=this.view,t=this.pos,4294967296*e.getUint32(t)+e.getUint32(t+4));return this.pos+=8,r},e.prototype.readI64=function(){var e=d(this.view,this.pos);return this.pos+=8,e},e.prototype.readF32=function(){var e=this.view.getFloat32(this.pos);return this.pos+=4,e},e.prototype.readF64=function(){var e=this.view.getFloat64(this.pos);return this.pos+=8,e},e}(),$={};function ee(e,t){void 0===t&&(t=$);var r=new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength);return r.setBuffer(e),r.decodeSingleSync()}var te=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},re=function(e){return this instanceof re?(this.v=e,this):new re(e)},ne=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise(function(r,n){o.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{(r=i[e](t)).value instanceof re?Promise.resolve(r.value.v).then(h,u):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function h(e){a("next",e)}function u(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}};function ie(e){return null!=e[Symbol.asyncIterator]?e:function(e){return ne(this,arguments,function(){var t,r,n,i;return te(this,function(o){switch(o.label){case 0:t=e.getReader(),o.label=1;case 1:o.trys.push([1,,9,10]),o.label=2;case 2:return[4,re(t.read())];case 3:return r=o.sent(),n=r.done,i=r.value,n?[4,re(void 0)]:[3,5];case 4:return[2,o.sent()];case 5:return[4,re(i)];case 6:return[4,o.sent()];case 7:return o.sent(),[3,2];case 8:return[3,10];case 9:return t.releaseLock(),[7];case 10:return[2]}})})}(e)}var oe=function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function s(e){try{h(n.next(e))}catch(e){o(e)}}function a(e){try{h(n.throw(e))}catch(e){o(e)}}function h(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r(function(e){e(t)})).then(s,a)}h((n=n.apply(e,t||[])).next())})},se=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}};function ae(e,t){return void 0===t&&(t=$),oe(this,void 0,void 0,function(){var r;return se(this,function(n){return r=ie(e),[2,new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeSingleAsync(r)]})})}function he(e,t){void 0===t&&(t=$);var r=ie(e);return new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeArrayStream(r)}function ue(e,t){void 0===t&&(t=$);var r=ie(e);return new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeStream(r)}r.d(t,"encode",function(){return P}),r.d(t,"decode",function(){return ee}),r.d(t,"decodeAsync",function(){return ae}),r.d(t,"decodeArrayStream",function(){return he}),r.d(t,"decodeStream",function(){return ue}),r.d(t,"Decoder",function(){return Z}),r.d(t,"Encoder",function(){return C}),r.d(t,"ExtensionCodec",function(){return S}),r.d(t,"ExtData",function(){return l}),r.d(t,"EXT_TIMESTAMP",function(){return-1}),r.d(t,"encodeDateToTimeSpec",function(){return g}),r.d(t,"encodeTimeSpecToTimestamp",function(){return v}),r.d(t,"decodeTimestampToTimeSpec",function(){return m}),r.d(t,"encodeTimestampExtension",function(){return b}),r.d(t,"decodeTimestampExtension",function(){return U}),r.d(t,"__WASM_AVAILABLE",function(){return A})}])});

},{}],2:[function(require,module,exports){
(function (global){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":13,"util/":5}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],5:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":4,"_process":14,"inherits":3}],6:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],7:[function(require,module,exports){

},{}],8:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":6,"buffer":8,"ieee754":11}],9:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(require,module,exports){
(function (process,global){
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var root = typeof window === 'object' ? window : {};
  var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  }
  var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var BASE32_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'.split('');
  var BASE32_DECODE_CHAR = {
    'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8,
    'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16,
    'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24,
    'Z': 25, '2': 26, '3': 27, '4': 28, '5': 29, '6': 30, '7': 31
  };

  var blocks = [0, 0, 0, 0, 0, 0, 0, 0];

  var throwInvalidUtf8 = function (position, partial) {
    if (partial.length > 10) {
      partial = '...' + partial.substr(-10);
    }
    var err = new Error('Decoded data is not valid UTF-8.'
      + ' Maybe try base32.decode.asBytes()?'
      + ' Partial data after reading ' + position + ' bytes: ' + partial + ' <-');
    err.position = position;
    throw err;
  };

  var toUtf8String = function (bytes) {
    var str = '', length = bytes.length, i = 0, followingChars = 0, b, c;
    while (i < length) {
      b = bytes[i++];
      if (b <= 0x7F) {
        str += String.fromCharCode(b);
        continue;
      } else if (b > 0xBF && b <= 0xDF) {
        c = b & 0x1F;
        followingChars = 1;
      } else if (b <= 0xEF) {
        c = b & 0x0F;
        followingChars = 2;
      } else if (b <= 0xF7) {
        c = b & 0x07;
        followingChars = 3;
      } else {
        throwInvalidUtf8(i, str);
      }

      for (var j = 0; j < followingChars; ++j) {
        b = bytes[i++];
        if (b < 0x80 || b > 0xBF) {
          throwInvalidUtf8(i, str);
        }
        c <<= 6;
        c += b & 0x3F;
      }
      if (c >= 0xD800 && c <= 0xDFFF) {
        throwInvalidUtf8(i, str);
      }
      if (c > 0x10FFFF) {
        throwInvalidUtf8(i, str);
      }

      if (c <= 0xFFFF) {
        str += String.fromCharCode(c);
      } else {
        c -= 0x10000;
        str += String.fromCharCode((c >> 10) + 0xD800);
        str += String.fromCharCode((c & 0x3FF) + 0xDC00);
      }
    }
    return str;
  };

  var decodeAsBytes = function (base32Str) {
    if (!/^[A-Z2-7=]+$/.test(base32Str)) {
      throw new Error('Invalid base32 characters');
    }
    base32Str = base32Str.replace(/=/g, '');
    var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;

    // 4 char to 3 bytes
    for (var i = 0, count = length >> 3 << 3; i < count;) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
      bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
      bytes[index++] = (v7 << 5 | v8) & 255;
    }

    // remain bytes
    var remain = length - count;
    if (remain === 2) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
    } else if (remain === 4) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
    } else if (remain === 5) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
    } else if (remain === 7) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
      bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
    }
    return bytes;
  };

  var encodeAscii = function (str) {
    var v1, v2, v3, v4, v5, base32Str = '', length = str.length;
    for (var i = 0, count = parseInt(length / 5) * 5; i < count;) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i++);
      v3 = str.charCodeAt(i++);
      v4 = str.charCodeAt(i++);
      v5 = str.charCodeAt(i++);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] +
        BASE32_ENCODE_CHAR[v5 & 31];
    }

    // remain char
    var remain = length - count;
    if (remain === 1) {
      v1 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2) & 31] +
        '======';
    } else if (remain === 2) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4) & 31] +
        '====';
    } else if (remain === 3) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i++);
      v3 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1) & 31] +
        '===';
    } else if (remain === 4) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i++);
      v3 = str.charCodeAt(i++);
      v4 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3) & 31] +
        '=';
    }
    return base32Str;
  };

  var encodeUtf8 = function (str) {
    var v1, v2, v3, v4, v5, code, end = false, base32Str = '',
      index = 0, i, start = 0, bytes = 0, length = str.length;
    do {
      blocks[0] = blocks[5];
      blocks[1] = blocks[6];
      blocks[2] = blocks[7];
      for (i = start; index < length && i < 5; ++index) {
        code = str.charCodeAt(index);
        if (code < 0x80) {
          blocks[i++] = code;
        } else if (code < 0x800) {
          blocks[i++] = 0xc0 | (code >> 6);
          blocks[i++] = 0x80 | (code & 0x3f);
        } else if (code < 0xd800 || code >= 0xe000) {
          blocks[i++] = 0xe0 | (code >> 12);
          blocks[i++] = 0x80 | ((code >> 6) & 0x3f);
          blocks[i++] = 0x80 | (code & 0x3f);
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++index) & 0x3ff));
          blocks[i++] = 0xf0 | (code >> 18);
          blocks[i++] = 0x80 | ((code >> 12) & 0x3f);
          blocks[i++] = 0x80 | ((code >> 6) & 0x3f);
          blocks[i++] = 0x80 | (code & 0x3f);
        }
      }
      bytes += i - start;
      start = i - 5;
      if (index === length) {
        ++index;
      }
      if (index > length && i < 6) {
        end = true;
      }
      v1 = blocks[0];
      if (i > 4) {
        v2 = blocks[1];
        v3 = blocks[2];
        v4 = blocks[3];
        v5 = blocks[4];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
          BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
          BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
          BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] +
          BASE32_ENCODE_CHAR[v5 & 31];
      } else if (i === 1) {
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2) & 31] +
          '======';
      } else if (i === 2) {
        v2 = blocks[1];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4) & 31] +
          '====';
      } else if (i === 3) {
        v2 = blocks[1];
        v3 = blocks[2];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
          BASE32_ENCODE_CHAR[(v3 << 1) & 31] +
          '===';
      } else {
        v2 = blocks[1];
        v3 = blocks[2];
        v4 = blocks[3];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
          BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
          BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
          BASE32_ENCODE_CHAR[(v4 << 3) & 31] +
          '=';
      }
    } while (!end);
    return base32Str;
  };

  var encodeBytes = function (bytes) {
    var v1, v2, v3, v4, v5, base32Str = '', length = bytes.length;
    for (var i = 0, count = parseInt(length / 5) * 5; i < count;) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      v4 = bytes[i++];
      v5 = bytes[i++];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] +
        BASE32_ENCODE_CHAR[v5 & 31];
    }

    // remain char
    var remain = length - count;
    if (remain === 1) {
      v1 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2) & 31] +
        '======';
    } else if (remain === 2) {
      v1 = bytes[i++];
      v2 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4) & 31] +
        '====';
    } else if (remain === 3) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1) & 31] +
        '===';
    } else if (remain === 4) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      v4 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3) & 31] +
        '=';
    }
    return base32Str;
  };

  var encode = function (input, asciiOnly) {
    var notString = typeof(input) !== 'string';
    if (notString && input.constructor === ArrayBuffer) {
      input = new Uint8Array(input);
    }
    if (notString) {
      return encodeBytes(input);
    } else if (asciiOnly) {
      return encodeAscii(input);
    } else {
      return encodeUtf8(input);
    }
  };

  var decode = function (base32Str, asciiOnly) {
    if (!asciiOnly) {
      return toUtf8String(decodeAsBytes(base32Str));
    }
    if (!/^[A-Z2-7=]+$/.test(base32Str)) {
      throw new Error('Invalid base32 characters');
    }
    var v1, v2, v3, v4, v5, v6, v7, v8, str = '', length = base32Str.indexOf('=');
    if (length === -1) {
      length = base32Str.length;
    }

    // 8 char to 5 bytes
    for (var i = 0, count = length >> 3 << 3; i < count;) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) +
        String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) +
        String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) +
        String.fromCharCode((v7 << 5 | v8) & 255);
    }

    // remain bytes
    var remain = length - count;
    if (remain === 2) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
    } else if (remain === 4) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
    } else if (remain === 5) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) +
        String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
    } else if (remain === 7) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) +
        String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) +
        String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
    }
    return str;
  };

  var exports = {
    encode: encode,
    decode: decode
  };
  decode.asBytes = decodeAsBytes;

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.base32 = exports;
    if (AMD) {
      define(function() {
        return exports;
      });
    }
  }
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":14}],11:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],12:[function(require,module,exports){
(function (process,global){
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA512_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD,
    0xB5C0FBCF, 0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC,
    0x3956C25B, 0xF348B538, 0x59F111F1, 0xB605D019,
    0x923F82A4, 0xAF194F9B, 0xAB1C5ED5, 0xDA6D8118,
    0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,
    0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2,
    0x72BE5D74, 0xF27B896F, 0x80DEB1FE, 0x3B1696B1,
    0x9BDC06A7, 0x25C71235, 0xC19BF174, 0xCF692694,
    0xE49B69C1, 0x9EF14AD2, 0xEFBE4786, 0x384F25E3,
    0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,
    0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483,
    0x5CB0A9DC, 0xBD41FBD4, 0x76F988DA, 0x831153B5,
    0x983E5152, 0xEE66DFAB, 0xA831C66D, 0x2DB43210,
    0xB00327C8, 0x98FB213F, 0xBF597FC7, 0xBEEF0EE4,
    0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,
    0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70,
    0x27B70A85, 0x46D22FFC, 0x2E1B2138, 0x5C26C926,
    0x4D2C6DFC, 0x5AC42AED, 0x53380D13, 0x9D95B3DF,
    0x650A7354, 0x8BAF63DE, 0x766A0ABB, 0x3C77B2A8,
    0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,
    0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001,
    0xC24B8B70, 0xD0F89791, 0xC76C51A3, 0x0654BE30,
    0xD192E819, 0xD6EF5218, 0xD6990624, 0x5565A910,
    0xF40E3585, 0x5771202A, 0x106AA070, 0x32BBD1B8,
    0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,
    0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8,
    0x391C0CB3, 0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB,
    0x5B9CCA4F, 0x7763E373, 0x682E6FF3, 0xD6B2B8A3,
    0x748F82EE, 0x5DEFB2FC, 0x78A5636F, 0x43172F60,
    0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,
    0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9,
    0xBEF9A3F7, 0xB2C67915, 0xC67178F2, 0xE372532B,
    0xCA273ECE, 0xEA26619C, 0xD186B8C7, 0x21C0C207,
    0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F, 0xEE6ED178,
    0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,
    0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B,
    0x28DB77F5, 0x23047D84, 0x32CAAB7B, 0x40C72493,
    0x3C9EBE0A, 0x15C9BEBC, 0x431D67C4, 0x9C100D4C,
    0x4CC5D4BE, 0xCB3E42B6, 0x597F299C, 0xFC657E2A,
    0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817
  ];

  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, bits) {
    return function (message) {
      return new Sha512(bits, true).update(message)[outputType]();
    };
  };

  var createMethod = function (bits) {
    var method = createOutputMethod('hex', bits);
    method.create = function () {
      return new Sha512(bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, bits);
    }
    return method;
  };

  var createHmacOutputMethod = function (outputType, bits) {
    return function (key, message) {
      return new HmacSha512(key, bits, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (bits) {
    var method = createHmacOutputMethod('hex', bits);
    method.create = function (key) {
      return new HmacSha512(key, bits);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, bits);
    }
    return method;
  };

  function Sha512(bits, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] =
      blocks[5] = blocks[6] = blocks[7] = blocks[8] =
      blocks[9] = blocks[10] = blocks[11] = blocks[12] =
      blocks[13] = blocks[14] = blocks[15] = blocks[16] =
      blocks[17] = blocks[18] = blocks[19] = blocks[20] =
      blocks[21] = blocks[22] = blocks[23] = blocks[24] =
      blocks[25] = blocks[26] = blocks[27] = blocks[28] =
      blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (bits == 384) {
      this.h0h = 0xCBBB9D5D;
      this.h0l = 0xC1059ED8;
      this.h1h = 0x629A292A;
      this.h1l = 0x367CD507;
      this.h2h = 0x9159015A;
      this.h2l = 0x3070DD17;
      this.h3h = 0x152FECD8;
      this.h3l = 0xF70E5939;
      this.h4h = 0x67332667;
      this.h4l = 0xFFC00B31;
      this.h5h = 0x8EB44A87;
      this.h5l = 0x68581511;
      this.h6h = 0xDB0C2E0D;
      this.h6l = 0x64F98FA7;
      this.h7h = 0x47B5481D;
      this.h7l = 0xBEFA4FA4;
    } else if (bits == 256) {
      this.h0h = 0x22312194;
      this.h0l = 0xFC2BF72C;
      this.h1h = 0x9F555FA3;
      this.h1l = 0xC84C64C2;
      this.h2h = 0x2393B86B;
      this.h2l = 0x6F53B151;
      this.h3h = 0x96387719;
      this.h3l = 0x5940EABD;
      this.h4h = 0x96283EE2;
      this.h4l = 0xA88EFFE3;
      this.h5h = 0xBE5E1E25;
      this.h5l = 0x53863992;
      this.h6h = 0x2B0199FC;
      this.h6l = 0x2C85B8AA;
      this.h7h = 0x0EB72DDC;
      this.h7l = 0x81C52CA2;
    } else if (bits == 224) {
      this.h0h = 0x8C3D37C8;
      this.h0l = 0x19544DA2;
      this.h1h = 0x73E19966;
      this.h1l = 0x89DCD4D6;
      this.h2h = 0x1DFAB7AE;
      this.h2l = 0x32FF9C82;
      this.h3h = 0x679DD514;
      this.h3l = 0x582F9FCF;
      this.h4h = 0x0F6D2B69;
      this.h4l = 0x7BD44DA8;
      this.h5h = 0x77E36F73;
      this.h5l = 0x04C48942;
      this.h6h = 0x3F9D85A8;
      this.h6l = 0x6A1D36C8;
      this.h7h = 0x1112E6AD;
      this.h7l = 0x91D692A1;
    } else { // 512
      this.h0h = 0x6A09E667;
      this.h0l = 0xF3BCC908;
      this.h1h = 0xBB67AE85;
      this.h1l = 0x84CAA73B;
      this.h2h = 0x3C6EF372;
      this.h2l = 0xFE94F82B;
      this.h3h = 0xA54FF53A;
      this.h3l = 0x5F1D36F1;
      this.h4h = 0x510E527F;
      this.h4l = 0xADE682D1;
      this.h5h = 0x9B05688C;
      this.h5l = 0x2B3E6C1F;
      this.h6h = 0x1F83D9AB;
      this.h6l = 0xFB41BD6B;
      this.h7h = 0x5BE0CD19;
      this.h7l = 0x137E2179;
    }
    this.bits = bits;

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
  }

  Sha512.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[1] = blocks[2] = blocks[3] = blocks[4] =
        blocks[5] = blocks[6] = blocks[7] = blocks[8] =
        blocks[9] = blocks[10] = blocks[11] = blocks[12] =
        blocks[13] = blocks[14] = blocks[15] = blocks[16] =
        blocks[17] = blocks[18] = blocks[19] = blocks[20] =
        blocks[21] = blocks[22] = blocks[23] = blocks[24] =
        blocks[25] = blocks[26] = blocks[27] = blocks[28] =
        blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
      }

      if(notString) {
        for (i = this.start; index < length && i < 128; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 128; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 128) {
        this.block = blocks[32];
        this.start = i - 128;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha512.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[32] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[32];
    if (i >= 112) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[1] = blocks[2] = blocks[3] = blocks[4] =
      blocks[5] = blocks[6] = blocks[7] = blocks[8] =
      blocks[9] = blocks[10] = blocks[11] = blocks[12] =
      blocks[13] = blocks[14] = blocks[15] = blocks[16] =
      blocks[17] = blocks[18] = blocks[19] = blocks[20] =
      blocks[21] = blocks[22] = blocks[23] = blocks[24] =
      blocks[25] = blocks[26] = blocks[27] = blocks[28] =
      blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
    }
    blocks[30] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[31] = this.bytes << 3;
    this.hash();
  };

  Sha512.prototype.hash = function () {
    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l,
      h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l,
      h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l,
      h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l,
      blocks = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4,
      abh, abl, dah, dal, cdh, cdl, bch, bcl,
      majh, majl, t1h, t1l, t2h, t2l, chh, chl;

    for (j = 32; j < 160; j += 2) {
      t1h = blocks[j - 30];
      t1l = blocks[j - 29];
      s0h = ((t1h >>> 1) | (t1l << 31)) ^ ((t1h >>> 8) | (t1l << 24)) ^ (t1h >>> 7);
      s0l = ((t1l >>> 1) | (t1h << 31)) ^ ((t1l >>> 8) | (t1h << 24)) ^ ((t1l >>> 7) | t1h << 25);

      t1h = blocks[j - 4];
      t1l = blocks[j - 3];
      s1h = ((t1h >>> 19) | (t1l << 13)) ^ ((t1l >>> 29) | (t1h << 3)) ^ (t1h >>> 6);
      s1l = ((t1l >>> 19) | (t1h << 13)) ^ ((t1h >>> 29) | (t1l << 3)) ^ ((t1l >>> 6) | t1h << 26);

      t1h = blocks[j - 32];
      t1l = blocks[j - 31];
      t2h = blocks[j - 14];
      t2l = blocks[j - 13];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (s0l & 0xFFFF) + (s1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (s0h & 0xFFFF) + (s1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);

      blocks[j] = (c4 << 16) | (c3 & 0xFFFF);
      blocks[j + 1] = (c2 << 16) | (c1 & 0xFFFF);
    }

    var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
    bch = bh & ch;
    bcl = bl & cl;
    for (j = 0; j < 160; j += 8) {
      s0h = ((ah >>> 28) | (al << 4)) ^ ((al >>> 2) | (ah << 30)) ^ ((al >>> 7) | (ah << 25));
      s0l = ((al >>> 28) | (ah << 4)) ^ ((ah >>> 2) | (al << 30)) ^ ((ah >>> 7) | (al << 25));

      s1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((el >>> 9) | (eh << 23));
      s1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((eh >>> 9) | (el << 23));

      abh = ah & bh;
      abl = al & bl;
      majh = abh ^ (ah & ch) ^ bch;
      majl = abl ^ (al & cl) ^ bcl;

      chh = (eh & fh) ^ (~eh & gh);
      chl = (el & fl) ^ (~el & gl);

      t1h = blocks[j];
      t1l = blocks[j + 1];
      t2h = K[j];
      t2l = K[j + 1];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (hl & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (dl & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (dh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      hh = (c4 << 16) | (c3 & 0xFFFF);
      hl = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      dh = (c4 << 16) | (c3 & 0xFFFF);
      dl = (c2 << 16) | (c1 & 0xFFFF);

      s0h = ((dh >>> 28) | (dl << 4)) ^ ((dl >>> 2) | (dh << 30)) ^ ((dl >>> 7) | (dh << 25));
      s0l = ((dl >>> 28) | (dh << 4)) ^ ((dh >>> 2) | (dl << 30)) ^ ((dh >>> 7) | (dl << 25));

      s1h = ((hh >>> 14) | (hl << 18)) ^ ((hh >>> 18) | (hl << 14)) ^ ((hl >>> 9) | (hh << 23));
      s1l = ((hl >>> 14) | (hh << 18)) ^ ((hl >>> 18) | (hh << 14)) ^ ((hh >>> 9) | (hl << 23));

      dah = dh & ah;
      dal = dl & al;
      majh = dah ^ (dh & bh) ^ abh;
      majl = dal ^ (dl & bl) ^ abl;

      chh = (hh & eh) ^ (~hh & fh);
      chl = (hl & el) ^ (~hl & fl);

      t1h = blocks[j + 2];
      t1l = blocks[j + 3];
      t2h = K[j + 2];
      t2l = K[j + 3];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (gl & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (cl & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (ch & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      gh = (c4 << 16) | (c3 & 0xFFFF);
      gl = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      ch = (c4 << 16) | (c3 & 0xFFFF);
      cl = (c2 << 16) | (c1 & 0xFFFF);

      s0h = ((ch >>> 28) | (cl << 4)) ^ ((cl >>> 2) | (ch << 30)) ^ ((cl >>> 7) | (ch << 25));
      s0l = ((cl >>> 28) | (ch << 4)) ^ ((ch >>> 2) | (cl << 30)) ^ ((ch >>> 7) | (cl << 25));

      s1h = ((gh >>> 14) | (gl << 18)) ^ ((gh >>> 18) | (gl << 14)) ^ ((gl >>> 9) | (gh << 23));
      s1l = ((gl >>> 14) | (gh << 18)) ^ ((gl >>> 18) | (gh << 14)) ^ ((gh >>> 9) | (gl << 23));

      cdh = ch & dh;
      cdl = cl & dl;
      majh = cdh ^ (ch & ah) ^ dah;
      majl = cdl ^ (cl & al) ^ dal;

      chh = (gh & hh) ^ (~gh & eh);
      chl = (gl & hl) ^ (~gl & el);

      t1h = blocks[j + 4];
      t1l = blocks[j + 5];
      t2h = K[j + 4];
      t2l = K[j + 5];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (fl & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (bl & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (bh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      fh = (c4 << 16) | (c3 & 0xFFFF);
      fl = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      bh = (c4 << 16) | (c3 & 0xFFFF);
      bl = (c2 << 16) | (c1 & 0xFFFF);

      s0h = ((bh >>> 28) | (bl << 4)) ^ ((bl >>> 2) | (bh << 30)) ^ ((bl >>> 7) | (bh << 25));
      s0l = ((bl >>> 28) | (bh << 4)) ^ ((bh >>> 2) | (bl << 30)) ^ ((bh >>> 7) | (bl << 25));

      s1h = ((fh >>> 14) | (fl << 18)) ^ ((fh >>> 18) | (fl << 14)) ^ ((fl >>> 9) | (fh << 23));
      s1l = ((fl >>> 14) | (fh << 18)) ^ ((fl >>> 18) | (fh << 14)) ^ ((fh >>> 9) | (fl << 23));

      bch = bh & ch;
      bcl = bl & cl;
      majh = bch ^ (bh & dh) ^ cdh;
      majl = bcl ^ (bl & dl) ^ cdl;

      chh = (fh & gh) ^ (~fh & hh);
      chl = (fl & gl) ^ (~fl & hl);

      t1h = blocks[j + 6];
      t1l = blocks[j + 7];
      t2h = K[j + 6];
      t2l = K[j + 7];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (el & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (al & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (ah & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      eh = (c4 << 16) | (c3 & 0xFFFF);
      el = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      ah = (c4 << 16) | (c3 & 0xFFFF);
      al = (c2 << 16) | (c1 & 0xFFFF);
    }

    c1 = (h0l & 0xFFFF) + (al & 0xFFFF);
    c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
    c3 = (h0h & 0xFFFF) + (ah & 0xFFFF) + (c2 >>> 16);
    c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);

    this.h0h = (c4 << 16) | (c3 & 0xFFFF);
    this.h0l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h1l & 0xFFFF) + (bl & 0xFFFF);
    c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
    c3 = (h1h & 0xFFFF) + (bh & 0xFFFF) + (c2 >>> 16);
    c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);

    this.h1h = (c4 << 16) | (c3 & 0xFFFF);
    this.h1l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h2l & 0xFFFF) + (cl & 0xFFFF);
    c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
    c3 = (h2h & 0xFFFF) + (ch & 0xFFFF) + (c2 >>> 16);
    c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);

    this.h2h = (c4 << 16) | (c3 & 0xFFFF);
    this.h2l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h3l & 0xFFFF) + (dl & 0xFFFF);
    c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
    c3 = (h3h & 0xFFFF) + (dh & 0xFFFF) + (c2 >>> 16);
    c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);

    this.h3h = (c4 << 16) | (c3 & 0xFFFF);
    this.h3l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h4l & 0xFFFF) + (el & 0xFFFF);
    c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
    c3 = (h4h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
    c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);

    this.h4h = (c4 << 16) | (c3 & 0xFFFF);
    this.h4l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h5l & 0xFFFF) + (fl & 0xFFFF);
    c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
    c3 = (h5h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
    c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);

    this.h5h = (c4 << 16) | (c3 & 0xFFFF);
    this.h5l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h6l & 0xFFFF) + (gl & 0xFFFF);
    c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
    c3 = (h6h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
    c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);

    this.h6h = (c4 << 16) | (c3 & 0xFFFF);
    this.h6l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h7l & 0xFFFF) + (hl & 0xFFFF);
    c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
    c3 = (h7h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
    c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);

    this.h7h = (c4 << 16) | (c3 & 0xFFFF);
    this.h7l = (c2 << 16) | (c1 & 0xFFFF);
  };

  Sha512.prototype.hex = function () {
    this.finalize();

    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l,
      h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l,
      h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l,
      h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l,
      bits = this.bits;

    var hex = HEX_CHARS[(h0h >> 28) & 0x0F] + HEX_CHARS[(h0h >> 24) & 0x0F] +
      HEX_CHARS[(h0h >> 20) & 0x0F] + HEX_CHARS[(h0h >> 16) & 0x0F] +
      HEX_CHARS[(h0h >> 12) & 0x0F] + HEX_CHARS[(h0h >> 8) & 0x0F] +
      HEX_CHARS[(h0h >> 4) & 0x0F] + HEX_CHARS[h0h & 0x0F] +
      HEX_CHARS[(h0l >> 28) & 0x0F] + HEX_CHARS[(h0l >> 24) & 0x0F] +
      HEX_CHARS[(h0l >> 20) & 0x0F] + HEX_CHARS[(h0l >> 16) & 0x0F] +
      HEX_CHARS[(h0l >> 12) & 0x0F] + HEX_CHARS[(h0l >> 8) & 0x0F] +
      HEX_CHARS[(h0l >> 4) & 0x0F] + HEX_CHARS[h0l & 0x0F] +
      HEX_CHARS[(h1h >> 28) & 0x0F] + HEX_CHARS[(h1h >> 24) & 0x0F] +
      HEX_CHARS[(h1h >> 20) & 0x0F] + HEX_CHARS[(h1h >> 16) & 0x0F] +
      HEX_CHARS[(h1h >> 12) & 0x0F] + HEX_CHARS[(h1h >> 8) & 0x0F] +
      HEX_CHARS[(h1h >> 4) & 0x0F] + HEX_CHARS[h1h & 0x0F] +
      HEX_CHARS[(h1l >> 28) & 0x0F] + HEX_CHARS[(h1l >> 24) & 0x0F] +
      HEX_CHARS[(h1l >> 20) & 0x0F] + HEX_CHARS[(h1l >> 16) & 0x0F] +
      HEX_CHARS[(h1l >> 12) & 0x0F] + HEX_CHARS[(h1l >> 8) & 0x0F] +
      HEX_CHARS[(h1l >> 4) & 0x0F] + HEX_CHARS[h1l & 0x0F] +
      HEX_CHARS[(h2h >> 28) & 0x0F] + HEX_CHARS[(h2h >> 24) & 0x0F] +
      HEX_CHARS[(h2h >> 20) & 0x0F] + HEX_CHARS[(h2h >> 16) & 0x0F] +
      HEX_CHARS[(h2h >> 12) & 0x0F] + HEX_CHARS[(h2h >> 8) & 0x0F] +
      HEX_CHARS[(h2h >> 4) & 0x0F] + HEX_CHARS[h2h & 0x0F] +
      HEX_CHARS[(h2l >> 28) & 0x0F] + HEX_CHARS[(h2l >> 24) & 0x0F] +
      HEX_CHARS[(h2l >> 20) & 0x0F] + HEX_CHARS[(h2l >> 16) & 0x0F] +
      HEX_CHARS[(h2l >> 12) & 0x0F] + HEX_CHARS[(h2l >> 8) & 0x0F] +
      HEX_CHARS[(h2l >> 4) & 0x0F] + HEX_CHARS[h2l & 0x0F] +
      HEX_CHARS[(h3h >> 28) & 0x0F] + HEX_CHARS[(h3h >> 24) & 0x0F] +
      HEX_CHARS[(h3h >> 20) & 0x0F] + HEX_CHARS[(h3h >> 16) & 0x0F] +
      HEX_CHARS[(h3h >> 12) & 0x0F] + HEX_CHARS[(h3h >> 8) & 0x0F] +
      HEX_CHARS[(h3h >> 4) & 0x0F] + HEX_CHARS[h3h & 0x0F];
    if (bits >= 256) {
      hex += HEX_CHARS[(h3l >> 28) & 0x0F] + HEX_CHARS[(h3l >> 24) & 0x0F] +
        HEX_CHARS[(h3l >> 20) & 0x0F] + HEX_CHARS[(h3l >> 16) & 0x0F] +
        HEX_CHARS[(h3l >> 12) & 0x0F] + HEX_CHARS[(h3l >> 8) & 0x0F] +
        HEX_CHARS[(h3l >> 4) & 0x0F] + HEX_CHARS[h3l & 0x0F];
    }
    if (bits >= 384) {
      hex += HEX_CHARS[(h4h >> 28) & 0x0F] + HEX_CHARS[(h4h >> 24) & 0x0F] +
        HEX_CHARS[(h4h >> 20) & 0x0F] + HEX_CHARS[(h4h >> 16) & 0x0F] +
        HEX_CHARS[(h4h >> 12) & 0x0F] + HEX_CHARS[(h4h >> 8) & 0x0F] +
        HEX_CHARS[(h4h >> 4) & 0x0F] + HEX_CHARS[h4h & 0x0F] +
        HEX_CHARS[(h4l >> 28) & 0x0F] + HEX_CHARS[(h4l >> 24) & 0x0F] +
        HEX_CHARS[(h4l >> 20) & 0x0F] + HEX_CHARS[(h4l >> 16) & 0x0F] +
        HEX_CHARS[(h4l >> 12) & 0x0F] + HEX_CHARS[(h4l >> 8) & 0x0F] +
        HEX_CHARS[(h4l >> 4) & 0x0F] + HEX_CHARS[h4l & 0x0F] +
        HEX_CHARS[(h5h >> 28) & 0x0F] + HEX_CHARS[(h5h >> 24) & 0x0F] +
        HEX_CHARS[(h5h >> 20) & 0x0F] + HEX_CHARS[(h5h >> 16) & 0x0F] +
        HEX_CHARS[(h5h >> 12) & 0x0F] + HEX_CHARS[(h5h >> 8) & 0x0F] +
        HEX_CHARS[(h5h >> 4) & 0x0F] + HEX_CHARS[h5h & 0x0F] +
        HEX_CHARS[(h5l >> 28) & 0x0F] + HEX_CHARS[(h5l >> 24) & 0x0F] +
        HEX_CHARS[(h5l >> 20) & 0x0F] + HEX_CHARS[(h5l >> 16) & 0x0F] +
        HEX_CHARS[(h5l >> 12) & 0x0F] + HEX_CHARS[(h5l >> 8) & 0x0F] +
        HEX_CHARS[(h5l >> 4) & 0x0F] + HEX_CHARS[h5l & 0x0F];
    }
    if (bits == 512) {
      hex += HEX_CHARS[(h6h >> 28) & 0x0F] + HEX_CHARS[(h6h >> 24) & 0x0F] +
        HEX_CHARS[(h6h >> 20) & 0x0F] + HEX_CHARS[(h6h >> 16) & 0x0F] +
        HEX_CHARS[(h6h >> 12) & 0x0F] + HEX_CHARS[(h6h >> 8) & 0x0F] +
        HEX_CHARS[(h6h >> 4) & 0x0F] + HEX_CHARS[h6h & 0x0F] +
        HEX_CHARS[(h6l >> 28) & 0x0F] + HEX_CHARS[(h6l >> 24) & 0x0F] +
        HEX_CHARS[(h6l >> 20) & 0x0F] + HEX_CHARS[(h6l >> 16) & 0x0F] +
        HEX_CHARS[(h6l >> 12) & 0x0F] + HEX_CHARS[(h6l >> 8) & 0x0F] +
        HEX_CHARS[(h6l >> 4) & 0x0F] + HEX_CHARS[h6l & 0x0F] +
        HEX_CHARS[(h7h >> 28) & 0x0F] + HEX_CHARS[(h7h >> 24) & 0x0F] +
        HEX_CHARS[(h7h >> 20) & 0x0F] + HEX_CHARS[(h7h >> 16) & 0x0F] +
        HEX_CHARS[(h7h >> 12) & 0x0F] + HEX_CHARS[(h7h >> 8) & 0x0F] +
        HEX_CHARS[(h7h >> 4) & 0x0F] + HEX_CHARS[h7h & 0x0F] +
        HEX_CHARS[(h7l >> 28) & 0x0F] + HEX_CHARS[(h7l >> 24) & 0x0F] +
        HEX_CHARS[(h7l >> 20) & 0x0F] + HEX_CHARS[(h7l >> 16) & 0x0F] +
        HEX_CHARS[(h7l >> 12) & 0x0F] + HEX_CHARS[(h7l >> 8) & 0x0F] +
        HEX_CHARS[(h7l >> 4) & 0x0F] + HEX_CHARS[h7l & 0x0F];
    }
    return hex;
  };

  Sha512.prototype.toString = Sha512.prototype.hex;

  Sha512.prototype.digest = function () {
    this.finalize();

    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l,
      h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l,
      h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l,
      h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l,
      bits = this.bits;

    var arr = [
      (h0h >> 24) & 0xFF, (h0h >> 16) & 0xFF, (h0h >> 8) & 0xFF, h0h & 0xFF,
      (h0l >> 24) & 0xFF, (h0l >> 16) & 0xFF, (h0l >> 8) & 0xFF, h0l & 0xFF,
      (h1h >> 24) & 0xFF, (h1h >> 16) & 0xFF, (h1h >> 8) & 0xFF, h1h & 0xFF,
      (h1l >> 24) & 0xFF, (h1l >> 16) & 0xFF, (h1l >> 8) & 0xFF, h1l & 0xFF,
      (h2h >> 24) & 0xFF, (h2h >> 16) & 0xFF, (h2h >> 8) & 0xFF, h2h & 0xFF,
      (h2l >> 24) & 0xFF, (h2l >> 16) & 0xFF, (h2l >> 8) & 0xFF, h2l & 0xFF,
      (h3h >> 24) & 0xFF, (h3h >> 16) & 0xFF, (h3h >> 8) & 0xFF, h3h & 0xFF
    ];

    if (bits >= 256) {
      arr.push((h3l >> 24) & 0xFF, (h3l >> 16) & 0xFF, (h3l >> 8) & 0xFF, h3l & 0xFF);
    }
    if (bits >= 384) {
      arr.push(
        (h4h >> 24) & 0xFF, (h4h >> 16) & 0xFF, (h4h >> 8) & 0xFF, h4h & 0xFF,
        (h4l >> 24) & 0xFF, (h4l >> 16) & 0xFF, (h4l >> 8) & 0xFF, h4l & 0xFF,
        (h5h >> 24) & 0xFF, (h5h >> 16) & 0xFF, (h5h >> 8) & 0xFF, h5h & 0xFF,
        (h5l >> 24) & 0xFF, (h5l >> 16) & 0xFF, (h5l >> 8) & 0xFF, h5l & 0xFF
      );
    }
    if (bits == 512) {
      arr.push(
        (h6h >> 24) & 0xFF, (h6h >> 16) & 0xFF, (h6h >> 8) & 0xFF, h6h & 0xFF,
        (h6l >> 24) & 0xFF, (h6l >> 16) & 0xFF, (h6l >> 8) & 0xFF, h6l & 0xFF,
        (h7h >> 24) & 0xFF, (h7h >> 16) & 0xFF, (h7h >> 8) & 0xFF, h7h & 0xFF,
        (h7l >> 24) & 0xFF, (h7l >> 16) & 0xFF, (h7l >> 8) & 0xFF, h7l & 0xFF
      );
    }
    return arr;
  };

  Sha512.prototype.array = Sha512.prototype.digest;

  Sha512.prototype.arrayBuffer = function () {
    this.finalize();

    var bits = this.bits;
    var buffer = new ArrayBuffer(bits / 8);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0h);
    dataView.setUint32(4, this.h0l);
    dataView.setUint32(8, this.h1h);
    dataView.setUint32(12, this.h1l);
    dataView.setUint32(16, this.h2h);
    dataView.setUint32(20, this.h2l);
    dataView.setUint32(24, this.h3h);

    if (bits >= 256) {
      dataView.setUint32(28, this.h3l);
    }
    if (bits >= 384) {
      dataView.setUint32(32, this.h4h);
      dataView.setUint32(36, this.h4l);
      dataView.setUint32(40, this.h5h);
      dataView.setUint32(44, this.h5l);
    }
    if (bits == 512) {
      dataView.setUint32(48, this.h6h);
      dataView.setUint32(52, this.h6l);
      dataView.setUint32(56, this.h7h);
      dataView.setUint32(60, this.h7l);
    }
    return buffer;
  };

  Sha512.prototype.clone = function () {
    var hash = new Sha512(this.bits, false);
    this.copyTo(hash);
    return hash;
  };

  Sha512.prototype.copyTo = function (hash) {
    var i = 0, attrs = [
      'h0h', 'h0l', 'h1h', 'h1l', 'h2h', 'h2l', 'h3h', 'h3l', 'h4h', 'h4l', 'h5h', 'h5l', 'h6h', 'h6l', 'h7h', 'h7l',
      'start', 'bytes', 'hBytes', 'finalized', 'hashed', 'lastByteIndex'
    ];
    for (i = 0; i < attrs.length; ++i) {
      hash[attrs[i]] = this[attrs[i]];
    }
    for (i = 0; i < this.blocks.length; ++i) {
      hash.blocks[i] = this.blocks[i];
    }
  };

  function HmacSha512(key, bits, sharedMemory) {
    var notString, type = typeof key;
    if (type !== 'string') {
      if (type === 'object') {
        if (key === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var length = key.length;
    if (!notString) {
      var bytes = [], length = key.length, index = 0, code;
      for (var i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    }

    if (key.length > 128) {
      key = (new Sha512(bits, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (var i = 0; i < 128; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha512.call(this, bits, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha512.prototype = new Sha512();

  HmacSha512.prototype.finalize = function () {
    Sha512.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha512.call(this, this.bits, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha512.prototype.finalize.call(this);
    }
  };

  HmacSha512.prototype.clone = function () {
    var hash = new HmacSha512([], this.bits, false);
    this.copyTo(hash);
    hash.inner = this.inner;
    for (var i = 0; i < this.oKeyPad.length; ++i) {
      hash.oKeyPad[i] = this.oKeyPad[i];
    }
    return hash;
  };

  var exports = createMethod(512);
  exports.sha512 = exports;
  exports.sha384 = createMethod(384);
  exports.sha512_256 = createMethod(256);
  exports.sha512_224 = createMethod(224);
  exports.sha512.hmac = createHmacMethod(512);
  exports.sha384.hmac = createHmacMethod(384);
  exports.sha512_256.hmac = createHmacMethod(256);
  exports.sha512_224.hmac = createHmacMethod(224);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha512 = exports.sha512;
    root.sha384 = exports.sha384;
    root.sha512_256 = exports.sha512_256;
    root.sha512_224 = exports.sha512_224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":14}],13:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],14:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],15:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(fn => {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(...args) {
    this._defaults.push({fn, args});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(def => {
      req[def.fn].apply(req, def.args);
    });
};

module.exports = Agent;

},{}],16:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

const Emitter = require('component-emitter');
const RequestBase = require('./request-base');
const isObject = require('./is-object');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

const request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim
  ? s => s.trim()
  : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  const pairs = [];
  for (const key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(v => {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(const subkey in val) {
        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  const obj = {};
  const pairs = str.split('&');
  let pair;
  let pos;

  for (let i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let val;

  for (let i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  let status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  const req = this.req;
  const method = req.method;
  const url = req.url;

  const msg = `cannot ${method} ${url} (${this.status})`;
  const err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let err = null;
    let res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    let new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  const encoder = string => {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  const fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  const err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = () => {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function() {
  if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));

  const self = this;
  const xhr = (this.xhr = request.getXHR());
  let data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = () => {
    const readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = () => new Agent();

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(method => {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    const req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":15,"./is-object":17,"./request-base":18,"./response-base":19,"component-emitter":9}],17:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],18:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
const isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(const option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

const ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {
      self.on('error', innerReject);
      self.on('abort', () => {
        const err = new Error('Aborted');
        err.code = "ABORTED";
        err.status = this.status;
        err.method = this.method;
        err.url = this.url;
        innerReject(err);
      });
      self.end((err, res) => {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (const key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (const key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (const i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  const isObj = isObject(data);
  let type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (const key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? `${this._data}&${data}`
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  const err = new Error(`${reason + timeout}ms exceeded`);
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":17}],19:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    const ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    const params = utils.params(ct);
    for (const key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    const type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":20}],20:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = str => str.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = str => str.split(/ *; */).reduce((obj, str) => {
  const parts = str.split(/ *= */);
  const key = parts.shift();
  const val = parts.shift();

  if (key && val) obj[key] = val;
  return obj;
}, {});

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {
  const parts = str.split(/ *; */);
  const url = parts[0].slice(1, -1);
  const rel = parts[1].split(/ *= */)[1].slice(1, -1);
  obj[rel] = url;
  return obj;
}, {});

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],21:[function(require,module,exports){
(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = (x[j] + 128) >> 8;
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i, mlen;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  mlen = -1;
  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  mlen = n;
  return mlen;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof require !== 'undefined') {
    // Node.js.
    crypto = require('crypto');
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));

},{"crypto":7}],22:[function(require,module,exports){
(function (Buffer){
const address = require("./encoding/address");
const encoding = require("./encoding/encoding");
const nacl = require("./nacl/naclWrappers");
const utils = require("./utils/utils");

/**
 * Bid enables construction of Algorand Auctions Bids
 * */
class Bid {
    constructor({bidderKey, bidAmount, maxPrice, bidID, auctionKey, auctionID}) {
        this.name = "Bid";
        this.tag = Buffer.from([97, 66]); // "aB"

        bidderKey = address.decode(bidderKey);
        auctionKey = address.decode(auctionKey);

        if (!Number.isSafeInteger(bidAmount) || bidAmount < 0) throw Error("Bid amount must be positive and 2^53-1");
        if (!Number.isSafeInteger(bidID) || bidID < 0) throw Error("BidID must be positive and 2^53-1");
        if (!Number.isSafeInteger(auctionID) || auctionID < 0) throw Error("auctionID must be positive");

        Object.assign(this, {
            bidderKey, auctionKey, bidAmount, maxPrice, bidID, auctionID,
        });
    }

    get_obj_for_encoding() {
        return {
            "bidder": Buffer.from(this.bidderKey.publicKey),
            "cur": this.bidAmount,
            "price": this.maxPrice,
            "id": this.bidID,
            "auc": Buffer.from(this.auctionKey.publicKey),
            "aid": this.auctionID,
        };
    }

    signBid(sk) {
        const encodedMsg = encoding.encode(this.get_obj_for_encoding());
        const toBeSigned = Buffer.from(utils.concatArrays(this.tag, encodedMsg));
        const sig = nacl.sign(toBeSigned, sk);

        // construct signed message
        let sBid = {
            "sig": Buffer.from(sig),
            "bid": this.get_obj_for_encoding(),

        };

        let note = {
            "t": "b",
            "b": sBid
        };
        return new Uint8Array(encoding.encode(note));
    }


}

module.exports = {Bid};
}).call(this,require("buffer").Buffer)

},{"./encoding/address":26,"./encoding/encoding":27,"./nacl/naclWrappers":35,"./utils/utils":37,"buffer":8}],23:[function(require,module,exports){
(function (Buffer){
const client = require('./client');

function Algod(token = '', baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
    // workaround to allow backwards compatibility for multiple headers
    let tokenHeader = token;
    if (typeof (tokenHeader) == 'string') {
        tokenHeader = {"X-Algo-API-Token": tokenHeader};
    }

    // Get client
    let c = new client.HTTPClient(tokenHeader, baseServer, port, headers);

    /**
     * Takes an object and convert its note field to Buffer, if exist.
     * @param o
     * @returns {*}
     */
    function noteb64ToNote(o) {
        if (!(o.noteb64 === undefined || o.noteb64 === null)) {
            o.note = Buffer.from(o.noteb64, "base64")
        }
        return o
    }

    /**
     * status retrieves the StatusResponse from the running node
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.status = async function (headers={}) {
        return await c.get("/v1/status", {}, headers);
    };

    /**
     * healthCheck returns an empty object iff the node is running
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.healthCheck = async function (headers={}) {
        return await c.get("/health", {}, headers);
    };

    /**
     * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.
     * This call blocks
     * @param roundNumber
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.statusAfterBlock = async function (roundNumber, headers={}) {
        if (!Number.isInteger(roundNumber)) throw Error("roundNumber should be an integer");
        return await c.get("/v1/status/wait-for-block-after/" + roundNumber, {}, headers);
    };

    /**
     * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.
     * If maxTxns = 0, fetches as many transactions as possible.
     * @param maxTxns number
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.pendingTransactions = async function (maxTxns, headers={}) {
        if (!Number.isInteger(maxTxns)) throw Error("maxTxns should be an integer");
        let res = await c.get("/v1/transactions/pending", { 'max': maxTxns }, headers);
        if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== undefined) {
            for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {
                res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);
            }
        }
        return res;
    };

    /**
     * versions retrieves the VersionResponse from the running node
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.versions = async function (headers={}) {
        return await c.get("/versions", {}, headers);
    };

    /**
     * LedgerSupply gets the supply details for the specified node's Ledger
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.ledgerSupply = async function (headers={}) {
        return await c.get("/v1/ledger/supply", {}, headers);
    };

    /**
     * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.
     * @param addr string
     * @param first number, optional
     * @param last number, optional
     * @param maxTxns number, optional
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.transactionByAddress = async function (addr, first=null, last=null, maxTxns=null, headers={}) {

        if (( first !== null ) && (!Number.isInteger(first) )){
            throw Error("first round should be an integer")
        }
        if (( last !== null ) && (!Number.isInteger(last) )){
            throw Error("last round should be an integer")
        }
        let res = await c.get("/v1/account/" + addr + "/transactions", { 'firstRound': first, 'lastRound': last, 'max': maxTxns }, headers);
        if (res.statusCode === 200 && res.body.transactions !== undefined) {
            for (let i = 0; i < res.body.transactions.length; i++) {
                res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
            }
        }
        return res;
    };

    /**
     * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range. 
     * The date is a string in the YYYY-MM-DD format.
     * @param addr string
     * @param fromDate string
     * @param toDate string
     * @param maxTxns number, optional
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.transactionByAddressAndDate = async function (addr, fromDate, toDate, maxTxns=null, headers={}) {
        let res = await c.get("/v1/account/" + addr + "/transactions", { 'fromDate': fromDate, 'toDate': toDate, 'max': maxTxns }, headers);
        if (res.statusCode === 200 && res.body.transactions !== undefined) {
            for (let i = 0; i < res.body.transactions.length; i++) {
                res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
            }
        }
        return res;
    };

    /**
     * transactionById returns the a transaction information of a specific txid [txId]
     * Note - This method is allowed only when Indexer is enabled.
     * @param txid
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.transactionById = async function (txid, headers={}) {
        let res = await c.get("/v1/transaction/" + txid, {}, headers);
        if (res.statusCode === 200) {
            res.body = noteb64ToNote(res.body);
        }
        return res;
    };

    /**
     * transactionInformation returns the transaction information of a specific txid and an address
     * @param addr
     * @param txid
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.transactionInformation = async function (addr, txid, headers={}) {
        let res = await c.get("/v1/account/" + addr + "/transaction/" + txid, {}, headers);
        if (res.statusCode === 200) {
            res.body = noteb64ToNote(res.body);
        }
        return res;
    };

    /**
     * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction
     * @param txid
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.pendingTransactionInformation = async function (txid, headers={}) {
        let res = await c.get("/v1/transactions/pending/" + txid, {}, headers);
        if (res.statusCode === 200) {
            res.body = noteb64ToNote(res.body);
        }
        return res;
    };

    /**
     * accountInformation returns the passed account's information
     * @param addr string
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.accountInformation = async function (addr, headers={}) {
        return await c.get("/v1/account/" + addr, {}, headers);
    };

    /**
     * assetInformation returns the information for the asset with the passed creator and index
     * @param index number
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.assetInformation = async function (index, headers={}) {
        return await c.get("/v1/asset/" + index, {}, headers);
    };

    /**
     * suggestedFee gets the recommended transaction fee from the node
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.suggestedFee = async function (headers={}) {
        return await c.get("/v1/transactions/fee", {}, headers);
    };

    /**
     * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network
     * @param txn Uin8Array
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.sendRawTransaction = async function (txn, headers={}) {
        return await c.post("/v1/transactions", Buffer.from(txn), headers);
    };

    /**
     * sendRawTransactions gets a list of encoded SignedTxns and broadcasts it to the network
     * @param txn Array of Uin8Array
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.sendRawTransactions = async function (txns, headers={}) {
        const merged = Array.prototype.concat(...txns.map(arr => Array.from(arr)));
        return await c.post("/v1/transactions", Buffer.from(merged), headers);
    };

    /**
     * getTransactionParams returns to common needed parameters for a new transaction
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.getTransactionParams = async function (headers={}) {
        return await c.get("/v1/transactions/params", {}, headers);
    };

    /**
     * block gets the block info for the given round This call blocks
     * @param roundNumber
     * @param headers, optional
     * @returns {Promise<*>}
     */
    this.block = async function (roundNumber, headers={}) {
        if (!Number.isInteger(roundNumber)) throw Error("roundNumber should be an integer");
        let res = await c.get("/v1/block/" + roundNumber, {}, headers);
        if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {
            for (let i = 0; i < res.body.txns.transactions.length; i++) {
                res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);
            }
        }
        return res;
    };

}


module.exports = { Algod };

}).call(this,require("buffer").Buffer)

},{"./client":24,"buffer":8}],24:[function(require,module,exports){
var request = require("superagent");

/**
 * removeEmpty gets a dictionary and removes empty values
 * @param obj
 * @returns {*}
 */
function removeEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (!obj[key] || obj[key].length === 0) delete obj[key];
        }
    }
    return obj;
}

function HTTPClient(token, baseServer, port, headers={}) {
    // Do not need colon if port is empty
    if (port !== '') {
        baseServer += ":" + port.toString();
    }
    this.address = baseServer;
    this.token = token;
    this.defaultHeaders = headers;

    this.get = async function (path, query, requestHeaders={}) {
        try {
            return await request
                .get(this.address + path)
                .set(this.token)
                .set(this.defaultHeaders)
                .set(requestHeaders)
                .set('Accept', 'application/json')
                .query(removeEmpty(query));
        } catch (e) {
            throw e;
        }
    };

    this.post = async function (path, data, requestHeaders={}) {
        try {
            return await request
                .post(this.address + path)
                .set(this.token)
                .set(this.defaultHeaders)
                .set(requestHeaders)
                .send(data);
        } catch (e) {
            throw e.response;
        }
    };

    this.delete = async function (path, data, requestHeaders={}) {
        try {
            return await request
                .delete(this.address + path)
                .set(this.token)
                .set(this.defaultHeaders)
                .set(requestHeaders)
                .send(data);
        } catch (e) {
            throw e.response;
        }
    };
}

module.exports = { HTTPClient };
},{"superagent":16}],25:[function(require,module,exports){
(function (Buffer){
const client = require('./client');
const txn = require("../transaction");

function Kmd(token, baseServer = "http://127.0.0.1", port = 7833) {
    // Get client
    let c = new client.HTTPClient({'X-KMD-API-Token':token}, baseServer, port);

    /**
     * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
     * @returns {Promise<*>}
     */
    this.versions = async function () {
        return await c.get("/versions");
    };

    /**
     * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
     * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
     * @returns {Promise<*>}
     */
    this.listWallets = async function () {
        return await c.get("/v1/wallets");
    };

    /**
     * createWallet creates a wallet with the specified name, password, driver,
     * and master derivation key. If the master derivation key is blank, one is
     * generated internally to kmd. CreateWallet returns a CreateWalletResponse
     * containing information about the new wallet.
     * @param walletName
     * @param walletPassword
     * @param walletDriverName
     * @param walletMDK
     * @returns {Promise<*>}
     */
    this.createWallet = async function (walletName, walletPassword, walletMDK = "", walletDriverName = "sqlite") {
        let req = {
            "wallet_name": walletName,
            "wallet_driver_name": walletDriverName,
            "wallet_password": walletPassword,
            "master_derivation_key": Buffer.from(walletMDK).toString('base64'),
        };
        return await c.post("/v1/wallet", req);
    };

    /**
     * initWalletHandle accepts a wallet ID and a wallet password, and returns an
     * initWalletHandleResponse containing a wallet handle token. This wallet
     * handle token can be used for subsequent operations on this wallet, like key
     * generation, transaction signing, etc.. WalletHandleTokens expire after a
     * configurable number of seconds, and must be renewed periodically with
     * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
     * you're done interacting with this wallet.
     * @param walletID
     * @param walletPassword
     * @returns {Promise<*>}
     */
    this.initWalletHandle = async function (walletID, walletPassword) {
        let req = {
            "wallet_id": walletID,
            "wallet_password": walletPassword,

        };
        return await c.post("/v1/wallet/init", req);
    };

    /**
     * releaseWalletHandle invalidates the passed wallet handle token, making
     * it unusuable for subsequent wallet operations.
     * @param walletHandle
     * @returns {Promise<*>}
     */
    this.releaseWalletHandle = async function (walletHandle) {
        let req = {
            "wallet_handle_token": walletHandle,
        };
        return await c.post("/v1/wallet/release", req);
    };

    /**
     * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
     * the expiration time to some number of seconds in the future. It returns a
     * RenewWalletHandleResponse containing the walletHandle and the number of
     * seconds until expiration
     * @param walletHandle
     * @returns {Promise<*>}
     */
    this.renewWalletHandle = async function (walletHandle) {
        let req = {
            "wallet_handle_token": walletHandle,
        };
        return await c.post("/v1/wallet/renew", req);
    };

    /**
     * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
     * and renames the underlying wallet.
     * @param walletID
     * @param walletPassword
     * @param newWalletName
     * @returns {Promise<*>}
     */
    this.renameWallet = async function (walletID, walletPassword, newWalletName) {
        let req = {
            "wallet_id": walletID,
            "wallet_password": walletPassword,
            "wallet_name": newWalletName

        };
        return await c.post("/v1/wallet/rename", req);
    };

    /**
     * getWallet accepts a wallet handle and returns high level information about
     * this wallet in a GetWalletResponse.
     * @param walletHandle
     * @returns {Promise<*>}
     */
    this.getWallet = async function (walletHandle) {
        let req = {
            "wallet_handle_token": walletHandle,
        };
        return await c.post("/v1/wallet/info", req);
    };

    /**
     * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
     * returns an ExportMasterDerivationKeyResponse containing the master
     * derivation key. This key can be used as an argument to CreateWallet in
     * order to recover the keys generated by this wallet. The master derivation
     * key can be encoded as a sequence of words using the mnemonic library, and
     * @param walletHandle
     * @param walletPassword
     * @returns {Promise<*>}
     */
    this.exportMasterDerivationKey = async function (walletHandle, walletPassword) {
        let req = {
            "wallet_handle_token": walletHandle,
            "wallet_password": walletPassword,
        };
        let res = await c.post("/v1/master-key/export", req);
        return {"master_derivation_key": Buffer.from(res.body.master_derivation_key, 'base64')};
    };


    /**
     * importKey accepts a wallet handle and an ed25519 private key, and imports
     * the key into the wallet. It returns an ImportKeyResponse containing the
     * address corresponding to this private key.
     * @param walletHandle
     * @param secretKey
     * @returns {Promise<*>}
     */
    this.importKey = async function (walletHandle, secretKey) {
        let req = {
            "wallet_handle_token": walletHandle,
            "private_key": Buffer.from(secretKey).toString('base64'),
        };
        return await c.post("/v1/key/import", req);
    };

    /**
     * exportKey accepts a wallet handle, wallet password, and address, and returns
     * an ExportKeyResponse containing the ed25519 private key corresponding to the
     * address stored in the wallet.
     * @param walletHandle
     * @param walletPassword
     * @param addr
     * @returns {Promise<*>}
     */
    this.exportKey = async function (walletHandle, walletPassword, addr) {
        let req = {
            "wallet_handle_token": walletHandle,
            "address": addr,
            "wallet_password": walletPassword
        };
        return await c.post("/v1/key/export", req);
    };

    /**
     * generateKey accepts a wallet handle, and then generates the next key in the
     * wallet using its internal master derivation key. Two wallets with the same
     * master derivation key will generate the same sequence of keys.
     * @param walletHandle
     * @returns {Promise<*>}
     */
    this.generateKey = async function (walletHandle) {
        let req = {
            "wallet_handle_token": walletHandle,
            "display_mnemonic": false
        };
        return await c.post("/v1/key", req);
    };

    /**
     * deleteKey accepts a wallet handle, wallet password, and address, and deletes
     * the information about this address from the wallet (including address and
     * secret key). If DeleteKey is called on a key generated using GenerateKey,
     * the same key will not be generated again. However, if a wallet is recovered
     * using the master derivation key, a key generated in this way can be
     * recovered.
     * @param walletHandle
     * @param walletPassword
     * @param addr
     * @returns {Promise<*>}
     */
    this.deleteKey = async function (walletHandle, walletPassword, addr) {
        let req = {
            "wallet_handle_token": walletHandle,
            "address": addr,
            "wallet_password": walletPassword
        };
        return await c.delete("/v1/key", req);
    };

    /**
     * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
     * all of the addresses for which this wallet contains secret keys.
     * @param walletHandle
     * @returns {Promise<*>}
     */
    this.listKeys = async function (walletHandle) {
        let req = {
            "wallet_handle_token": walletHandle,
        };
        return await c.post("/v1/key/list", req);
    };

    /**
     * signTransaction accepts a wallet handle, wallet password, and a transaction,
     * and returns and SignTransactionResponse containing an encoded, signed
     * transaction. The transaction is signed using the key corresponding to the
     * Sender field.
     * @param walletHandle
     * @param walletPassword
     * @param transaction
     * @returns {Promise<*>}
     */
    this.signTransaction = async function (walletHandle, walletPassword, transaction) {

        let tx = new txn.Transaction(transaction);

        let req = {
            "wallet_handle_token": walletHandle,
            "wallet_password": walletPassword,
            "transaction": Buffer.from(tx.toByte()).toString('base64')
        };

        return await c.post("/v1/transaction/sign", req);
    };

    /**
     * listMultisig accepts a wallet handle and returns a ListMultisigResponse
     * containing the multisig addresses whose preimages are stored in this wallet.
     * A preimage is the information needed to reconstruct this multisig address,
     * including multisig version information, threshold information, and a list
     * of public keys.
     * @param walletHandle
     * @returns {Promise<*>}
     */
    this.listMultisig = async function (walletHandle) {
        let req = {
            "wallet_handle_token": walletHandle,
        };
        return await c.post("/v1/multisig/list", req);
    };

    /**
     * importMultisig accepts a wallet handle and the information required to
     * generate a multisig address. It derives this address, and stores all of the
     * information within the wallet. It returns a ImportMultisigResponse with the
     * derived address.
     * @param walletHandle
     * @param version
     * @param threshold
     * @param pks
     * @returns {Promise<*>}
     */
    this.importMultisig = async function (walletHandle, version, threshold, pks) {
        let req = {
            "wallet_handle_token": walletHandle,
            "multisig_version": version,
            "threshold": threshold,
            "pks": pks
        };
        return await c.post("/v1/multisig/import", req);
    };

    /**
     * exportMultisig accepts a wallet handle, wallet password, and multisig
     * address, and returns an ExportMultisigResponse containing the stored
     * multisig preimage. The preimage contains all of the information necessary
     * to derive the multisig address, including version, threshold, and a list of
     * public keys.
     * @param walletHandle
     * @param walletPassword
     * @param addr
     * @returns {Promise<*>}
     */
    this.exportMultisig = async function (walletHandle, addr) {
        let req = {
            "wallet_handle_token": walletHandle,
            "address": addr,
        };
        return await c.post("/v1/multisig/export", req);
    };

    /**
     * signMultisigTransaction accepts a wallet handle, wallet password,
     * transaction, public key (*not* an address), and an optional partial
     * MultisigSig. It looks up the secret key corresponding to the public key, and
     * returns a SignMultisigTransactionResponse containing a MultisigSig with a
     * signature by the secret key included.
     * @param walletHandle
     * @param pw
     * @param tx
     * @param pk
     * @param partial
     * @returns {Promise<*>}
     */
    this.signMultisigTransaction = async function (walletHandle, pw, transaction, pk, partial) {
        let tx = new txn.Transaction(transaction);
        let req = {
            "wallet_handle_token": walletHandle,
            "transaction": Buffer.from(tx.toByte()).toString('base64'),
            "public_key": Buffer.from(pk).toString('base64'),
            "partial_multisig": partial,
            "wallet_password": pw
        };
        return await c.post("/v1/multisig/sign", req);
    };

    /**
     * deleteMultisig accepts a wallet handle, wallet password, and multisig
     * address, and deletes the information about this multisig address from the 
     * wallet (including address and secret key).
     * @param walletHandle
     * @param walletPassword
     * @param addr
     * @returns {Promise<*>}
     */
    this.deleteMultisig = async function (walletHandle, walletPassword, addr) {
        let req = {
            "wallet_handle_token": walletHandle,
            "address": addr,
            "wallet_password": walletPassword
        };
        return await c.delete("/v1/multisig", req);
    };
}
module.exports = {Kmd};


module.exports = {Kmd};

}).call(this,require("buffer").Buffer)

},{"../transaction":36,"./client":24,"buffer":8}],26:[function(require,module,exports){
const base32 = require('hi-base32');
const nacl = require('../nacl/naclWrappers');
const utils = require('../utils/utils');

const ALGORAND_ADDRESS_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_ADDRESS_LENGTH = 58;

// Convert "MultisigAddr" UTF-8 to byte array
const MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);

const MALFORMED_ADDRESS_ERROR = new Error("address seems to be malformed");
const INVALID_MSIG_VERSION = new Error("invalid multisig version");
const INVALID_MSIG_THRESHOLD = new Error("bad multisig threshold");
const INVALID_MSIG_PK = new Error("bad multisig public key - wrong length");
const UNEXPECTED_PK_LEN = new Error("nacl public key length is not 32 bytes");

/**
 * isValidAddress takes an Algorand address and checks if valid.
 * @param address Algorand address
 * @returns {boolean}n true if valid, false otherwise
 */
function isValidAddress(address) {
    if (typeof address !== "string") return false;

    if (address.length !== ALGORAND_ADDRESS_LENGTH) return false;

    // Try to decode
    let decoded;
    try {
        decoded = decode(address);
    } catch (e) {
        return false;
    }

    // Compute checksum
    let checksum = nacl.genericHash(decoded.publicKey).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,nacl.HASH_BYTES_LENGTH);

    // Check if the checksum and the address are equal
    return utils.arrayEqual(checksum, decoded.checksum);
}

function decode(address) {
    if (!(typeof address === "string" || address instanceof String)) throw MALFORMED_ADDRESS_ERROR;

    //try to decode
    let decoded = base32.decode.asBytes(address);

    // Sanity check
    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw MALFORMED_ADDRESS_ERROR;

    let pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
    let cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));

    return {"publicKey": pk, "checksum": cs}
}

function encode(address) {
    //compute checksum
    let checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);
    let addr = base32.encode(utils.concatArrays(address, checksum));

    return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='
}

/**
 * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,
 * representing an address that identifies the "exact group, version, and public keys" that are required for signing.
 * Hash("MultisigAddr" || version uint8 || threshold uint8 || PK1 || PK2 || ...)
 * Encoding this output yields a human readable address.
 * @param version multisig version
 * @param threshold multisig threshold
 * @param pks array of typed array public keys
 */
function fromMultisigPreImg({version, threshold, pks}) {
    if (version !== 1 || version > 255 || version < 0) {
        // ^ a tad redundant, but in case in the future version != 1, still check for uint8
        throw INVALID_MSIG_VERSION;
    }
    if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
        throw INVALID_MSIG_THRESHOLD;
    }
    let pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
    if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {
        throw UNEXPECTED_PK_LEN;
    }
    let merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen*pks.length);
    merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
    merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
    merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
    for (var i = 0; i < pks.length; i++) {
        if (pks[i].length !== pkLen) {
            throw INVALID_MSIG_PK;
        }
        merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i*pkLen);
    }
    return nacl.genericHash(merged);
}

/**
 * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.
 * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.
 * @param version multisig version
 * @param threshold multisig threshold
 * @param addrs array of encoded addresses
 */
function fromMultisigPreImgAddrs({version, threshold, addrs}) {
    const pks = addrs.map(addr => {
        return decode(addr).publicKey;
    });
    return encode(fromMultisigPreImg({version, threshold, pks}));
}

module.exports = {isValidAddress, decode, encode, fromMultisigPreImg, fromMultisigPreImgAddrs, MALFORMED_ADDRESS_ERROR,
    INVALID_MSIG_VERSION, INVALID_MSIG_THRESHOLD, INVALID_MSIG_PK, UNEXPECTED_PK_LEN};
},{"../nacl/naclWrappers":35,"../utils/utils":37,"hi-base32":10}],27:[function(require,module,exports){
/**
 * This file is a wrapper of msgpack.js.
 * The wrapper was written in order to ensure correct encoding of Algorand Transaction and other formats.
 * In particular, it matches go-algorand blockchain client, written in go (https://www.github.com/algorand/go-algorand.
 * Algorand's msgpack encoding follows to following rules -
 *  1. Every integer must be encoded to the smallest type possible (0-255->8bit, 256-65535->16bit, etx)
 *  2. All fields names must be sorted
 *  3. All empty and 0 fields should be omitted
 *  4. Every positive number must be encoded as uint
 *  5. Binary blob should be used for binary data and string for strings
 *  */

const msgpack = require("@msgpack/msgpack");

// Errors
const ERROR_CONTAINS_EMPTY = new Error("The object contains empty or 0 values");

/**
 * containsEmpty returns true if any of the object's values are empty, false otherwise.
 * Empty arrays considered empty
 * @param obj
 * @returns {boolean} true if contains empty, false otherwise
 */
function containsEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (!obj[key] || obj[key].length === 0) return true;
        }
    }
    return false;
}

/**
 * encode encodes objects using msgpack
 * @param obj a dictionary to be encoded. Must not contain empty or 0 values.
 * @returns {Uint8Array} msgpack representation of the object
 * @throws ERROR_CONTAINS_EMPTY if the object contains empty or zero values
 */
function encode(obj) {
    // Check for empty values
    if (containsEmpty(obj)) {throw ERROR_CONTAINS_EMPTY;}

    // enable the canonical option
    let options = {sortKeys: true};
    return msgpack.encode(obj, options);
}

function decode(obj) {
    return msgpack.decode(obj);
}

module.exports = {encode, decode, ERROR_CONTAINS_EMPTY};
},{"@msgpack/msgpack":1}],28:[function(require,module,exports){
module.exports={"EvalMaxVersion":1,"LogicSigVersion":1,"Ops":[{"Opcode":0,"Name":"err","Cost":1,"Size":1,"Doc":"Error. Panic immediately. This is primarily a fencepost against accidental zero bytes getting compiled into programs.","Groups":["Flow Control"]},{"Opcode":1,"Name":"sha256","Args":"B","Returns":"B","Cost":7,"Size":1,"Doc":"SHA256 hash of value X, yields [32]byte","Groups":["Arithmetic"]},{"Opcode":2,"Name":"keccak256","Args":"B","Returns":"B","Cost":26,"Size":1,"Doc":"Keccak256 hash of value X, yields [32]byte","Groups":["Arithmetic"]},{"Opcode":3,"Name":"sha512_256","Args":"B","Returns":"B","Cost":9,"Size":1,"Doc":"SHA512_256 hash of value X, yields [32]byte","Groups":["Arithmetic"]},{"Opcode":4,"Name":"ed25519verify","Args":"BBB","Returns":"U","Cost":1900,"Size":1,"Doc":"for (data A, signature B, pubkey C) verify the signature of (\"ProgData\" || program_hash || data) against the pubkey =\u003e {0 or 1}","DocExtra":"The 32 byte public key is the last element on the stack, preceeded by the 64 byte signature at the second-to-last element on the stack, preceeded by the data which was signed at the third-to-last element on the stack.","Groups":["Arithmetic"]},{"Opcode":8,"Name":"+","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A plus B. Panic on overflow.","Groups":["Arithmetic"]},{"Opcode":9,"Name":"-","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A minus B. Panic if B \u003e A.","Groups":["Arithmetic"]},{"Opcode":10,"Name":"/","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A divided by B. Panic if B == 0.","Groups":["Arithmetic"]},{"Opcode":11,"Name":"*","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A times B. Panic on overflow.","DocExtra":"Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `mulw`.","Groups":["Arithmetic"]},{"Opcode":12,"Name":"\u003c","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A less than B =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":13,"Name":"\u003e","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A greater than B =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":14,"Name":"\u003c=","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A less than or equal to B =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":15,"Name":"\u003e=","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A greater than or equal to B =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":16,"Name":"\u0026\u0026","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A is not zero and B is not zero =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":17,"Name":"||","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A is not zero or B is not zero =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":18,"Name":"==","Args":"..","Returns":"U","Cost":1,"Size":1,"Doc":"A is equal to B =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":19,"Name":"!=","Args":"..","Returns":"U","Cost":1,"Size":1,"Doc":"A is not equal to B =\u003e {0 or 1}","Groups":["Arithmetic"]},{"Opcode":20,"Name":"!","Args":"U","Returns":"U","Cost":1,"Size":1,"Doc":"X == 0 yields 1; else 0","Groups":["Arithmetic"]},{"Opcode":21,"Name":"len","Args":"B","Returns":"U","Cost":1,"Size":1,"Doc":"yields length of byte value X","Groups":["Arithmetic"]},{"Opcode":22,"Name":"itob","Args":"U","Returns":"B","Cost":1,"Size":1,"Doc":"converts uint64 X to big endian bytes","Groups":["Arithmetic"]},{"Opcode":23,"Name":"btoi","Args":"B","Returns":"U","Cost":1,"Size":1,"Doc":"converts bytes X as big endian to uint64","DocExtra":"`btoi` panics if the input is longer than 8 bytes","Groups":["Arithmetic"]},{"Opcode":24,"Name":"%","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A modulo B. Panic if B == 0.","Groups":["Arithmetic"]},{"Opcode":25,"Name":"|","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A bitwise-or B","Groups":["Arithmetic"]},{"Opcode":26,"Name":"\u0026","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A bitwise-and B","Groups":["Arithmetic"]},{"Opcode":27,"Name":"^","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A bitwise-xor B","Groups":["Arithmetic"]},{"Opcode":28,"Name":"~","Args":"U","Returns":"U","Cost":1,"Size":1,"Doc":"bitwise invert value X","Groups":["Arithmetic"]},{"Opcode":29,"Name":"mulw","Args":"UU","Returns":"UU","Cost":1,"Size":1,"Doc":"A times B out to 128-bit long result as low (top) and high uint64 values on the stack","Groups":["Arithmetic"]},{"Opcode":32,"Name":"intcblock","Cost":1,"Size":0,"Doc":"load block of uint64 constants","DocExtra":"`intcblock` loads following program bytes into an array of integer constants in the evaluator. These integer constants can be referred to by `intc` and `intc_*` which will push the value onto the stack. Subsequent calls to `intcblock` reset and replace the integer constants available to the script.","ImmediateNote":"{varuint length} [{varuint value}, ...]","Groups":["Loading Values"]},{"Opcode":33,"Name":"intc","Returns":"U","Cost":1,"Size":2,"Doc":"push value from uint64 constants to stack by index into constants","ImmediateNote":"{uint8 int constant index}","Groups":["Loading Values"]},{"Opcode":34,"Name":"intc_0","Returns":"U","Cost":1,"Size":1,"Doc":"push constant 0 from intcblock to stack","Groups":["Loading Values"]},{"Opcode":35,"Name":"intc_1","Returns":"U","Cost":1,"Size":1,"Doc":"push constant 1 from intcblock to stack","Groups":["Loading Values"]},{"Opcode":36,"Name":"intc_2","Returns":"U","Cost":1,"Size":1,"Doc":"push constant 2 from intcblock to stack","Groups":["Loading Values"]},{"Opcode":37,"Name":"intc_3","Returns":"U","Cost":1,"Size":1,"Doc":"push constant 3 from intcblock to stack","Groups":["Loading Values"]},{"Opcode":38,"Name":"bytecblock","Cost":1,"Size":0,"Doc":"load block of byte-array constants","DocExtra":"`bytecblock` loads the following program bytes into an array of byte string constants in the evaluator. These constants can be referred to by `bytec` and `bytec_*` which will push the value onto the stack. Subsequent calls to `bytecblock` reset and replace the bytes constants available to the script.","ImmediateNote":"{varuint length} [({varuint value length} bytes), ...]","Groups":["Loading Values"]},{"Opcode":39,"Name":"bytec","Returns":"B","Cost":1,"Size":2,"Doc":"push bytes constant to stack by index into constants","ImmediateNote":"{uint8 byte constant index}","Groups":["Loading Values"]},{"Opcode":40,"Name":"bytec_0","Returns":"B","Cost":1,"Size":1,"Doc":"push constant 0 from bytecblock to stack","Groups":["Loading Values"]},{"Opcode":41,"Name":"bytec_1","Returns":"B","Cost":1,"Size":1,"Doc":"push constant 1 from bytecblock to stack","Groups":["Loading Values"]},{"Opcode":42,"Name":"bytec_2","Returns":"B","Cost":1,"Size":1,"Doc":"push constant 2 from bytecblock to stack","Groups":["Loading Values"]},{"Opcode":43,"Name":"bytec_3","Returns":"B","Cost":1,"Size":1,"Doc":"push constant 3 from bytecblock to stack","Groups":["Loading Values"]},{"Opcode":44,"Name":"arg","Returns":"B","Cost":1,"Size":2,"Doc":"push Args[N] value to stack by index","ImmediateNote":"{uint8 arg index N}","Groups":["Loading Values"]},{"Opcode":45,"Name":"arg_0","Returns":"B","Cost":1,"Size":1,"Doc":"push Args[0] to stack","Groups":["Loading Values"]},{"Opcode":46,"Name":"arg_1","Returns":"B","Cost":1,"Size":1,"Doc":"push Args[1] to stack","Groups":["Loading Values"]},{"Opcode":47,"Name":"arg_2","Returns":"B","Cost":1,"Size":1,"Doc":"push Args[2] to stack","Groups":["Loading Values"]},{"Opcode":48,"Name":"arg_3","Returns":"B","Cost":1,"Size":1,"Doc":"push Args[3] to stack","Groups":["Loading Values"]},{"Opcode":49,"Name":"txn","Returns":".","Cost":1,"Size":2,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUB","Doc":"push field from current transaction to stack","DocExtra":"FirstValidTime causes the program to fail. The field is reserved for future use.","ImmediateNote":"{uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":50,"Name":"global","Returns":".","Cost":1,"Size":2,"ArgEnum":["MinTxnFee","MinBalance","MaxTxnLife","ZeroAddress","GroupSize"],"ArgEnumTypes":"UUUBU","Doc":"push value from globals to stack","ImmediateNote":"{uint8 global field index}","Groups":["Loading Values"]},{"Opcode":51,"Name":"gtxn","Returns":".","Cost":1,"Size":3,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUB","Doc":"push field to the stack from a transaction in the current transaction group","DocExtra":"for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group, `gtxn i field` is equivalent to `txn field`","ImmediateNote":"{uint8 transaction group index}{uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":52,"Name":"load","Returns":".","Cost":1,"Size":2,"Doc":"copy a value from scratch space to the stack","ImmediateNote":"{uint8 position in scratch space to load from}","Groups":["Loading Values"]},{"Opcode":53,"Name":"store","Args":".","Cost":1,"Size":2,"Doc":"pop a value from the stack and store to scratch space","ImmediateNote":"{uint8 position in scratch space to store to}","Groups":["Loading Values"]},{"Opcode":64,"Name":"bnz","Args":"U","Cost":1,"Size":3,"Doc":"branch if value X is not zero","DocExtra":"The `bnz` instruction opcode 0x40 is followed by two immediate data bytes which are a high byte first and low byte second which together form a 16 bit offset which the instruction may branch to. For a bnz instruction at `pc`, if the last element of the stack is not zero then branch to instruction at `pc + 3 + N`, else proceed to next instruction at `pc + 3`. Branch targets must be well aligned instructions. (e.g. Branching to the second byte of a 2 byte op will be rejected.) Branch offsets are currently limited to forward branches only, 0-0x7fff. A future expansion might make this a signed 16 bit integer allowing for backward branches and looping.","ImmediateNote":"{0..0x7fff forward branch offset, big endian}","Groups":["Flow Control"]},{"Opcode":72,"Name":"pop","Args":".","Cost":1,"Size":1,"Doc":"discard value X from stack","Groups":["Flow Control"]},{"Opcode":73,"Name":"dup","Args":".","Returns":"..","Cost":1,"Size":1,"Doc":"duplicate last value on stack","Groups":["Flow Control"]}]}

},{}],29:[function(require,module,exports){
/**
 Utilities for working with program bytes.
 */

const langspec = require("./langspec.json")

let opcodes;

const maxCost = 20000;
const maxLength = 1000;

/**
 * checkProgram validates program for length and running cost
 * @param {Uint8Array} program Program to check
 * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays
 * @throws {Error}
 * @returns {bool} true if success
 */
function checkProgram(program, args) {
    const intcblockOpcode = 32;
    const bytecblockOpcode = 38;
    if (!program) {
        throw new Error("empty program");
    }

    if (args == undefined) {
        args = []
    }
    if (!Array.isArray(args)) {
        throw new Error("invalid arguments");
    }

    let [version, vlen] = parseUvarint(program);
    if (vlen <= 0) {
        throw new Error("version parsing error");
    }
    if (version > langspec.EvalMaxVersion) {
        throw new Error("unsupported version");
    }

    let cost = 0;
    let length =program.length;
    for (let arg of args) {
        length += arg.length;
    }
    if (length > maxLength) {
        throw new Error("program too long");
    }

    if (!opcodes) {
        opcodes = {}
        for (let op of langspec.Ops) {
            opcodes[op.Opcode] = op;
        }
    }

    let pc = vlen;
    while (pc < program.length) {
        let op = opcodes[program[pc]];
        if (op === undefined) {
            throw new Error("invalid instruction");
        }

        cost += op.Cost;
        let size = op.Size;
        if (size == 0) {
            switch (op.Opcode) {
                case intcblockOpcode: {
                    size = checkIntConstBlock(program, pc);
                    break;
                }
                case bytecblockOpcode: {
                    size = checkByteConstBlock(program, pc);
                    break;
                }
                default: {
                    throw new Error("invalid instruction");
                }
            }
        }
        pc += size;
    }

    if (cost > maxCost) {
        throw new Error("program too costly to run");
    }

    return true;
}

function checkIntConstBlock(program, pc) {
    let size = 1;
    let [numInts, bytesUsed] = parseUvarint(program.slice(pc + size));
    if (bytesUsed <= 0) {
        throw new Error(`could not decode int const block size at pc=${pc + size}`);
    }

    size += bytesUsed;
    for (let i = 0; i < numInts; i++) {
        if (pc + size >= program.length) {
            throw new Error("intcblock ran past end of program");
        }
        [_, bytesUsed] = parseUvarint(program.slice(pc + size));
        if (bytesUsed <= 0) {
            throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);
        }
        size += bytesUsed;
    }
    return size;
}

function checkByteConstBlock(program, pc) {
    let size = 1;
    let [numInts, bytesUsed] = parseUvarint(program.slice(pc + size));
    if (bytesUsed <= 0) {
        throw new Error(`could not decode []byte const block size at pc=${pc + size}`);
    }

    size += bytesUsed;
    for (let i = 0; i < numInts; i++) {
        if (pc + size >= program.length) {
            throw new Error("bytecblock ran past end of program");
        }
        let [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
        if (bytesUsed <= 0) {
            throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);
        }
        size += bytesUsed;
        if (pc + size >= program.length) {
            throw new Error("bytecblock ran past end of program");
        }
        size += itemLen;
    }
    return size;
}

function parseUvarint(array) {
    let x = 0;
    let s = 0;
    for (let i = 0; i < array.length; i++) {
        b = array[i];
        if (b < 0x80) {
            if (i > 9 || i == 9 && b > 1) {
                return [0, -(i + 1)];
            }
            return [x | b << s, i + 1];
        }
        x += (b & 0x7f) << s;
        s += 7;
    }
    return [0, 0];
}

module.exports = {
    checkProgram,
    parseUvarint,
    checkIntConstBlock,
    checkByteConstBlock
};

},{"./langspec.json":28}],30:[function(require,module,exports){
(function (Buffer){
const assert = require('assert');
const nacl = require('./nacl/naclWrappers');
const address = require('./encoding/address');
const encoding = require('./encoding/encoding');
const logic = require('./logic/logic');
const multisig = require('./multisig');
const utils = require('./utils/utils');

/**
 LogicSig implementation
 */

class LogicSig {
    constructor(program, args) {
        this.tag = Buffer.from("Program");

        assert(logic.checkProgram(program, args));

        this.logic = program;
        this.args = args;
        this.sig = undefined;
        this.msig = undefined;
    }

    get_obj_for_encoding() {
        let obj = {
            l: this.logic,
        }
        if (this.args) {
            obj["arg"] = this.args;
        }
        if (this.sig) {
            obj["sig"] = this.sig;
        } else if (this.msig) {
            obj["msig"] = this.msig;
        }
        return obj;
    }

    static from_obj_for_encoding(encoded) {
        let lsig = new LogicSig(encoded.l, encoded.arg);
        lsig.sig = encoded.sig;
        lsig.msig = encoded.msig;
        return lsig;
    }

    /**
     * Performs signature verification
     * @param {Uint8Array} publicKey Verification key (derived from sender address or escrow address)
     * @returns {boolean}
     */
    verify(publicKey) {
        if (this.sig && this.msig) {
            return false;
        }

        try {
            logic.checkProgram(this.logic, this.args);
        } catch (e) {
            return false;
        }

        let toBeSigned = utils.concatArrays(this.tag, this.logic);

        if (!this.sig && !this.msig) {
            let hash = nacl.genericHash(toBeSigned);
            return utils.arrayEqual(hash, publicKey)
        }

        if (this.sig) {
            return nacl.verify(toBeSigned, this.sig, publicKey);
        }

        return multisig.verifyMultisig(toBeSigned, this.msig, publicKey);
    }

    /**
     * Compute hash of the logic sig program (that is the same as escrow account address) as string address
     * @returns {string} String representation of the address
     */
    address() {
        let toBeSigned = utils.concatArrays(this.tag, this.logic);
        let hash = nacl.genericHash(toBeSigned);
        return address.encode(hash);
    }

    /**
     * Creates signature (if no msig provided) or multi signature otherwise
     * @param {Uint8Array} secretKey Secret key to sign with
     * @param {Object} msig Multisig account as {version, threshold, addrs}
     */
    sign(secretKey, msig) {
        if (msig === undefined) {
            this.sig = this.signProgram(secretKey);
        } else {
            let subsigs = msig.addrs.map(addr => {
                return {"pk": address.decode(addr).publicKey};
            });

            this.msig = {
                "v": msig.version,
                "thr": msig.threshold,
                "subsig": subsigs
            };

            let [sig, index] = this.singleSignMultisig(secretKey, this.msig);
            this.msig.subsig[index].s = sig;
        }
    }

    /**
     * Appends a signature to multi signature
     * @param {Uint8Array} secretKey Secret key to sign with
     */
    appendToMultisig(secretKey) {
        if (this.msig === undefined) {
            throw new Error("no multisig present");
        }
        let [sig, index] = this.singleSignMultisig(secretKey, this.msig);
        this.msig.subsig[index].s = sig;
    }

    signProgram(secretKey) {
        let toBeSigned = utils.concatArrays(this.tag, this.logic);
        const sig = nacl.sign(toBeSigned, secretKey);
        return sig;
    }

    singleSignMultisig(secretKey, msig) {
        let index = -1;
        let myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;
        for (let i = 0; i < msig.subsig.length; i++) {
            let pk = msig.subsig[i].pk;
            if (utils.arrayEqual(pk, myPk)) {
                index = i;
                break;
            }
        }
        if (index == -1) {
            throw new Error("invalid secret key");
        }
        let sig = this.signProgram(secretKey);
        return [sig, index];
    }

    toByte() {
        return encoding.encode(this.get_obj_for_encoding());
    }

    static fromByte(encoded) {
        let decoded_obj = encoding.decode(encoded);
        return LogicSig.from_obj_for_encoding(decoded_obj);
    }
}

module.exports = {
    LogicSig
};

}).call(this,require("buffer").Buffer)

},{"./encoding/address":26,"./encoding/encoding":27,"./logic/logic":29,"./multisig":34,"./nacl/naclWrappers":35,"./utils/utils":37,"assert":2,"buffer":8}],31:[function(require,module,exports){
(function (Buffer){
const nacl = require('./nacl/naclWrappers');
const address = require('./encoding/address');
const mnemonic = require('./mnemonic/mnemonic');
const encoding = require('./encoding/encoding');
const txnBuilder = require('./transaction');
const multisig = require('./multisig');
const bidBuilder = require('./bid');
const algod = require('./client/algod');
const kmd = require('./client/kmd');
const utils = require('./utils/utils');
const logicsig = require('./logicsig');

let Algod = algod.Algod;
let Kmd = kmd.Kmd;

const SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // "MX"
const MICROALGOS_TO_ALGOS_RATIO = 1e6;
// Errors
const ERROR_MULTISIG_BAD_SENDER = new Error("The transaction sender address and multisig preimage do not match.");
const ERROR_INVALID_MICROALGOS = new Error("Microalgos should be positive and less than 2^53 - 1.")
/**
 * generateAccount returns a new Algorand address and its corresponding secret key
 * @returns {{sk: Uint8Array, addr: string}}
 */
function generateAccount() {
    let keys = nacl.keyPair();
    let encodedPk = address.encode(keys.publicKey);
    return {addr: encodedPk, sk: keys.secretKey};
}

/**
 * isValidAddress takes an Algorand address and checks if valid.
 * @param addr Algorand address
 * @returns {boolean} true if valid, false otherwise
 */
function isValidAddress(addr) {
    return address.isValidAddress(addr);
}

/**
 * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.
 * @param mn 25 words Algorand mnemonic
 * @returns {{sk: Uint8Array, addr: string}}
 * @throws error if fails to decode the mnemonic
 */
function mnemonicToSecretKey(mn) {
    let seed = mnemonic.seedFromMnemonic(mn);
    let keys = nacl.keyPairFromSeed(seed);
    let encodedPk = address.encode(keys.publicKey);
    return {addr: encodedPk, sk: keys.secretKey};
}

/**
 * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.
 * @param sk Uint8Array
 * @returns string mnemonic
 */
function secretKeyToMnemonic(sk) {
    // get the seed from the sk
    let seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);
    return mnemonic.mnemonicFromSeed(seed);
}

/**
 * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.
 * @param mn 25 words Algorand mnemonic
 * @returns Uint8Array
 * @throws error if fails to decode the mnemonic
 */
function mnemonicToMasterDerivationKey(mn) {
    return mnemonic.seedFromMnemonic(mn);
}

/**
 * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.
 * @param mdk Uint8Array
 * @returns string mnemonic
 */
function masterDerivationKeyToMnemonic(mdk) {
    return mnemonic.mnemonicFromSeed(mdk);
}

/**
 * signTransaction takes an object with either payment or key registration fields and
 * a secret key and returns a signed blob.
 *
 * Payment transaction fields: to, amount, fee, firstRound, lastRound, genesisHash,
 * note(optional), GenesisID(optional), closeRemainderTo(optional)
 *
 * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,
 * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)
 * @param txn object with either payment or key registration fields
 * @param sk Algorand Secret Key
 * @returns object contains the binary signed transaction and its txID
 */
function signTransaction(txn, sk) {
    // Get pk from sk
    let key = nacl.keyPairFromSecretKey(sk);
    txn.from = address.encode(key.publicKey);
    let algoTxn = new txnBuilder.Transaction(txn);

    return {"txID": algoTxn.txID().toString(), "blob": algoTxn.signTxn(sk)};
}

/**
 * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,
 * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.
 * @param bid Algorand Bid
 * @param sk Algorand secret key
 * @returns Uint8Array binary signed bid
 */
function signBid(bid, sk) {
    let signedBid = new bidBuilder.Bid(bid);
    return signedBid.signBid(sk);
}

/**
 * signBytes takes arbitrary bytes and a secret key, prepends the bytes with "MX" for domain separation, signs the bytes
 * with the private key, and returns the signature.
 * @param bytes Uint8array
 * @param sk Algorand secret key
 * @returns binary signature
 */
function signBytes(bytes, sk) {
    let toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));
    let sig = nacl.sign(toBeSigned, sk);
    return sig;
}

/**
 * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public
 * key and the bytes (the bytes should have been signed with "MX" prepended for domain separation).
 * @param bytes Uint8Array
 * @param signature binary signature
 * @param addr string address
 * @returns bool
 */
function verifyBytes(bytes, signature, addr) {
    toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));
    let pk = address.decode(addr).publicKey;
    return nacl.verify(toBeVerified, signature, pk);
}

/**
 * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns
 * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned
 * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendMultisigTransaction.
 * @param txn object with either payment or key registration fields
 * @param version multisig version
 * @param threshold multisig threshold
 * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.
 * @param sk Algorand secret key. The corresponding pk should be in the pre image.
 * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)
 */
function signMultisigTransaction(txn, {version, threshold, addrs}, sk) {
    // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.
    let expectedFromRaw = address.fromMultisigPreImgAddrs({version, threshold, addrs});
    if (txn.hasOwnProperty('from')) {
        if (txn.from !== expectedFromRaw) {
            throw ERROR_MULTISIG_BAD_SENDER;
        }
    } else {
        txn.from = expectedFromRaw;
    }
    let algoTxn = new multisig.MultisigTransaction(txn);
    const pks = addrs.map(addr => {
        return address.decode(addr).publicKey;
    });
    return {
        "txID": algoTxn.txID().toString(),
        "blob": algoTxn.partialSignTxn({version, threshold, pks}, sk),
    };
}

/**
 * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.
 * While we could derive public key preimagery from the partially-signed multisig transaction,
 * we ask the caller to pass it back in, to ensure they know what they are signing.
 * @param multisigTxnBlob an encoded multisig txn. Supports non-payment txn types.
 * @param version multisig version
 * @param threshold multisig threshold
 * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.
 * @param sk Algorand secret key
 * @returns object containing txID, and blob representing encoded multisig txn
 */
function appendSignMultisigTransaction(multisigTxnBlob, {version, threshold, addrs}, sk) {
    const pks = addrs.map(addr => {
        return address.decode(addr).publicKey;
    });
    // obtain underlying txn, sign it, and merge it
    let multisigTxObj = encoding.decode(multisigTxnBlob);
    let msigTxn = multisig.MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
    let partialSignedBlob = msigTxn.partialSignTxn({version, threshold, pks}, sk);
    return {
        "txID": msigTxn.txID().toString(),
        "blob": mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),
    };
}

/**
 * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.
 * @param multisigTxnBlobs a list of blobs representing encoded multisig txns
 * @returns blob representing encoded multisig txn
 */
function mergeMultisigTransactions(multisigTxnBlobs) {
    return multisig.mergeMultisigTransactions(multisigTxnBlobs);
}

/**
 * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
 * @param version mutlisig version
 * @param threshold multisig threshold
 * @param addrs list of Algorand addresses
 */
function multisigAddress({version, threshold, addrs}) {
    return address.fromMultisigPreImgAddrs({version, threshold, addrs});
}

/**
 * encodeObj takes a javascript object and returns its msgpack encoding
 * Note that the encoding sorts the fields alphabetically
 * @param o js obj
 * @returns Uint8Array binary representation
 */
function encodeObj(o) {
    return new Uint8Array(encoding.encode(o));
}

/**
 * decodeObj takes a Uint8Array and returns its javascript obj
 * @param o Uint8Array to decode
 * @returns object
 */
function decodeObj(o) {
    return encoding.decode(o);
}

/**
 * microalgosToAlgos converts microalgos to algos
 * @param microalgos number
 * @returns number
 */
function microalgosToAlgos(microalgos) {
    if (microalgos < 0 || !Number.isSafeInteger(microalgos)){
        throw ERROR_INVALID_MICROALGOS;
    }
    return microalgos/MICROALGOS_TO_ALGOS_RATIO
}

/**
 * algosToMicroalgos converts algos to microalgos
 * @param algos number
 * @returns number
 */
function algosToMicroalgos(algos) {
    let microalgos = algos*MICROALGOS_TO_ALGOS_RATIO;
    return Math.round(microalgos)
}

/**
 * computeGroupID returns group ID for a group of transactions
 * @param txns array of transactions (every element is a dict or Transaction)
 * @return Buffer
 */
function computeGroupID(txns) {
    const hashes = [];
    for (let txn of txns)  {
        let tx = txn;
        if (!(txn instanceof txnBuilder.Transaction)) {
            tx = new txnBuilder.Transaction(txn);
        }
        hashes.push(tx.rawTxID());
    }

    const txgroup = new txnBuilder.TxGroup(hashes);

    const bytes = txgroup.toByte();
    const toBeHashed = Buffer.from(utils.concatArrays(txgroup.tag, bytes));
    const gid = nacl.genericHash(toBeHashed)
    return Buffer.from(gid);
}

/**
 * assignGroupID assigns group id to a given list of unsigned transactions
 * @param txns array of transactions (every element is a dict or Transaction)
 * @param from optional sender address specifying which transaction return
 * @return possible list of matching transactions
 */
function assignGroupID(txns, from = undefined) {
    const gid = computeGroupID(txns);
    let result = [];
    for (tx of txns) {
        if (!from || address.encode(tx.from.publicKey) == from) {
            tx.group = gid;
            result.push(tx);
        }
    }
    return result;
}

/**
 * makeLogicSig creates LogicSig object from program and arguments
 *
 * @param {Uint8Array} program Program to make LogicSig from
 * @param {[Uint8Array]} args Arguments as array of Uint8Array
 * @returns {LogicSig} LogicSig object
 */
function makeLogicSig(program, args) {
    return new logicsig.LogicSig(program, args);
}

/**
 * signLogicSigTransaction takes  a raw transaction and a LogicSig object and returns a logicsig
 * transaction which is a blob representing a transaction and logicsig object.
 * @param {Object} txn transaction object
 * @param {LogicSig} lsig logicsig object
 * @returns {Object} Object containing txID and blob representing signed transaction.
 * @throws error on failure
 */
function signLogicSigTransaction(txn, lsig) {
    if (!lsig.verify(address.decode(txn.from).publicKey)) {
        throw new Error("invalid signature");
    }

    let algoTxn = new txnBuilder.Transaction(txn);

    let lstx = {
        lsig: lsig.get_obj_for_encoding(),
        txn: algoTxn.get_obj_for_encoding()
    };

    return {
        "txID": algoTxn.txID().toString(),
        "blob": encoding.encode(lstx)
    };
}


/**
 * makePaymentTxn takes payment arguments and returns a Transaction object
 * @param from - string representation of Algorand address of sender
 * @param to - string representation of Algorand address of recipient
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param amount - integer amount to send, in microAlgos
 * @param closeRemainderTo - optionally close out remaining account balance to this account, represented as string rep of Algorand address
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @returns {Transaction}
 */
function makePaymentTxn(from, to, fee, amount, closeRemainderTo, firstRound, lastRound, note, genesisHash, genesisID) {
    let o = {
        "from": from,
        "to": to,
        "fee": fee,
        "amount": amount,
        "closeRemainderTo": closeRemainderTo,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "note": note,
        "genesisHash": genesisHash,
        "genesisID": genesisID,
        "type": "pay"
    };
    return new txnBuilder.Transaction(o);
}

/**
 * makeKeyRegistrationTxn takes key registration arguments and returns a Transaction object for
 * that key registration operation
 *
 * @param from - string representation of Algorand address of sender
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @param voteKey - string representation of voting key. for key deregistration, leave undefined
 * @param selectionKey - string representation of selection key. for key deregistration, leave undefined
 * @param voteFirst - first round on which voteKey is valid
 * @param voteLast - last round on which voteKey is valid
 * @param voteKeyDilution - integer
 * @returns {Transaction}
 */
function makeKeyRegistrationTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID,
                                voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution) {
    let o = {
        "from": from,
        "fee": fee,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "note": note,
        "genesisHash": genesisHash,
        "voteKey": voteKey,
        "selectionKey": selectionKey,
        "voteFirst": voteFirst,
        "voteLast": voteLast,
        "voteKeyDilution": voteKeyDilution,
        "genesisID": genesisID,
        "type": "keyreg"
    };
    return new txnBuilder.Transaction(o);
}

/** makeAssetCreateTxn takes asset creation arguments and returns a Transaction object
 * for creating that asset
 *
 * @param from - string representation of Algorand address of sender
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @param total - integer total supply of the asset
 * @param defaultFrozen - boolean whether asset accounts should default to being frozen
 * @param manager - string representation of Algorand address in charge of reserve, freeze, clawback, destruction, etc
 * @param reserve - string representation of Algorand address representing asset reserve
 * @param freeze - string representation of Algorand address with power to freeze/unfreeze asset holdings
 * @param clawback - string representation of Algorand address with power to revoke asset holdings
 * @param unitName - string units name for this asset
 * @param assetName - string name for this asset
 * @param assetURL - string URL relating to this asset
 * @param assetMetadataHash - string representation of some sort of hash commitment with respect to the asset
 * @returns {Transaction}
 */
function makeAssetCreateTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID,
                            total, defaultFrozen, manager, reserve, freeze, clawback,
                            unitName, assetName, assetURL, assetMetadataHash) {
    let o = {
        "from": from,
        "fee": fee,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "note": note,
        "genesisHash": genesisHash,
        "assetTotal": total,
        "assetDefaultFrozen": defaultFrozen,
        "assetUnitName": unitName,
        "assetName": assetName,
        "assetURL": assetURL,
        "assetMetadataHash": assetMetadataHash,
        "assetManager": manager,
        "assetReserve": reserve,
        "assetFreeze": freeze,
        "assetClawback": clawback,
        "genesisID": genesisID,
        "type": "acfg"
    };
    return new txnBuilder.Transaction(o);
}

/** makeAssetConfigTxn can be issued by the asset manager to change the manager, reserve, freeze, or clawback
 * you must respecify existing addresses to keep them the same; leaving a field blank is the same as turning
 * that feature off for this asset
 *
 * @param from - string representation of Algorand address of sender
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @param assetIndex - int asset index uniquely specifying the asset
 * @param manager - string representation of new asset manager Algorand address
 * @param reserve - string representation of new reserve Algorand address
 * @param freeze - string representation of new freeze manager Algorand address
 * @param clawback - string representation of new revocation manager Algorand address
 * @param strictEmptyAddressChecking - boolean - throw an error if any of manager, reserve, freeze, or clawback are undefined. optional, defaults to true.
 * @returns {Transaction}
 */
function makeAssetConfigTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID,
                            assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking=true) {
    if (strictEmptyAddressChecking && ((manager === undefined) || (reserve === undefined) || (freeze === undefined) || (clawback === undefined))) {
        throw Error("strict empty address checking was turned on, but at least one empty address was provided");
    }
    let o = {
        "from": from,
        "fee": fee,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "genesisHash": genesisHash,
        "genesisID": genesisID,
        "assetIndex": assetIndex,
        "assetManager": manager,
        "assetReserve": reserve,
        "assetFreeze": freeze,
        "assetClawback": clawback,
        "type": "acfg",
        "note": note
    };
    return new txnBuilder.Transaction(o);
}

/** makeAssetDestroyTxn will allow the asset's manager to remove this asset from the ledger, so long
 * as all outstanding assets are held by the creator.
 *
 * @param from - string representation of Algorand address of sender
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @param assetIndex - int asset index uniquely specifying the asset
 * @returns {Transaction}
 */
function makeAssetDestroyTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex) {
    let o = {
        "from": from,
        "fee": fee,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "genesisHash": genesisHash,
        "genesisID": genesisID,
        "assetIndex": assetIndex,
        "type": "acfg",
        "note": note
    };
    return new txnBuilder.Transaction(o);
}

/** makeAssetFreezeTxn will allow the asset's freeze manager to freeze or un-freeze an account,
 * blocking or allowing asset transfers to and from the targeted account.
 *
 * @param from - string representation of Algorand address of sender
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @param assetIndex - int asset index uniquely specifying the asset
 * @param freezeTarget - string representation of Algorand address being frozen or unfrozen
 * @param freezeState - true if freezeTarget should be frozen, false if freezeTarget should be allowed to transact
 * @returns {Transaction}
 */
function makeAssetFreezeTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID,
                            assetIndex, freezeTarget, freezeState) {
    let o = {
        "from": from,
        "fee": fee,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "genesisHash": genesisHash,
        "type": "afrz",
        "freezeAccount": freezeTarget,
        "assetIndex": assetIndex,
        "freezeState" : freezeState,
        "note": note
    };
    return new txnBuilder.Transaction(o);
}

/** makeAssetTransferTxn allows for the creation of an asset transfer transaction.
 * Special case: to begin accepting assets, set amount=0 and from=to.
 *
 * @param from - string representation of Algorand address of sender
 * @param to - string representation of Algorand address of asset recipient
 * @param closeRemainderTo - optional - string representation of Algorand address - if provided,
 * send all remaining assets after transfer to the "closeRemainderTo" address and close "from"'s asset holdings
 * @param revocationTarget - optional - string representation of Algorand address - if provided,
 * and if "from" is the asset's revocation manager, then deduct from "revocationTarget" rather than "from"
 * @param fee - integer fee per byte, in microAlgos. for a flat fee, overwrite the fee property on the returned object
 * @param amount - integer amount of assets to send
 * @param firstRound - integer first protocol round on which this txn is valid
 * @param lastRound - integer last protocol round on which this txn is valid
 * @param note - uint8array of arbitrary data for sender to store
 * @param genesisHash - string specifies hash genesis block of network in use
 * @param genesisID - string specifies genesis ID of network in use
 * @param assetIndex - int asset index uniquely specifying the asset
 * @param lease - see makePaymentTxn
 * @returns {Transaction}
 */
function makeAssetTransferTxn(from, to, closeRemainderTo, revocationTarget,
                              fee, amount, firstRound, lastRound, note, genesisHash, genesisID, assetIndex) {
    let o = {
        "type": "axfer",
        "from": from,
        "to": to,
        "amount": amount,
        "fee": fee,
        "firstRound": firstRound,
        "lastRound": lastRound,
        "genesisHash": genesisHash,
        "genesisID": genesisID,
        "assetIndex": assetIndex,
        "note": note,
        "assetRevocationTarget": revocationTarget,
        "closeRemainderTo": closeRemainderTo
    };
    return new txnBuilder.Transaction(o);
}

module.exports = {
    isValidAddress,
    generateAccount,
    secretKeyToMnemonic,
    mnemonicToSecretKey,
    signTransaction,
    signBid,
    signBytes,
    verifyBytes,
    encodeObj,
    decodeObj,
    Algod,
    Kmd,
    mnemonicToMasterDerivationKey,
    masterDerivationKeyToMnemonic,
    appendSignMultisigTransaction,
    mergeMultisigTransactions,
    signMultisigTransaction,
    multisigAddress,
    ERROR_MULTISIG_BAD_SENDER,
    ERROR_INVALID_MICROALGOS,
    microalgosToAlgos,
    algosToMicroalgos,
    computeGroupID,
    assignGroupID,
    makeLogicSig,
    signLogicSigTransaction,
    makePaymentTxn,
    makeKeyRegistrationTxn,
    makeAssetCreateTxn,
    makeAssetConfigTxn,
    makeAssetDestroyTxn,
    makeAssetFreezeTxn,
    makeAssetTransferTxn,
};

}).call(this,require("buffer").Buffer)

},{"./bid":22,"./client/algod":23,"./client/kmd":25,"./encoding/address":26,"./encoding/encoding":27,"./logicsig":30,"./mnemonic/mnemonic":32,"./multisig":34,"./nacl/naclWrappers":35,"./transaction":36,"./utils/utils":37,"buffer":8}],32:[function(require,module,exports){
const english = require("./wordlists/english");
const nacl = require("../nacl/naclWrappers");

const ERROR_FAIL_TO_DECODE_MNEMONIC = Error('failed to decode mnemonic');
const ERROR_NOT_IN_WORDS_LIST = Error('the mnemonic contains a word that is not in the wordlist');

/**
 * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.
 * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.
 * @param seed 32 bytes long seed
 * @returns {string} 25 words mnemonic
 */
function mnemonicFromSeed(seed) {
    // Sanity length check
    if (seed.length !== nacl.SEED_BTYES_LENGTH) {throw new RangeError("Seed length must be " +
        nacl.SEED_BTYES_LENGTH);}

    const uint11Array = toUint11Array(seed);
    const words = applyWords(uint11Array);
    const checksumWord = computeChecksum(seed);

    return words.join(' ') + ' ' + checksumWord;
}

/**
 * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.
 * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one
 * of the passed words is not found in the words list.
 * @param mnemonic 25 words mnemonic
 * @returns {Uint8Array} 32 bytes long seed
 */
function seedFromMnemonic(mnemonic) {
    const words = mnemonic.split(' ');
    const key = words.slice(0, 24);

    //Check that all words are in list
    for (let w of key) {
        if (english.indexOf(w) === -1) throw ERROR_NOT_IN_WORDS_LIST;
    }

    const checksum = words[words.length - 1];
    const uint11Array = key.map(word => english.indexOf(word));

    // Convert the key to uint8Array
    let uint8Array = toUint8Array(uint11Array);

    // We need to chop the last byte -
    // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.
    // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.
    // This left gets padded with another 8 bits to the create the 24th word.
    // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.

    // check that we have 33 bytes long array as expected
    if (uint8Array.length !== 33) throw ERROR_FAIL_TO_DECODE_MNEMONIC;

    // check that the last byte is actually 0x0
    if (uint8Array[uint8Array.length - 1] !== 0x0) throw ERROR_FAIL_TO_DECODE_MNEMONIC;

    // chop it !
    uint8Array = uint8Array.slice(0, uint8Array.length - 1);


    // compute checksum
    const cs = computeChecksum(uint8Array);

    // success!
    if (cs === checksum) return uint8Array;

    throw ERROR_FAIL_TO_DECODE_MNEMONIC;
}

function computeChecksum(seed) {
    const hashBuffer = nacl.genericHash(seed);
    const uint11Hash = toUint11Array(hashBuffer);
    const words = applyWords(uint11Hash);

    return words[0];
}

function applyWords(nums) {
    return nums.map(n => english[n]);
}


// https://stackoverflow.com/a/51452614
function toUint11Array(buffer8) {
    let buffer11 = [];
    let acc = 0;
    let accBits = 0;
    function add(octet) {
        acc = (octet << accBits) | acc;
        accBits += 8;
        if (accBits >=11) {
            buffer11.push( acc & 0x7ff);
            acc >>= 11;
            accBits -= 11;
        }
    }
    function flush() {
        if (accBits) {
            buffer11.push( acc);
        }
    }

    buffer8.forEach( add);
    flush();
    return buffer11;
}

// from Uint11Array
// https://stackoverflow.com/a/51452614
function toUint8Array(buffer11) {
    let buffer8 = [];
    let acc = 0;
    let accBits = 0;
    function add(ui11) {
        acc = (ui11 << accBits) | acc;
        accBits += 11;
        while (accBits >= 8) {
            buffer8.push( acc & 0xff);
            acc >>= 8;
            accBits -= 8;
        }
    }
    function flush() {
        if (accBits) {
            buffer8.push( acc);
        }
    }

    buffer11.forEach( add);
    flush();
    return new Uint8Array(buffer8);
}

module.exports = {mnemonicFromSeed, seedFromMnemonic, ERROR_FAIL_TO_DECODE_MNEMONIC, ERROR_NOT_IN_WORDS_LIST};
},{"../nacl/naclWrappers":35,"./wordlists/english":33}],33:[function(require,module,exports){
const english = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];

module.exports = english;
},{}],34:[function(require,module,exports){
(function (Buffer){
const nacl = require('./nacl/naclWrappers');
const address = require('./encoding/address');
const encoding = require('./encoding/encoding');
const txnBuilder = require('./transaction');
const utils = require('./utils/utils');

/**
 Utilities for manipulating multisig transaction blobs.
 */

const ERROR_MULTISIG_MERGE_LESSTHANTWO = new Error("Not enough multisig transactions to merge. Need at least two");
const ERROR_MULTISIG_MERGE_MISMATCH = new Error("Cannot merge txs. txIDs differ");
const ERROR_MULTISIG_MERGE_WRONG_PREIMAGE = new Error("Cannot merge txs. Multisig preimages differ");
const ERROR_MULTISIG_MERGE_SIG_MISMATCH = new Error("Cannot merge txs. subsigs are mismatched.");
const ERROR_MULTISIG_BAD_FROM_FIELD = new Error("The transaction from field and multisig preimage do not match.");
const ERROR_MULTISIG_KEY_NOT_EXIST = new Error("Key does not exist");

/**
 * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.
 */
class MultisigTransaction extends txnBuilder.Transaction {
    get_obj_for_encoding() {
        if (this.hasOwnProperty("objForEncoding")) {
            // if set, use the value for encoding. This allows us to sign existing non-payment type transactions.
            return this.objForEncoding;
        }
        return super.get_obj_for_encoding();
    }

    static from_obj_for_encoding(txnForEnc) {
        if (txnForEnc.type !== "pay") {
            // we don't support decoding this txn yet - but we can keep signing it since we have the
            // encoded format. We trust that the caller knows what they are trying to sign.
            let txn = Object.create(this.prototype);
            txn.name = "Transaction";
            txn.tag = Buffer.from([84, 88]); // "TX"

            txn.objForEncoding = txnForEnc;
            return txn;
        }
        return super.from_obj_for_encoding(txnForEnc);
    }

    /**
     * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,
     * encoded with msgpack as a typed array.
     * @param version multisig version
     * @param threshold multisig threshold
     * @param pks multisig public key list, order is important.
     * @param sk an Algorand secret key to sign with.
     * @returns an encoded, partially signed multisig transaction.
     */
    partialSignTxn({version, threshold, pks}, sk) {
        // verify one more time that the from field is correct
        if (!this.hasOwnProperty("objForEncoding")) {
            let expectedFromRaw = address.fromMultisigPreImg({version, threshold, pks});
            if (address.encode(this.from.publicKey) !== address.encode(expectedFromRaw)) {
                throw ERROR_MULTISIG_BAD_FROM_FIELD;
            }
        }
        // get signature verifier
        let myPk = nacl.keyPairFromSecretKey(sk).publicKey;
        return createMultisigTransaction(
            this.get_obj_for_encoding(),
            {"rawSig": this.rawSignTxn(sk), myPk},
            {version, threshold, pks},
        );
    }
}

/**
 * createMultisigTransaction creates a multisig transaction blob.
 * @param txnForEncoding the actual transaction to sign.
 * @param rawSig a Buffer raw signature of that transaction
 * @param myPk a public key that corresponds with rawSig
 * @param version multisig version
 * @param threshold mutlisig threshold
 * @param pks ordered list of public keys in this multisig
 * @returns encoded multisig blob
 */
function createMultisigTransaction(txnForEncoding, {rawSig, myPk}, {version, threshold, pks}) {
    let keyExist = false;
    // construct the appendable multisigned transaction format
    let subsigs = pks.map(pk => {
        if (nacl.bytesEqual(pk, myPk)) {
            keyExist = true;
            return {
                "pk": Buffer.from(pk),
                "s" : rawSig,
            };
        }
        return {"pk": Buffer.from(pk)};
    });
    if (keyExist === false) {
        throw ERROR_MULTISIG_KEY_NOT_EXIST;
    }
    let msig = {
        "v": version,
        "thr": threshold,
        "subsig": subsigs,
    };
    let sTxn = {
        "msig": msig,
        "txn": txnForEncoding,
    };
    return new Uint8Array(encoding.encode(sTxn));
}

/**
 * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.
 * @param multisigTxnBlobs a list of blobs representing encoded multisig txns
 * @returns typed array msg-pack encoded multisig txn
 */
function mergeMultisigTransactions(multisigTxnBlobs) {
    if (multisigTxnBlobs.length < 2) {
        throw ERROR_MULTISIG_MERGE_LESSTHANTWO;
    }
    const refSigTx = encoding.decode(multisigTxnBlobs[0]);
    const refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);
    const refTxIDStr = refSigAlgoTx.txID().toString();
    const from = address.encode(refSigTx.txn.snd);

    let newSubsigs = refSigTx.msig.subsig;
    for (let i = 0; i < multisigTxnBlobs.length; i++) {
        let unisig = encoding.decode(multisigTxnBlobs[i]);
        let unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
        if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {
            throw ERROR_MULTISIG_MERGE_MISMATCH;
        }
        // check multisig has same preimage as reference
        if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
            throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;
        }
        let preimg = {
            "version": unisig.msig.v,
            "threshold": unisig.msig.thr,
            "pks": unisig.msig.subsig.map(subsig => {
                return subsig.pk;
            }),
        };
        if (from !== address.encode(address.fromMultisigPreImg(preimg))) {
            throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;
        }
        // now, we can merge
        newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {
            let current = newSubsigs[index];
            if (current.s) {
                if (uniSubsig.s && Buffer.compare(uniSubsig.s, current.s) !== 0) {
                    // mismatch
                    throw ERROR_MULTISIG_MERGE_SIG_MISMATCH;
                }
                return {
                    "pk": current.pk,
                    "s": current.s,
                }
            } else if (uniSubsig.s) {
                return {
                    "pk": current.pk,
                    "s": uniSubsig.s,
                }
            }
            return current;
        });
    }
    let msig = {
        "v": refSigTx.msig.v,
        "thr": refSigTx.msig.thr,
        "subsig": newSubsigs,
    };
    let sTxn = {
        "msig": msig,
        "txn": refSigTx.txn,
    };
    return new Uint8Array(encoding.encode(sTxn));
}

function verifyMultisig(toBeVerified, msig, publicKey) {
    const version = msig.v;
    const threshold = msig.thr;
    const subsigs = msig.subsig;

    let pks = subsigs.map(
        (subsig) => subsig.pk
    );
    if (msig.subsig.length < threshold) {
        return false;
    }

    let pk;
    try {
        pk = address.fromMultisigPreImg({version, threshold, pks});
    } catch (e) {
        return false;
    }

    if (!utils.arrayEqual(pk, publicKey)) {
        return false;
    }

    let counter = 0;
    for (let subsig of subsigs) {
        if (subsig.s !== undefined) {
            counter += 1;
        }
    }
    if (counter < threshold) {
        return false;
    }

    let verifiedCounter = 0;
    for (let subsig of subsigs) {
        if (subsig.s !== undefined) {
            if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {
                verifiedCounter += 1;
            }
        }
    }

    if (verifiedCounter < threshold) {
        return false;
    }

    return true;
}

module.exports = {
    MultisigTransaction,
    mergeMultisigTransactions,
    createMultisigTransaction,
    verifyMultisig,
    ERROR_MULTISIG_MERGE_LESSTHANTWO,
    ERROR_MULTISIG_MERGE_MISMATCH,
    ERROR_MULTISIG_MERGE_WRONG_PREIMAGE,
    ERROR_MULTISIG_MERGE_SIG_MISMATCH,
};

}).call(this,require("buffer").Buffer)

},{"./encoding/address":26,"./encoding/encoding":27,"./nacl/naclWrappers":35,"./transaction":36,"./utils/utils":37,"buffer":8}],35:[function(require,module,exports){
const nacl = require('tweetnacl');
const sha512 = require('js-sha512');

function genericHash(arr) {
    return sha512.sha512_256.array(arr);
}

function randomBytes(length) {
    return nacl.randomBytes(length);
}

function keyPair() {
    let seed = randomBytes(nacl.box.secretKeyLength);
    return keyPairFromSeed(seed);
}

function keyPairFromSeed(seed) {
    return nacl.sign.keyPair.fromSeed(seed);
}

function keyPairFromSecretKey(sk) {
    return nacl.sign.keyPair.fromSecretKey(sk);
}

function sign(msg, secretKey) {
    return nacl.sign.detached(msg, secretKey);
}

function bytesEqual(a, b) {
    return nacl.verify(a, b);
}

function verify(message, signature, verifyKey) {
    return nacl.sign.detached.verify(message, signature, verifyKey);
}

module.exports = {genericHash, randomBytes, keyPair, sign, keyPairFromSeed, keyPairFromSecretKey, bytesEqual, verify};

// constants
module.exports.PUBLIC_KEY_LENGTH = nacl.sign.publicKeyLength;
module.exports.SECRET_KEY_LENGTH = nacl.sign.secretKeyLength;
module.exports.HASH_BYTES_LENGTH = 32;
module.exports.SEED_BTYES_LENGTH = 32;
},{"js-sha512":12,"tweetnacl":21}],36:[function(require,module,exports){
(function (Buffer){
const address = require("./encoding/address");
const encoding = require("./encoding/encoding");
const nacl = require("./nacl/naclWrappers");
const utils = require("./utils/utils");
const base32 = require('hi-base32');

const ALGORAND_TRANSACTION_LENGTH = 52;
const ALGORAND_MIN_TX_FEE = 1000; // version v5
const ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
const ALGORAND_MAX_TX_GROUP_SIZE = 16;

/**
 * Transaction enables construction of Algorand transactions
 * */
class Transaction {
    constructor({from, to, fee, amount, firstRound, lastRound, note, genesisID, genesisHash, lease,
                 closeRemainderTo, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, 
                 assetIndex, assetTotal, assetDefaultFrozen, assetManager, assetReserve,
                 assetFreeze, assetClawback, assetUnitName, assetName, assetURL, assetMetadataHash,
                 freezeAccount, freezeState, assetRevocationTarget, type="pay", flatFee=false}) {
        this.name = "Transaction";
        this.tag = Buffer.from("TX");

        from = address.decode(from);
        if (to !== undefined) to = address.decode(to);
        if (closeRemainderTo !== undefined) closeRemainderTo = address.decode(closeRemainderTo);
        if (assetManager !== undefined) assetManager = address.decode(assetManager);
        if (assetReserve !== undefined) assetReserve = address.decode(assetReserve);
        if (assetFreeze !== undefined) assetFreeze = address.decode(assetFreeze);
        if (assetClawback !== undefined) assetClawback = address.decode(assetClawback);
        if (assetRevocationTarget !== undefined) assetRevocationTarget = address.decode(assetRevocationTarget);
        if (freezeAccount !== undefined) freezeAccount = address.decode(freezeAccount);
        if (genesisHash === undefined) throw Error("genesis hash must be specified and in a base64 string.");

        genesisHash = Buffer.from(genesisHash, 'base64');

        if (amount !== undefined && (!Number.isSafeInteger(amount) || amount < 0)) throw Error("Amount must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(fee) || fee < 0) throw Error("fee must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(firstRound) || firstRound < 0) throw Error("firstRound must be a positive number");
        if (!Number.isSafeInteger(lastRound) || lastRound < 0) throw Error("lastRound must be a positive number");
        if (assetTotal !== undefined && (!Number.isSafeInteger(assetTotal) || assetTotal < 0)) throw Error("Total asset issuance must be a positive number and smaller than 2^53-1");
        if (assetIndex !== undefined && (!Number.isSafeInteger(assetIndex) || assetIndex < 0)) throw Error("Asset index must be a positive number and smaller than 2^53-1");

        if (note !== undefined) {
            if (note.constructor !== Uint8Array) throw Error("note must be a Uint8Array.");
        }
        else {
          note = new Uint8Array(0);
        }
        if (lease !== undefined) {
            if (lease.constructor !== Uint8Array) throw Error("lease must be a Uint8Array.");
            if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH) throw Error("lease must be of length " + ALGORAND_TRANSACTION_LEASE_LENGTH.toString() + ".");
        }
        else {
            lease = new Uint8Array(0);
        }
        if (voteKey !== undefined) {
            voteKey = Buffer.from(voteKey, "base64");
        }
        if (selectionKey !== undefined) {
            selectionKey = Buffer.from(selectionKey, "base64");
        }

        Object.assign(this, {
            from, to, fee, amount, firstRound, lastRound, note, genesisID, genesisHash, lease,
            closeRemainderTo, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution,
            assetIndex, assetTotal, assetDefaultFrozen, assetManager, assetReserve,
            assetFreeze, assetClawback, assetUnitName, assetName, assetURL, assetMetadataHash,
            freezeAccount, freezeState, assetRevocationTarget, type
        });

        // Modify Fee
        if (!flatFee){
            this.fee *= this.estimateSize();
        }
        // If suggested fee too small and will be rejected, set to min tx fee
        if (this.fee < ALGORAND_MIN_TX_FEE) {
            this.fee = ALGORAND_MIN_TX_FEE;
        }

        // say we are aware of groups
        this.group = undefined;
    }

    get_obj_for_encoding() {
        if (this.type == "pay") {
            let txn = {
                "amt": this.amount,
                "fee": this.fee,
                "fv": this.firstRound,
                "lv": this.lastRound,
                "note": Buffer.from(this.note),
                "rcv": Buffer.from(this.to.publicKey),
                "snd": Buffer.from(this.from.publicKey),
                "type": "pay",
                "gen": this.genesisID,
                "gh": this.genesisHash,
                "lx": Buffer.from(this.lease),
                "grp": this.group,
            };

            // parse close address
            if (this.closeRemainderTo !== undefined) txn.close = Buffer.from(this.closeRemainderTo.publicKey);

            // allowed zero values
            if (!txn.note.length) delete txn.note;
            if (!txn.amt) delete txn.amt;
            if (!txn.fee) delete txn.fee;
            if (!txn.gen) delete txn.gen;
            if (txn.grp === undefined) delete txn.grp;
            if (!txn.lx.length) delete txn.lx;

            return txn;
        }
        else if (this.type == "keyreg") {
            let txn = {
                "fee": this.fee,
                "fv": this.firstRound,
                "lv": this.lastRound,
                "note": Buffer.from(this.note),
                "snd": Buffer.from(this.from.publicKey),
                "type": this.type,
                "gen": this.genesisID,
                "gh": this.genesisHash,
                "lx": Buffer.from(this.lease),
                "grp": this.group,
                "votekey": this.voteKey,
                "selkey": this.selectionKey,
                "votefst": this.voteFirst,
                "votelst": this.voteLast,
                "votekd": this.voteKeyDilution
            };
            // allowed zero values
            if (!txn.note.length) delete txn.note;
            if (!txn.lx.length) delete txn.lx;
            if (!txn.fee) delete txn.fee;
            if (!txn.gen) delete txn.gen;

            if (txn.grp === undefined) delete txn.grp;

            return txn;
        }
        else if (this.type == "acfg") {
            // asset creation, or asset reconfigure, or asset destruction
            let txn = {
                "fee": this.fee,
                "fv": this.firstRound,
                "lv": this.lastRound,
                "note": Buffer.from(this.note),
                "snd": Buffer.from(this.from.publicKey),
                "type": this.type,
                "gen": this.genesisID,
                "gh": this.genesisHash,
                "lx": Buffer.from(this.lease),
                "caid": this.assetIndex,
                "apar": {
                    "t": this.assetTotal,
                    "df": this.assetDefaultFrozen,
                }
            };
            if (this.assetManager !== undefined) txn.apar.m = Buffer.from(this.assetManager.publicKey);
            if (this.assetReserve !== undefined) txn.apar.r = Buffer.from(this.assetReserve.publicKey);
            if (this.assetFreeze !== undefined) txn.apar.f = Buffer.from(this.assetFreeze.publicKey);
            if (this.assetClawback !== undefined) txn.apar.c = Buffer.from(this.assetClawback.publicKey);
            if (this.assetName !== undefined) txn.apar.an =this.assetName;
            if (this.assetUnitName !== undefined) txn.apar.un = this.assetUnitName;
            if (this.assetURL !== undefined) txn.apar.au = this.assetURL;
            if (this.assetMetadataHash !== undefined) txn.apar.am = Buffer.from(this.assetMetadataHash);

            // allowed zero values
            if (!txn.note.length) delete txn.note;
            if (!txn.lx.length) delete txn.lx;
            if (!txn.amt) delete txn.amt;
            if (!txn.fee) delete txn.fee;
            if (!txn.gen) delete txn.gen;


            if (!txn.caid) delete txn.caid;
            if ((!txn.apar.t) &&
                (!txn.apar.un) &&
                (!txn.apar.an) &&
                (!txn.apar.df) &&
                (!txn.apar.m) &&
                (!txn.apar.r) &&
                (!txn.apar.f) &&
                (!txn.apar.c) &&
                (!txn.apar.au) &&
                (!txn.apar.am)){
                    delete txn.apar
            }
            else {
                if (!txn.apar.t) delete txn.apar.t;
                if (!txn.apar.un) delete txn.apar.un;
                if (!txn.apar.an) delete txn.apar.an;
                if (!txn.apar.df) delete txn.apar.df;
                if (!txn.apar.m) delete txn.apar.m;
                if (!txn.apar.r) delete txn.apar.r;
                if (!txn.apar.f) delete txn.apar.f;
                if (!txn.apar.c) delete txn.apar.c;
                if (!txn.apar.au) delete txn.apar.au;
                if (!txn.apar.am) delete txn.apar.am;
            }
            if (txn.grp === undefined) delete txn.grp;

            return txn;
        }
        else if (this.type == "axfer") {
            // asset transfer, acceptance, revocation, mint, or burn
            let txn = {
                "aamt": this.amount,
                "fee": this.fee,
                "fv": this.firstRound,
                "lv": this.lastRound,
                "note": Buffer.from(this.note),
                "snd": Buffer.from(this.from.publicKey),
                "arcv": Buffer.from(this.to.publicKey),
                "type": this.type,
                "gen": this.genesisID,
                "gh": this.genesisHash,
                "lx": Buffer.from(this.lease),
                "xaid": this.assetIndex
            };
            if (this.closeRemainderTo !== undefined) txn.aclose = Buffer.from(this.closeRemainderTo.publicKey);
            if (this.assetRevocationTarget !== undefined) txn.asnd = Buffer.from(this.assetRevocationTarget.publicKey);
            // allowed zero values
            if (!txn.note.length) delete txn.note;
            if (!txn.lx.length) delete txn.lx;
            if (!txn.aamt) delete txn.aamt;
            if (!txn.amt) delete txn.amt;
            if (!txn.fee) delete txn.fee;
            if (!txn.gen) delete txn.gen;
            if (txn.grp === undefined) delete txn.grp;
            if (!txn.aclose) delete txn.aclose;
            if (!txn.asnd) delete txn.asnd;
            return txn;
        }
        else if (this.type == "afrz") {
            // asset freeze or unfreeze
            let txn = {
                "fee": this.fee,
                "fv": this.firstRound,
                "lv": this.lastRound,
                "note": Buffer.from(this.note),
                "snd": Buffer.from(this.from.publicKey),
                "type": this.type,
                "gen": this.genesisID,
                "gh": this.genesisHash,
                "lx": Buffer.from(this.lease),
                "faid": this.assetIndex,
                "afrz": this.freezeState
            };
            if (this.freezeAccount !== undefined) txn.fadd = Buffer.from(this.freezeAccount.publicKey);
            // allowed zero values
            if (!txn.note.length) delete txn.note;
            if (!txn.lx.length) delete txn.lx;
            if (!txn.amt) delete txn.amt;
            if (!txn.fee) delete txn.fee;
            if (!txn.gen) delete txn.gen;
            if (!txn.afrz) delete txn.afrz;
            if (txn.grp === undefined) delete txn.grp;

            return txn;
        }
    }

    static from_obj_for_encoding(txnForEnc) {
        let txn = Object.create(this.prototype);
        txn.name = "Transaction";
        txn.tag = Buffer.from("TX");

        txn.genesisID = txnForEnc.gen;
        txn.genesisHash = Buffer.from(txnForEnc.gh);
        txn.type = txnForEnc.type;
        txn.fee = txnForEnc.fee;
        txn.firstRound = txnForEnc.fv;
        txn.lastRound = txnForEnc.lv;
        txn.note = new Uint8Array(txnForEnc.note);
        txn.lease = new Uint8Array(txnForEnc.lx);
        txn.from = address.decode(address.encode(new Uint8Array(txnForEnc.snd)));
        if (txnForEnc.grp !== undefined) txn.group = Buffer.from(txnForEnc.grp);

        if (txnForEnc.type === "pay") {
            txn.amount = txnForEnc.amt;
            txn.to = address.decode(address.encode(new Uint8Array(txnForEnc.rcv)));
            if (txnForEnc.close !== undefined) txn.closeRemainderTo = address.decode(address.encode(txnForEnc.close));
        }
        else if (txnForEnc.type === "keyreg") {
            txn.voteKey = Buffer.from(txnForEnc.votekey);
            txn.selectionKey = Buffer.from(txnForEnc.selkey);
            txn.voteKeyDilution = txnForEnc.votekd;
            txn.voteFirst = txnForEnc.votefst;
            txn.voteLast = txnForEnc.votelst;
        }
        else if (txnForEnc.type === "acfg") {
            // asset creation, or asset reconfigure, or asset destruction
            if (txnForEnc.caid !== undefined){
                txn.assetIndex = txnForEnc.caid;
            }
            if (txnForEnc.apar !== undefined){
                txn.assetTotal = txnForEnc.apar.t;
                txn.assetDefaultFrozen = txnForEnc.apar.df;
                if (txnForEnc.apar.m !== undefined) txn.assetManager = address.decode(address.encode(new Uint8Array(txnForEnc.apar.m)));
                if (txnForEnc.apar.r !== undefined) txn.assetReserve = address.decode(address.encode(new Uint8Array(txnForEnc.apar.r)));
                if (txnForEnc.apar.f !== undefined) txn.assetFreeze = address.decode(address.encode(new Uint8Array(txnForEnc.apar.f)));
                if (txnForEnc.apar.c !== undefined) txn.assetClawback = address.decode(address.encode(new Uint8Array(txnForEnc.apar.c)));
                if (txnForEnc.apar.un !== undefined) txn.assetUnitName = txnForEnc.apar.un;
                if (txnForEnc.apar.an !== undefined) txn.assetName = txnForEnc.apar.an;
                if (txnForEnc.apar.au !== undefined) txn.assetURL = txnForEnc.apar.au;
                if (txnForEnc.apar.am !== undefined) txn.assetMetadataHash = txnForEnc.apar.am;
            }
        }
        else if (txnForEnc.type === "axfer") {
            // asset transfer, acceptance, revocation, mint, or burn
            if (txnForEnc.xaid !== undefined) {
                txn.assetIndex = txnForEnc.xaid;
            }
            if (txnForEnc.aamt !== undefined) txn.amount = txnForEnc.aamt;
            if (txnForEnc.aclose !== undefined) {
                txn.closeRemainderTo = address.decode(address.encode(new Uint8Array(txnForEnc.aclose)));
            }
            if (txnForEnc.asnd !== undefined) {
                txn.assetRevocationTarget = address.decode(address.encode(new Uint8Array(txnForEnc.asnd)));
            }
            txn.to = address.decode(address.encode(new Uint8Array(txnForEnc.arcv)));
        }
        else if (txnForEnc.type === "afrz") {
            if (txnForEnc.afrz !== undefined) {
                txn.freezeState = txnForEnc.afrz;
            }
            if (txnForEnc.faid !== undefined) {
                txn.assetIndex = txnForEnc.faid;
            }
            txn.freezeAccount = address.decode(address.encode(new Uint8Array(txnForEnc.fadd)));
        }
        return txn;
    }

    estimateSize() {
        // Generate random key
        let key = nacl.keyPair();
        return this.signTxn(key.secretKey).length;

    }

    bytesToSign() {
        let encodedMsg = this.toByte();
        return Buffer.from(utils.concatArrays(this.tag, encodedMsg));
    }

    toByte() {
        return encoding.encode(this.get_obj_for_encoding());
    }

    // returns the raw signature
    rawSignTxn(sk) {
        const toBeSigned = this.bytesToSign();
        const sig = nacl.sign(toBeSigned, sk);
        return Buffer.from(sig);
    }

    signTxn(sk) {
        // construct signed message
        let sTxn = {
            "sig": this.rawSignTxn(sk),
            "txn": this.get_obj_for_encoding(),
        };
        return new Uint8Array(encoding.encode(sTxn));
    }

    rawTxID() {
        const en_msg = this.toByte();
        const gh = Buffer.from(utils.concatArrays(this.tag, en_msg));
        return Buffer.from(nacl.genericHash(gh));
    }

    txID() {
        const hash = this.rawTxID();
        return base32.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
    }

    // add a lease to a transaction not yet having
    // supply feePerByte to increment fee accordingly
    addLease(lease, feePerByte=0) {
        if (lease !== undefined) {
            if (lease.constructor !== Uint8Array) throw Error("lease must be a Uint8Array.");
            if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH) throw Error("lease must be of length " + ALGORAND_TRANSACTION_LEASE_LENGTH.toString() + ".");
        }
        else {
            lease = new Uint8Array(0);
        }
        this.lease = lease;
        if (feePerByte !== 0) {
            this.fee += 37 * feePerByte; // 32 bytes + 5 byte label
        }
    }
}

/**
 * Aux class for group id calculation of a group of transactions
 */
class TxGroup {
    constructor(hashes) {
        if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
            let errorMsg = hashes.length.toString() + " transactions grouped together but max group size is " + ALGORAND_MAX_TX_GROUP_SIZE.toString();
            throw Error(errorMsg);
        }

        this.name = "Transaction group";
        this.tag = Buffer.from("TG");

        this.txGroupHashes = hashes;
    }

    get_obj_for_encoding() {
        const txgroup = {
            "txlist": this.txGroupHashes
        };
        return txgroup;
    }

    static from_obj_for_encoding(txgroupForEnc) {
        const txn = Object.create(this.prototype);
        txn.name = "Transaction group";
        txn.tag = Buffer.from("TG");
        txn.txGroupHashes = [];
        for (let hash of txgroupForEnc.txlist) {
            txn.txGroupHashes.push(new Buffer.from(hash));
        }
        return txn;
    }

    toByte() {
        return encoding.encode(this.get_obj_for_encoding());
    }

}

module.exports = {Transaction, TxGroup};

}).call(this,require("buffer").Buffer)

},{"./encoding/address":26,"./encoding/encoding":27,"./nacl/naclWrappers":35,"./utils/utils":37,"buffer":8,"hi-base32":10}],37:[function(require,module,exports){
/**
 * ArrayEqual takes two arrays and return true if equal, false otherwise
 * @return {boolean}
 */
function arrayEqual(a, b) {
    if (a.length !== b.length) {return false;}
    return a.every((val, i) => val === b[i]);
}

/**
 * ConcatArrays takes two array and returns a joint array of both
 * @param a
 * @param b
 * @returns {Uint8Array} [a,b]
 */
function concatArrays(a, b) {
    let c = new Uint8Array(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
}

module.exports = {arrayEqual, concatArrays};
},{}]},{},[31])(31)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9kaXN0LmVzNS9tc2dwYWNrLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGktYmFzZTMyL3NyYy9iYXNlMzIuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1zaGE1MTIvc3JjL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9hZ2VudC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdHdlZXRuYWNsL25hY2wtZmFzdC5qcyIsInNyYy9iaWQuanMiLCJzcmMvY2xpZW50L2FsZ29kLmpzIiwic3JjL2NsaWVudC9jbGllbnQuanMiLCJzcmMvY2xpZW50L2ttZC5qcyIsInNyYy9lbmNvZGluZy9hZGRyZXNzLmpzIiwic3JjL2VuY29kaW5nL2VuY29kaW5nLmpzIiwic3JjL2xvZ2ljL2xhbmdzcGVjLmpzb24iLCJzcmMvbG9naWMvbG9naWMuanMiLCJzcmMvbG9naWNzaWcuanMiLCJzcmMvbWFpbi5qcyIsInNyYy9tbmVtb25pYy9tbmVtb25pYy5qcyIsInNyYy9tbmVtb25pYy93b3JkbGlzdHMvZW5nbGlzaC5qcyIsInNyYy9tdWx0aXNpZy5qcyIsInNyYy9uYWNsL25hY2xXcmFwcGVycy5qcyIsInNyYy90cmFuc2FjdGlvbi5qcyIsInNyYy91dGlscy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Z3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy81QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25nRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLk1lc3NhZ2VQYWNrPXQoKTplLk1lc3NhZ2VQYWNrPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgaT10W25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09ZSxyLmM9dCxyLmQ9ZnVuY3Rpb24oZSx0LG4pe3IubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPXIoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBpIGluIGUpci5kKG4saSxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLGkpKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHIucD1cIlwiLHIoci5zPTApfShbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3Iucih0KTt2YXIgbj1mdW5jdGlvbihlLHQpe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCFyKXJldHVybiBlO3ZhciBuLGksbz1yLmNhbGwoZSkscz1bXTt0cnl7Zm9yKDsodm9pZCAwPT09dHx8dC0tID4wKSYmIShuPW8ubmV4dCgpKS5kb25lOylzLnB1c2gobi52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7biYmIW4uZG9uZSYmKHI9by5yZXR1cm4pJiZyLmNhbGwobyl9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBzfSxpPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWU9ZS5jb25jYXQobihhcmd1bWVudHNbdF0pKTtyZXR1cm4gZX0sbz1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dEVuY29kZXImJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2RlcjtmdW5jdGlvbiBzKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxyPTAsbj0wO248dDspe3ZhciBpPWUuY2hhckNvZGVBdChuKyspO2lmKDAhPSg0Mjk0OTY3MTY4JmkpKWlmKDA9PSg0Mjk0OTY1MjQ4JmkpKXIrPTI7ZWxzZXtpZihpPj01NTI5NiYmaTw9NTYzMTkmJm48dCl7dmFyIG89ZS5jaGFyQ29kZUF0KG4pOzU2MzIwPT0oNjQ1MTImbykmJigrK24saT0oKDEwMjMmaSk8PDEwKSsoMTAyMyZvKSs2NTUzNil9cis9MD09KDQyOTQ5MDE3NjAmaSk/Mzo0fWVsc2UgcisrfXJldHVybiByfXZhciBhPW8/bmV3IFRleHRFbmNvZGVyOnZvaWQgMDt2YXIgaD1hJiZhLmVuY29kZUludG8/ZnVuY3Rpb24oZSx0LHIpe2EuZW5jb2RlSW50byhlLHQuc3ViYXJyYXkocikpfTpmdW5jdGlvbihlLHQscil7dC5zZXQoYS5lbmNvZGUoZSkscil9LHU9NjU1MzY7ZnVuY3Rpb24gYyhlLHQscil7Zm9yKHZhciBuPXQsbz1uK3Iscz1bXSxhPVwiXCI7bjxvOyl7dmFyIGg9ZVtuKytdO2lmKDA9PSgxMjgmaCkpcy5wdXNoKGgpO2Vsc2UgaWYoMTkyPT0oMjI0JmgpKXt2YXIgYz02MyZlW24rK107cy5wdXNoKCgzMSZoKTw8NnxjKX1lbHNlIGlmKDIyND09KDI0MCZoKSl7Yz02MyZlW24rK107dmFyIGY9NjMmZVtuKytdO3MucHVzaCgoMzEmaCk8PDEyfGM8PDZ8Zil9ZWxzZSBpZigyNDA9PSgyNDgmaCkpe3ZhciBsPSg3JmgpPDwxOHwoYz02MyZlW24rK10pPDwxMnwoZj02MyZlW24rK10pPDw2fDYzJmVbbisrXTtsPjY1NTM1JiYobC09NjU1MzYscy5wdXNoKGw+Pj4xMCYxMDIzfDU1Mjk2KSxsPTU2MzIwfDEwMjMmbCkscy5wdXNoKGwpfWVsc2Ugcy5wdXNoKGgpO3MubGVuZ3RoLTQ+PXUmJihhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKHMpKSxzLmxlbmd0aD0wKX1yZXR1cm4gcy5sZW5ndGg+MCYmKGErPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkocykpKSxhfXZhciBmPW8/bmV3IFRleHREZWNvZGVyOm51bGw7dmFyIGw9ZnVuY3Rpb24oZSx0KXt0aGlzLnR5cGU9ZSx0aGlzLmRhdGE9dH07ZnVuY3Rpb24gcChlLHQscil7dmFyIG49TWF0aC5mbG9vcihyLzQyOTQ5NjcyOTYpLGk9cjtlLnNldFVpbnQzMih0LG4pLGUuc2V0VWludDMyKHQrNCxpKX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5nZXRJbnQzMih0KStlLmdldFVpbnQzMih0KzQpfXZhciB5PTQyOTQ5NjcyOTUsdz0xNzE3OTg2OTE4MztmdW5jdGlvbiB2KGUpe3ZhciB0PWUuc2VjLHI9ZS5uc2VjO2lmKHQ+PTAmJnI+PTAmJnQ8PXcpe2lmKDA9PT1yJiZ0PD15KXt2YXIgbj1uZXcgVWludDhBcnJheSg0KTtyZXR1cm4ocz1uZXcgRGF0YVZpZXcobi5idWZmZXIpKS5zZXRVaW50MzIoMCx0KSxufXZhciBpPXQvNDI5NDk2NzI5NixvPTQyOTQ5NjcyOTUmdDtuPW5ldyBVaW50OEFycmF5KDgpO3JldHVybihzPW5ldyBEYXRhVmlldyhuLmJ1ZmZlcikpLnNldFVpbnQzMigwLHI8PDJ8MyZpKSxzLnNldFVpbnQzMig0LG8pLG59dmFyIHM7bj1uZXcgVWludDhBcnJheSgxMik7cmV0dXJuKHM9bmV3IERhdGFWaWV3KG4uYnVmZmVyKSkuc2V0VWludDMyKDAscikscChzLDQsdCksbn1mdW5jdGlvbiBnKGUpe3ZhciB0PWUuZ2V0VGltZSgpLHI9TWF0aC5mbG9vcih0LzFlMyksbj0xZTYqKHQtMWUzKnIpLGk9TWF0aC5mbG9vcihuLzFlOSk7cmV0dXJue3NlYzpyK2ksbnNlYzpuLTFlOSppfX1mdW5jdGlvbiBiKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRGF0ZT92KGcoZSkpOm51bGx9ZnVuY3Rpb24gbShlKXt2YXIgdD1uZXcgRGF0YVZpZXcoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCk7c3dpdGNoKGUuYnl0ZUxlbmd0aCl7Y2FzZSA0OnJldHVybntzZWM6dC5nZXRVaW50MzIoMCksbnNlYzowfTtjYXNlIDg6dmFyIHI9dC5nZXRVaW50MzIoMCk7cmV0dXJue3NlYzo0Mjk0OTY3Mjk2KigzJnIpK3QuZ2V0VWludDMyKDQpLG5zZWM6cj4+PjJ9O2Nhc2UgMTI6cmV0dXJue3NlYzpkKHQsNCksbnNlYzp0LmdldFVpbnQzMigwKX07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSBzaXplIGZvciB0aW1lc3RhbXA6IFwiK2UubGVuZ3RoKX19ZnVuY3Rpb24gVShlKXt2YXIgdD1tKGUpO3JldHVybiBuZXcgRGF0ZSgxZTMqdC5zZWMrdC5uc2VjLzFlNil9dmFyIHg9e3R5cGU6LTEsZW5jb2RlOmIsZGVjb2RlOlV9LFM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy5idWlsdEluRW5jb2RlcnM9W10sdGhpcy5idWlsdEluRGVjb2RlcnM9W10sdGhpcy5lbmNvZGVycz1bXSx0aGlzLmRlY29kZXJzPVtdLHRoaXMucmVnaXN0ZXIoeCl9cmV0dXJuIGUucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUudHlwZSxyPWUuZW5jb2RlLG49ZS5kZWNvZGU7aWYodD49MCl0aGlzLmVuY29kZXJzW3RdPXIsdGhpcy5kZWNvZGVyc1t0XT1uO2Vsc2V7dmFyIGk9MSt0O3RoaXMuYnVpbHRJbkVuY29kZXJzW2ldPXIsdGhpcy5idWlsdEluRGVjb2RlcnNbaV09bn19LGUucHJvdG90eXBlLnRyeVRvRW5jb2RlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8dGhpcy5idWlsdEluRW5jb2RlcnMubGVuZ3RoO3QrKyl7aWYobnVsbCE9KHI9dGhpcy5idWlsdEluRW5jb2RlcnNbdF0pKWlmKG51bGwhPShuPXIoZSkpKXJldHVybiBuZXcgbCgtMS10LG4pfWZvcih0PTA7dDx0aGlzLmVuY29kZXJzLmxlbmd0aDt0Kyspe3ZhciByLG47aWYobnVsbCE9KHI9dGhpcy5lbmNvZGVyc1t0XSkpaWYobnVsbCE9KG49cihlKSkpcmV0dXJuIG5ldyBsKHQsbil9cmV0dXJuIGUgaW5zdGFuY2VvZiBsP2U6bnVsbH0sZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dDwwP3RoaXMuYnVpbHRJbkRlY29kZXJzWy0xLXRdOnRoaXMuZGVjb2RlcnNbdF07cmV0dXJuIHI/cihlLHQpOm5ldyBsKHQsZSl9LGUuZGVmYXVsdENvZGVjPW5ldyBlLGV9KCk7ZnVuY3Rpb24gRShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/ZTpBcnJheUJ1ZmZlci5pc1ZpZXcoZSk/bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCk6ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP25ldyBVaW50OEFycmF5KGUpOlVpbnQ4QXJyYXkuZnJvbShlKX12YXIgQj1udWxsLEE9ISFCO2Z1bmN0aW9uIEwoZSx0LHIpe3ZhciBuPWUubGVuZ3RoLGk9MipuLG89Qi5tYWxsb2MoaSk7IWZ1bmN0aW9uKGUsdCxyLG4pe2Zvcih2YXIgaT1uZXcgRGF0YVZpZXcoQi5tZW1vcnkuYnVmZmVyLGUsdCksbz0wO288bjtvKyspaS5zZXRVaW50MTYoMipvLHIuY2hhckNvZGVBdChvKSl9KG8saSxlLG4pO3ZhciBzPUIubWFsbG9jKDUrNCpuKTt0cnl7dmFyIGE9Qi51dGY4RW5jb2RlVWludDE2QXJyYXkocyxvLG4pO3JldHVybiB0LnNldChuZXcgVWludDhBcnJheShCLm1lbW9yeS5idWZmZXIscyxhKSxyKSxhfWZpbmFsbHl7Qi5mcmVlKG8pLEIuZnJlZShzKX19dmFyIFQ9NjU1MzY7ZnVuY3Rpb24gSShlLHQscil7dmFyIG4saSxvLHM9Qi5tYWxsb2MociksYT1CLm1hbGxvYygyKnIpO3RyeXtuPXMsaT1lLnN1YmFycmF5KHQsdCtyKSxvPXIsbmV3IFVpbnQ4QXJyYXkoQi5tZW1vcnkuYnVmZmVyLG4sbykuc2V0KGkpO3ZhciBoPUIudXRmOERlY29kZVRvVWludDE2QXJyYXkoYSxzLHIpO3JldHVybiBmdW5jdGlvbihlKXtpZihlLmxlbmd0aDw9VClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSk7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbj1lLnN1YmFycmF5KHIqVCwocisxKSpUKTt0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxuKX1yZXR1cm4gdH0obmV3IFVpbnQxNkFycmF5KEIubWVtb3J5LmJ1ZmZlcixhLGgpKX1maW5hbGx5e0IuZnJlZShzKSxCLmZyZWUoYSl9fXZhciBrPWZ1bmN0aW9uKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yLHI9dCYmZVt0XSxuPTA7aWYocilyZXR1cm4gci5jYWxsKGUpO2lmKGUmJlwibnVtYmVyXCI9PXR5cGVvZiBlLmxlbmd0aClyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybiBlJiZuPj1lLmxlbmd0aCYmKGU9dm9pZCAwKSx7dmFsdWU6ZSYmZVtuKytdLGRvbmU6IWV9fX07dGhyb3cgbmV3IFR5cGVFcnJvcih0P1wiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIjpcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIil9LE09MTAwLHo9MjA0OCxDPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQscixuLGkpe3ZvaWQgMD09PWUmJihlPVMuZGVmYXVsdENvZGVjKSx2b2lkIDA9PT10JiYodD1NKSx2b2lkIDA9PT1yJiYocj16KSx2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09aSYmKGk9ITEpLHRoaXMuZXh0ZW5zaW9uQ29kZWM9ZSx0aGlzLm1heERlcHRoPXQsdGhpcy5pbml0aWFsQnVmZmVyU2l6ZT1yLHRoaXMuc29ydEtleXM9bix0aGlzLmZvcmNlRmxvYXQzMj1pLHRoaXMucG9zPTAsdGhpcy52aWV3PW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIodGhpcy5pbml0aWFsQnVmZmVyU2l6ZSkpLHRoaXMuYnl0ZXM9bmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlcil9cmV0dXJuIGUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHQ+dGhpcy5tYXhEZXB0aCl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZGVlcCBvYmplY3RzIGluIGRlcHRoIFwiK3QpO251bGw9PWU/dGhpcy5lbmNvZGVOaWwoKTpcImJvb2xlYW5cIj09dHlwZW9mIGU/dGhpcy5lbmNvZGVCb29sZWFuKGUpOlwibnVtYmVyXCI9PXR5cGVvZiBlP3RoaXMuZW5jb2RlTnVtYmVyKGUpOlwic3RyaW5nXCI9PXR5cGVvZiBlP3RoaXMuZW5jb2RlU3RyaW5nKGUpOnRoaXMuZW5jb2RlT2JqZWN0KGUsdCl9LGUucHJvdG90eXBlLmdldFVpbnQ4QXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheSgwLHRoaXMucG9zKX0sZS5wcm90b3R5cGUuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wb3MrZTt0aGlzLnZpZXcuYnl0ZUxlbmd0aDx0JiZ0aGlzLnJlc2l6ZUJ1ZmZlcigyKnQpfSxlLnByb3RvdHlwZS5yZXNpemVCdWZmZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5QnVmZmVyKGUpLHI9bmV3IFVpbnQ4QXJyYXkodCksbj1uZXcgRGF0YVZpZXcodCk7ci5zZXQodGhpcy5ieXRlcyksdGhpcy52aWV3PW4sdGhpcy5ieXRlcz1yfSxlLnByb3RvdHlwZS5lbmNvZGVOaWw9ZnVuY3Rpb24oKXt0aGlzLndyaXRlVTgoMTkyKX0sZS5wcm90b3R5cGUuZW5jb2RlQm9vbGVhbj1mdW5jdGlvbihlKXshMT09PWU/dGhpcy53cml0ZVU4KDE5NCk6dGhpcy53cml0ZVU4KDE5NSl9LGUucHJvdG90eXBlLmVuY29kZU51bWJlcj1mdW5jdGlvbihlKXtOdW1iZXIuaXNTYWZlSW50ZWdlcihlKT9lPj0wP2U8MTI4P3RoaXMud3JpdGVVOChlKTplPDI1Nj8odGhpcy53cml0ZVU4KDIwNCksdGhpcy53cml0ZVU4KGUpKTplPDY1NTM2Pyh0aGlzLndyaXRlVTgoMjA1KSx0aGlzLndyaXRlVTE2KGUpKTplPDQyOTQ5NjcyOTY/KHRoaXMud3JpdGVVOCgyMDYpLHRoaXMud3JpdGVVMzIoZSkpOih0aGlzLndyaXRlVTgoMjA3KSx0aGlzLndyaXRlVTY0KGUpKTplPj0tMzI/dGhpcy53cml0ZVU4KDIyNHxlKzMyKTplPj0tMTI4Pyh0aGlzLndyaXRlVTgoMjA4KSx0aGlzLndyaXRlSTgoZSkpOmU+PS0zMjc2OD8odGhpcy53cml0ZVU4KDIwOSksdGhpcy53cml0ZUkxNihlKSk6ZT49LTIxNDc0ODM2NDg/KHRoaXMud3JpdGVVOCgyMTApLHRoaXMud3JpdGVJMzIoZSkpOih0aGlzLndyaXRlVTgoMjExKSx0aGlzLndyaXRlSTY0KGUpKTp0aGlzLmZvcmNlRmxvYXQzMj8odGhpcy53cml0ZVU4KDIwMiksdGhpcy53cml0ZUYzMihlKSk6KHRoaXMud3JpdGVVOCgyMDMpLHRoaXMud3JpdGVGNjQoZSkpfSxlLnByb3RvdHlwZS53cml0ZVN0cmluZ0hlYWRlcj1mdW5jdGlvbihlKXtpZihlPDMyKXRoaXMud3JpdGVVOCgxNjArZSk7ZWxzZSBpZihlPDI1Nil0aGlzLndyaXRlVTgoMjE3KSx0aGlzLndyaXRlVTgoZSk7ZWxzZSBpZihlPDY1NTM2KXRoaXMud3JpdGVVOCgyMTgpLHRoaXMud3JpdGVVMTYoZSk7ZWxzZXtpZighKGU8NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxvbmcgc3RyaW5nOiBcIitlK1wiIGJ5dGVzIGluIFVURi04XCIpO3RoaXMud3JpdGVVOCgyMTkpLHRoaXMud3JpdGVVMzIoZSl9fSxlLnByb3RvdHlwZS5lbmNvZGVTdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYobyYmdD4yMDApe3ZhciByPXMoZSk7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg1K3IpLHRoaXMud3JpdGVTdHJpbmdIZWFkZXIociksaChlLHRoaXMuYnl0ZXMsdGhpcy5wb3MpLHRoaXMucG9zKz1yfWVsc2V7aWYoQSYmdD4xMDI0KXt2YXIgbj01KzQqdDt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKG4pO3ZhciBpPUwoZSx0aGlzLmJ5dGVzLHRoaXMucG9zKTtyZXR1cm4gdm9pZCh0aGlzLnBvcys9aSl9cj1zKGUpO3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNStyKSx0aGlzLndyaXRlU3RyaW5nSGVhZGVyKHIpLGZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG49ZS5sZW5ndGgsaT1yLG89MDtvPG47KXt2YXIgcz1lLmNoYXJDb2RlQXQobysrKTtpZigwIT0oNDI5NDk2NzE2OCZzKSl7aWYoMD09KDQyOTQ5NjUyNDgmcykpdFtpKytdPXM+PjYmMzF8MTkyO2Vsc2V7aWYocz49NTUyOTYmJnM8PTU2MzE5JiZvPG4pe3ZhciBhPWUuY2hhckNvZGVBdChvKTs1NjMyMD09KDY0NTEyJmEpJiYoKytvLHM9KCgxMDIzJnMpPDwxMCkrKDEwMjMmYSkrNjU1MzYpfTA9PSg0Mjk0OTAxNzYwJnMpPyh0W2krK109cz4+MTImMTV8MjI0LHRbaSsrXT1zPj42JjYzfDEyOCk6KHRbaSsrXT1zPj4xOCY3fDI0MCx0W2krK109cz4+MTImNjN8MTI4LHRbaSsrXT1zPj42JjYzfDEyOCl9dFtpKytdPTYzJnN8MTI4fWVsc2UgdFtpKytdPXN9fShlLHRoaXMuYnl0ZXMsdGhpcy5wb3MpLHRoaXMucG9zKz1yfX0sZS5wcm90b3R5cGUuZW5jb2RlT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5leHRlbnNpb25Db2RlYy50cnlUb0VuY29kZShlKTtpZihudWxsIT1yKXRoaXMuZW5jb2RlRXh0ZW5zaW9uKHIpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl0aGlzLmVuY29kZUFycmF5KGUsdCk7ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpdGhpcy5lbmNvZGVCaW5hcnkoZSk7ZWxzZXtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb2JqZWN0OiBcIitPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGUpKTt0aGlzLmVuY29kZU1hcChlLHQpfX0sZS5wcm90b3R5cGUuZW5jb2RlQmluYXJ5PWZ1bmN0aW9uKGUpe3ZhciB0PWUuYnl0ZUxlbmd0aDtpZih0PDI1Nil0aGlzLndyaXRlVTgoMTk2KSx0aGlzLndyaXRlVTgodCk7ZWxzZSBpZih0PDY1NTM2KXRoaXMud3JpdGVVOCgxOTcpLHRoaXMud3JpdGVVMTYodCk7ZWxzZXtpZighKHQ8NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGJpbmFyeTogXCIrdCk7dGhpcy53cml0ZVU4KDE5OCksdGhpcy53cml0ZVUzMih0KX12YXIgcj1FKGUpO3RoaXMud3JpdGVVOGEocil9LGUucHJvdG90eXBlLmVuY29kZUFycmF5PWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpPWUubGVuZ3RoO2lmKGk8MTYpdGhpcy53cml0ZVU4KDE0NCtpKTtlbHNlIGlmKGk8NjU1MzYpdGhpcy53cml0ZVU4KDIyMCksdGhpcy53cml0ZVUxNihpKTtlbHNle2lmKCEoaTw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbGFyZ2UgYXJyYXk6IFwiK2kpO3RoaXMud3JpdGVVOCgyMjEpLHRoaXMud3JpdGVVMzIoaSl9dHJ5e2Zvcih2YXIgbz1rKGUpLHM9by5uZXh0KCk7IXMuZG9uZTtzPW8ubmV4dCgpKXt2YXIgYT1zLnZhbHVlO3RoaXMuZW5jb2RlKGEsdCsxKX19Y2F0Y2goZSl7cj17ZXJyb3I6ZX19ZmluYWxseXt0cnl7cyYmIXMuZG9uZSYmKG49by5yZXR1cm4pJiZuLmNhbGwobyl9ZmluYWxseXtpZihyKXRocm93IHIuZXJyb3J9fX0sZS5wcm90b3R5cGUuZW5jb2RlTWFwPWZ1bmN0aW9uKGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7dGhpcy5zb3J0S2V5cyYmci5zb3J0KCk7dmFyIG49ci5sZW5ndGg7aWYobjwxNil0aGlzLndyaXRlVTgoMTI4K24pO2Vsc2UgaWYobjw2NTUzNil0aGlzLndyaXRlVTgoMjIyKSx0aGlzLndyaXRlVTE2KG4pO2Vsc2V7aWYoIShuPDQyOTQ5NjcyOTYpKXRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBtYXAgb2JqZWN0OiBcIituKTt0aGlzLndyaXRlVTgoMjIzKSx0aGlzLndyaXRlVTMyKG4pfWZvcih2YXIgaT0wO2k8bjtpKyspe3ZhciBvPXJbaV07dGhpcy5lbmNvZGVTdHJpbmcobyksdGhpcy5lbmNvZGUoZVtvXSx0KzEpfX0sZS5wcm90b3R5cGUuZW5jb2RlRXh0ZW5zaW9uPWZ1bmN0aW9uKGUpe3ZhciB0PWUuZGF0YS5sZW5ndGg7aWYoMT09PXQpdGhpcy53cml0ZVU4KDIxMik7ZWxzZSBpZigyPT09dCl0aGlzLndyaXRlVTgoMjEzKTtlbHNlIGlmKDQ9PT10KXRoaXMud3JpdGVVOCgyMTQpO2Vsc2UgaWYoOD09PXQpdGhpcy53cml0ZVU4KDIxNSk7ZWxzZSBpZigxNj09PXQpdGhpcy53cml0ZVU4KDIxNik7ZWxzZSBpZih0PDI1Nil0aGlzLndyaXRlVTgoMTk5KSx0aGlzLndyaXRlVTgodCk7ZWxzZSBpZih0PDY1NTM2KXRoaXMud3JpdGVVOCgyMDApLHRoaXMud3JpdGVVMTYodCk7ZWxzZXtpZighKHQ8NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGV4dGVuc2lvbiBvYmplY3Q6IFwiK3QpO3RoaXMud3JpdGVVOCgyMDEpLHRoaXMud3JpdGVVMzIodCl9dGhpcy53cml0ZUk4KGUudHlwZSksdGhpcy53cml0ZVU4YShlLmRhdGEpfSxlLnByb3RvdHlwZS53cml0ZVU4PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSksdGhpcy52aWV3LnNldFVpbnQ4KHRoaXMucG9zLGUpLHRoaXMucG9zKyt9LGUucHJvdG90eXBlLndyaXRlVThhPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUodCksdGhpcy5ieXRlcy5zZXQoZSx0aGlzLnBvcyksdGhpcy5wb3MrPXR9LGUucHJvdG90eXBlLndyaXRlSTg9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgxKSx0aGlzLnZpZXcuc2V0SW50OCh0aGlzLnBvcyxlKSx0aGlzLnBvcysrfSxlLnByb3RvdHlwZS53cml0ZVUxNj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpLHRoaXMudmlldy5zZXRVaW50MTYodGhpcy5wb3MsZSksdGhpcy5wb3MrPTJ9LGUucHJvdG90eXBlLndyaXRlSTE2PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMiksdGhpcy52aWV3LnNldEludDE2KHRoaXMucG9zLGUpLHRoaXMucG9zKz0yfSxlLnByb3RvdHlwZS53cml0ZVUzMj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpLHRoaXMudmlldy5zZXRVaW50MzIodGhpcy5wb3MsZSksdGhpcy5wb3MrPTR9LGUucHJvdG90eXBlLndyaXRlSTMyPWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCksdGhpcy52aWV3LnNldEludDMyKHRoaXMucG9zLGUpLHRoaXMucG9zKz00fSxlLnByb3RvdHlwZS53cml0ZUYzMj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpLHRoaXMudmlldy5zZXRGbG9hdDMyKHRoaXMucG9zLGUpLHRoaXMucG9zKz00fSxlLnByb3RvdHlwZS53cml0ZUY2ND1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpLHRoaXMudmlldy5zZXRGbG9hdDY0KHRoaXMucG9zLGUpLHRoaXMucG9zKz04fSxlLnByb3RvdHlwZS53cml0ZVU2ND1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpLGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yLzQyOTQ5NjcyOTYsaT1yO2Uuc2V0VWludDMyKHQsbiksZS5zZXRVaW50MzIodCs0LGkpfSh0aGlzLnZpZXcsdGhpcy5wb3MsZSksdGhpcy5wb3MrPTh9LGUucHJvdG90eXBlLndyaXRlSTY0PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCkscCh0aGlzLnZpZXcsdGhpcy5wb3MsZSksdGhpcy5wb3MrPTh9LGV9KCksRD17fTtmdW5jdGlvbiBQKGUsdCl7dm9pZCAwPT09dCYmKHQ9RCk7dmFyIHI9bmV3IEModC5leHRlbnNpb25Db2RlYyx0Lm1heERlcHRoLHQuaW5pdGlhbEJ1ZmZlclNpemUsdC5zb3J0S2V5cyx0LmZvcmNlRmxvYXQzMik7cmV0dXJuIHIuZW5jb2RlKGUsMSksci5nZXRVaW50OEFycmF5KCl9ZnVuY3Rpb24gaihlKXtyZXR1cm4oZTwwP1wiLVwiOlwiXCIpK1wiMHhcIitNYXRoLmFicyhlKS50b1N0cmluZygxNikucGFkU3RhcnQoMixcIjBcIil9dmFyIEY9MTYsVz0xNixPPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PWUmJihlPUYpLHZvaWQgMD09PXQmJih0PVcpLHRoaXMubWF4S2V5TGVuZ3RoPWUsdGhpcy5tYXhMZW5ndGhQZXJLZXk9dCx0aGlzLmNhY2hlcz1bXTtmb3IodmFyIHI9MDtyPHRoaXMubWF4S2V5TGVuZ3RoO3IrKyl0aGlzLmNhY2hlcy5wdXNoKFtdKX1yZXR1cm4gZS5wcm90b3R5cGUuY2FuQmVDYWNoZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGU+MCYmZTw9dGhpcy5tYXhLZXlMZW5ndGh9LGUucHJvdG90eXBlLmdldD1mdW5jdGlvbihlLHQscil7dmFyIG49dGhpcy5jYWNoZXNbci0xXSxpPW4ubGVuZ3RoO2U6Zm9yKHZhciBvPTA7bzxpO28rKyl7Zm9yKHZhciBzPW5bb10sYT1zLmJ5dGVzLGg9MDtoPHI7aCsrKWlmKGFbaF0hPT1lW3QraF0pY29udGludWUgZTtyZXR1cm4gcy52YWx1ZX1yZXR1cm4gbnVsbH0sZS5wcm90b3R5cGUuc3RvcmU9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmNhY2hlc1tlLmxlbmd0aC0xXSxuPXtieXRlczplLHZhbHVlOnR9O3IubGVuZ3RoPj10aGlzLm1heExlbmd0aFBlcktleT9yW01hdGgucmFuZG9tKCkqci5sZW5ndGh8MF09bjpyLnB1c2gobil9LGUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQscil7dmFyIG49dGhpcy5nZXQoZSx0LHIpO2lmKG4pcmV0dXJuIG47dmFyIGk9YyhlLHQsciksbz1VaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsdCx0K3IpO3JldHVybiB0aGlzLnN0b3JlKG8saSksaX0sZX0oKSxLPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBuZXcocnx8KHI9UHJvbWlzZSkpKGZ1bmN0aW9uKGksbyl7ZnVuY3Rpb24gcyhlKXt0cnl7aChuLm5leHQoZSkpfWNhdGNoKGUpe28oZSl9fWZ1bmN0aW9uIGEoZSl7dHJ5e2gobi50aHJvdyhlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gaChlKXt2YXIgdDtlLmRvbmU/aShlLnZhbHVlKToodD1lLnZhbHVlLHQgaW5zdGFuY2VvZiByP3Q6bmV3IHIoZnVuY3Rpb24oZSl7ZSh0KX0pKS50aGVuKHMsYSl9aCgobj1uLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9LF89ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPXMudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX0sVj1mdW5jdGlvbihlKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgdCxyPWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO3JldHVybiByP3IuY2FsbChlKTooZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBfX3ZhbHVlcz9fX3ZhbHVlcyhlKTplW1N5bWJvbC5pdGVyYXRvcl0oKSx0PXt9LG4oXCJuZXh0XCIpLG4oXCJ0aHJvd1wiKSxuKFwicmV0dXJuXCIpLHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHQpO2Z1bmN0aW9uIG4ocil7dFtyXT1lW3JdJiZmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixpKXsoZnVuY3Rpb24oZSx0LHIsbil7UHJvbWlzZS5yZXNvbHZlKG4pLnRoZW4oZnVuY3Rpb24odCl7ZSh7dmFsdWU6dCxkb25lOnJ9KX0sdCl9KShuLGksKHQ9ZVtyXSh0KSkuZG9uZSx0LnZhbHVlKX0pfX19LE49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBOPyh0aGlzLnY9ZSx0aGlzKTpuZXcgTihlKX0sUj1mdW5jdGlvbihlLHQscil7aWYoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7dmFyIG4saT1yLmFwcGx5KGUsdHx8W10pLG89W107cmV0dXJuIG49e30scyhcIm5leHRcIikscyhcInRocm93XCIpLHMoXCJyZXR1cm5cIiksbltTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbjtmdW5jdGlvbiBzKGUpe2lbZV0mJihuW2VdPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLG4pe28ucHVzaChbZSx0LHIsbl0pPjF8fGEoZSx0KX0pfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIE4/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihoLHUpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gaChlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIHUoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fSxIPS0xLEc9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksWD1uZXcgVWludDhBcnJheShHLmJ1ZmZlcikscT1mdW5jdGlvbigpe3RyeXtHLmdldEludDgoMCl9Y2F0Y2goZSl7cmV0dXJuIGUuY29uc3RydWN0b3J9dGhyb3cgbmV3IEVycm9yKFwibmV2ZXIgcmVhY2hlZFwiKX0oKSxKPW5ldyBxKFwiSW5zdWZmaWNpZW50IGRhdGFcIiksUT00Mjk0OTY3Mjk1LFk9bmV3IE8sWj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIsbixpLG8scyl7dm9pZCAwPT09ZSYmKGU9Uy5kZWZhdWx0Q29kZWMpLHZvaWQgMD09PXQmJih0PVEpLHZvaWQgMD09PXImJihyPVEpLHZvaWQgMD09PW4mJihuPVEpLHZvaWQgMD09PWkmJihpPVEpLHZvaWQgMD09PW8mJihvPVEpLHZvaWQgMD09PXMmJihzPVkpLHRoaXMuZXh0ZW5zaW9uQ29kZWM9ZSx0aGlzLm1heFN0ckxlbmd0aD10LHRoaXMubWF4QmluTGVuZ3RoPXIsdGhpcy5tYXhBcnJheUxlbmd0aD1uLHRoaXMubWF4TWFwTGVuZ3RoPWksdGhpcy5tYXhFeHRMZW5ndGg9byx0aGlzLmNhY2hlZEtleURlY29kZXI9cyx0aGlzLnRvdGFsUG9zPTAsdGhpcy5wb3M9MCx0aGlzLnZpZXc9Ryx0aGlzLmJ5dGVzPVgsdGhpcy5oZWFkQnl0ZT1ILHRoaXMuc3RhY2s9W119cmV0dXJuIGUucHJvdG90eXBlLnNldEJ1ZmZlcj1mdW5jdGlvbihlKXt0aGlzLmJ5dGVzPUUoZSksdGhpcy52aWV3PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilyZXR1cm4gbmV3IERhdGFWaWV3KGUpO3ZhciB0PUUoZSk7cmV0dXJuIG5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX0odGhpcy5ieXRlcyksdGhpcy5wb3M9MH0sZS5wcm90b3R5cGUuYXBwZW5kQnVmZmVyPWZ1bmN0aW9uKGUpe2lmKHRoaXMuaGVhZEJ5dGUhPT1IfHx0aGlzLmhhc1JlbWFpbmluZygpKXt2YXIgdD10aGlzLmJ5dGVzLnN1YmFycmF5KHRoaXMucG9zKSxyPUUoZSksbj1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCtyLmxlbmd0aCk7bi5zZXQodCksbi5zZXQocix0Lmxlbmd0aCksdGhpcy5zZXRCdWZmZXIobil9ZWxzZSB0aGlzLnNldEJ1ZmZlcihlKX0sZS5wcm90b3R5cGUuaGFzUmVtYWluaW5nPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0xKSx0aGlzLnZpZXcuYnl0ZUxlbmd0aC10aGlzLnBvcz49ZX0sZS5wcm90b3R5cGUuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3I9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy52aWV3LHI9dGhpcy5wb3M7cmV0dXJuIG5ldyBSYW5nZUVycm9yKFwiRXh0cmEgXCIrKHQuYnl0ZUxlbmd0aC1yKStcIiBieXRlKHMpIGZvdW5kIGF0IGJ1ZmZlcltcIitlK1wiXVwiKX0sZS5wcm90b3R5cGUuZGVjb2RlU2luZ2xlU3luYz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZGVjb2RlU3luYygpO2lmKHRoaXMuaGFzUmVtYWluaW5nKCkpdGhyb3cgdGhpcy5jcmVhdGVOb0V4dHJhQnl0ZXNFcnJvcih0aGlzLnBvcyk7cmV0dXJuIGV9LGUucHJvdG90eXBlLmRlY29kZVNpbmdsZUFzeW5jPWZ1bmN0aW9uKGUpe3ZhciB0LHIsbixpO3JldHVybiBLKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBvLHMsYSxoLHUsYyxmLGw7cmV0dXJuIF8odGhpcyxmdW5jdGlvbihwKXtzd2l0Y2gocC5sYWJlbCl7Y2FzZSAwOm89ITEscC5sYWJlbD0xO2Nhc2UgMTpwLnRyeXMucHVzaChbMSw2LDcsMTJdKSx0PVYoZSkscC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bNCx0Lm5leHQoKV07Y2FzZSAzOmlmKChyPXAuc2VudCgpKS5kb25lKXJldHVyblszLDVdO2lmKGE9ci52YWx1ZSxvKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy50b3RhbFBvcyk7dGhpcy5hcHBlbmRCdWZmZXIoYSk7dHJ5e3M9dGhpcy5kZWNvZGVTeW5jKCksbz0hMH1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBxKSl0aHJvdyBlfXRoaXMudG90YWxQb3MrPXRoaXMucG9zLHAubGFiZWw9NDtjYXNlIDQ6cmV0dXJuWzMsMl07Y2FzZSA1OnJldHVyblszLDEyXTtjYXNlIDY6cmV0dXJuIGg9cC5zZW50KCksbj17ZXJyb3I6aH0sWzMsMTJdO2Nhc2UgNzpyZXR1cm4gcC50cnlzLnB1c2goWzcsLDEwLDExXSksciYmIXIuZG9uZSYmKGk9dC5yZXR1cm4pP1s0LGkuY2FsbCh0KV06WzMsOV07Y2FzZSA4OnAuc2VudCgpLHAubGFiZWw9OTtjYXNlIDk6cmV0dXJuWzMsMTFdO2Nhc2UgMTA6aWYobil0aHJvdyBuLmVycm9yO3JldHVybls3XTtjYXNlIDExOnJldHVybls3XTtjYXNlIDEyOmlmKG8pe2lmKHRoaXMuaGFzUmVtYWluaW5nKCkpdGhyb3cgdGhpcy5jcmVhdGVOb0V4dHJhQnl0ZXNFcnJvcih0aGlzLnRvdGFsUG9zKTtyZXR1cm5bMixzXX10aHJvdyBjPSh1PXRoaXMpLmhlYWRCeXRlLGY9dS5wb3MsbD11LnRvdGFsUG9zLG5ldyBSYW5nZUVycm9yKFwiSW5zdWZmaWNpZW50IGRhdGEgaW4gcGFyY2luZyBcIitqKGMpK1wiIGF0IFwiK2wrXCIgKFwiK2YrXCIgaW4gdGhlIGN1cnJlbnQgYnVmZmVyKVwiKX19KX0pfSxlLnByb3RvdHlwZS5kZWNvZGVBcnJheVN0cmVhbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kZWNvZGVNdWx0aUFzeW5jKGUsITApfSxlLnByb3RvdHlwZS5kZWNvZGVTdHJlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGVjb2RlTXVsdGlBc3luYyhlLCExKX0sZS5wcm90b3R5cGUuZGVjb2RlTXVsdGlBc3luYz1mdW5jdGlvbihlLHQpe3JldHVybiBSKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKCl7dmFyIHIsbixpLG8scyxhLGgsdSxjO3JldHVybiBfKHRoaXMsZnVuY3Rpb24oZil7c3dpdGNoKGYubGFiZWwpe2Nhc2UgMDpyPXQsbj0tMSxmLmxhYmVsPTE7Y2FzZSAxOmYudHJ5cy5wdXNoKFsxLDEzLDE0LDE5XSksaT1WKGUpLGYubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQsTihpLm5leHQoKSldO2Nhc2UgMzppZigobz1mLnNlbnQoKSkuZG9uZSlyZXR1cm5bMywxMl07aWYocz1vLnZhbHVlLHQmJjA9PT1uKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy50b3RhbFBvcyk7dGhpcy5hcHBlbmRCdWZmZXIocyksciYmKG49dGhpcy5yZWFkQXJyYXlTaXplKCkscj0hMSx0aGlzLmNvbXBsZXRlKCkpLGYubGFiZWw9NDtjYXNlIDQ6Zi50cnlzLnB1c2goWzQsOSwsMTBdKSxmLmxhYmVsPTU7Y2FzZSA1OnJldHVybls0LE4odGhpcy5kZWNvZGVTeW5jKCkpXTtjYXNlIDY6cmV0dXJuWzQsZi5zZW50KCldO2Nhc2UgNzpyZXR1cm4gZi5zZW50KCksMD09LS1uP1szLDhdOlszLDVdO2Nhc2UgODpyZXR1cm5bMywxMF07Y2FzZSA5OmlmKCEoKGE9Zi5zZW50KCkpaW5zdGFuY2VvZiBxKSl0aHJvdyBhO3JldHVyblszLDEwXTtjYXNlIDEwOnRoaXMudG90YWxQb3MrPXRoaXMucG9zLGYubGFiZWw9MTE7Y2FzZSAxMTpyZXR1cm5bMywyXTtjYXNlIDEyOnJldHVyblszLDE5XTtjYXNlIDEzOnJldHVybiBoPWYuc2VudCgpLHU9e2Vycm9yOmh9LFszLDE5XTtjYXNlIDE0OnJldHVybiBmLnRyeXMucHVzaChbMTQsLDE3LDE4XSksbyYmIW8uZG9uZSYmKGM9aS5yZXR1cm4pP1s0LE4oYy5jYWxsKGkpKV06WzMsMTZdO2Nhc2UgMTU6Zi5zZW50KCksZi5sYWJlbD0xNjtjYXNlIDE2OnJldHVyblszLDE4XTtjYXNlIDE3OmlmKHUpdGhyb3cgdS5lcnJvcjtyZXR1cm5bN107Y2FzZSAxODpyZXR1cm5bN107Y2FzZSAxOTpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUuZGVjb2RlU3luYz1mdW5jdGlvbigpe2U6Zm9yKDs7KXt2YXIgZT10aGlzLnJlYWRIZWFkQnl0ZSgpLHQ9dm9pZCAwO2lmKGU+PTIyNCl0PWUtMjU2O2Vsc2UgaWYoZTwxOTIpaWYoZTwxMjgpdD1lO2Vsc2UgaWYoZTwxNDQpe2lmKDAhPT0obj1lLTEyOCkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZihlPDE2MCl7aWYoMCE9PShuPWUtMTQ0KSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2V7dmFyIHI9ZS0xNjA7dD10aGlzLmRlY29kZVV0ZjhTdHJpbmcociwwKX1lbHNlIGlmKDE5Mj09PWUpdD1udWxsO2Vsc2UgaWYoMTk0PT09ZSl0PSExO2Vsc2UgaWYoMTk1PT09ZSl0PSEwO2Vsc2UgaWYoMjAyPT09ZSl0PXRoaXMucmVhZEYzMigpO2Vsc2UgaWYoMjAzPT09ZSl0PXRoaXMucmVhZEY2NCgpO2Vsc2UgaWYoMjA0PT09ZSl0PXRoaXMucmVhZFU4KCk7ZWxzZSBpZigyMDU9PT1lKXQ9dGhpcy5yZWFkVTE2KCk7ZWxzZSBpZigyMDY9PT1lKXQ9dGhpcy5yZWFkVTMyKCk7ZWxzZSBpZigyMDc9PT1lKXQ9dGhpcy5yZWFkVTY0KCk7ZWxzZSBpZigyMDg9PT1lKXQ9dGhpcy5yZWFkSTgoKTtlbHNlIGlmKDIwOT09PWUpdD10aGlzLnJlYWRJMTYoKTtlbHNlIGlmKDIxMD09PWUpdD10aGlzLnJlYWRJMzIoKTtlbHNlIGlmKDIxMT09PWUpdD10aGlzLnJlYWRJNjQoKTtlbHNlIGlmKDIxNz09PWUpe3I9dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDEpfWVsc2UgaWYoMjE4PT09ZSl7cj10aGlzLmxvb2tVMTYoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDIpfWVsc2UgaWYoMjE5PT09ZSl7cj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDQpfWVsc2UgaWYoMjIwPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUxNigpKSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2UgaWYoMjIxPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUzMigpKSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2UgaWYoMjIyPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUxNigpKSl7dGhpcy5wdXNoTWFwU3RhdGUobiksdGhpcy5jb21wbGV0ZSgpO2NvbnRpbnVlIGV9dD17fX1lbHNlIGlmKDIyMz09PWUpe2lmKDAhPT0obj10aGlzLnJlYWRVMzIoKSkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZigxOTY9PT1lKXt2YXIgbj10aGlzLmxvb2tVOCgpO3Q9dGhpcy5kZWNvZGVCaW5hcnkobiwxKX1lbHNlIGlmKDE5Nz09PWUpe249dGhpcy5sb29rVTE2KCk7dD10aGlzLmRlY29kZUJpbmFyeShuLDIpfWVsc2UgaWYoMTk4PT09ZSl7bj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlQmluYXJ5KG4sNCl9ZWxzZSBpZigyMTI9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oMSwwKTtlbHNlIGlmKDIxMz09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbigyLDApO2Vsc2UgaWYoMjE0PT09ZSl0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKDQsMCk7ZWxzZSBpZigyMTU9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oOCwwKTtlbHNlIGlmKDIxNj09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbigxNiwwKTtlbHNlIGlmKDE5OT09PWUpe249dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sMSl9ZWxzZSBpZigyMDA9PT1lKXtuPXRoaXMubG9va1UxNigpO3Q9dGhpcy5kZWNvZGVFeHRlbnNpb24obiwyKX1lbHNle2lmKDIwMSE9PWUpdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHR5cGUgYnl0ZTogXCIraihlKSk7bj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sNCl9dGhpcy5jb21wbGV0ZSgpO2Zvcih2YXIgaT10aGlzLnN0YWNrO2kubGVuZ3RoPjA7KXt2YXIgbz1pW2kubGVuZ3RoLTFdO2lmKDA9PT1vLnR5cGUpe2lmKG8uYXJyYXlbby5wb3NpdGlvbl09dCxvLnBvc2l0aW9uKyssby5wb3NpdGlvbiE9PW8uc2l6ZSljb250aW51ZSBlO2kucG9wKCksdD1vLmFycmF5fWVsc2V7aWYoMT09PW8udHlwZSl7aWYocz12b2lkIDAsXCJzdHJpbmdcIiE9PShzPXR5cGVvZiB0KSYmXCJudW1iZXJcIiE9PXMpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgb2Yga2V5IG11c3QgYmUgc3RyaW5nIG9yIG51bWJlciBidXQgXCIrdHlwZW9mIHQpO28ua2V5PXQsby50eXBlPTI7Y29udGludWUgZX1pZigyPT09by50eXBlKXtpZihvLm1hcFtvLmtleV09dCxvLnJlYWRDb3VudCsrLG8ucmVhZENvdW50IT09by5zaXplKXtvLmtleT1udWxsLG8udHlwZT0xO2NvbnRpbnVlIGV9aS5wb3AoKSx0PW8ubWFwfX19cmV0dXJuIHR9dmFyIHN9LGUucHJvdG90eXBlLnJlYWRIZWFkQnl0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWRCeXRlPT09SCYmKHRoaXMuaGVhZEJ5dGU9dGhpcy5yZWFkVTgoKSksdGhpcy5oZWFkQnl0ZX0sZS5wcm90b3R5cGUuY29tcGxldGU9ZnVuY3Rpb24oKXt0aGlzLmhlYWRCeXRlPUh9LGUucHJvdG90eXBlLnJlYWRBcnJheVNpemU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlYWRIZWFkQnl0ZSgpO3N3aXRjaChlKXtjYXNlIDIyMDpyZXR1cm4gdGhpcy5yZWFkVTE2KCk7Y2FzZSAyMjE6cmV0dXJuIHRoaXMucmVhZFUzMigpO2RlZmF1bHQ6aWYoZTwxNjApcmV0dXJuIGUtMTQ0O3Rocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBhcnJheSB0eXBlIGJ5dGU6IFwiK2ooZSkpfX0sZS5wcm90b3R5cGUucHVzaE1hcFN0YXRlPWZ1bmN0aW9uKGUpe2lmKGU+dGhpcy5tYXhNYXBMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogbWFwIGxlbmd0aCAoXCIrZStcIikgPiBtYXhNYXBMZW5ndGhMZW5ndGggKFwiK3RoaXMubWF4TWFwTGVuZ3RoK1wiKVwiKTt0aGlzLnN0YWNrLnB1c2goe3R5cGU6MSxzaXplOmUsa2V5Om51bGwscmVhZENvdW50OjAsbWFwOnt9fSl9LGUucHJvdG90eXBlLnB1c2hBcnJheVN0YXRlPWZ1bmN0aW9uKGUpe2lmKGU+dGhpcy5tYXhBcnJheUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbGVuZ3RoIGV4Y2VlZGVkOiBhcnJheSBsZW5ndGggKFwiK2UrXCIpID4gbWF4QXJyYXlMZW5ndGggKFwiK3RoaXMubWF4QXJyYXlMZW5ndGgrXCIpXCIpO3RoaXMuc3RhY2sucHVzaCh7dHlwZTowLHNpemU6ZSxhcnJheTpuZXcgQXJyYXkoZSkscG9zaXRpb246MH0pfSxlLnByb3RvdHlwZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKGUsdCl7aWYoZT50aGlzLm1heFN0ckxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbGVuZ3RoIGV4Y2VlZGVkOiBVVEYtOCBieXRlIGxlbmd0aCAoXCIrZStcIikgPiBtYXhTdHJMZW5ndGggKFwiK3RoaXMubWF4U3RyTGVuZ3RoK1wiKVwiKTtpZih0aGlzLmJ5dGVzLmJ5dGVMZW5ndGg8dGhpcy5wb3MrdCtlKXRocm93IEo7dmFyIHIsbj10aGlzLnBvcyt0O3JldHVybiByPXRoaXMuY2FjaGVkS2V5RGVjb2RlciYmdGhpcy5zdGF0ZUlzTWFwS2V5KCkmJnRoaXMuY2FjaGVkS2V5RGVjb2Rlci5jYW5CZUNhY2hlZChlKT90aGlzLmNhY2hlZEtleURlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMsbixlKTpvJiZlPjIwMD9mdW5jdGlvbihlLHQscil7dmFyIG49ZS5zdWJhcnJheSh0LHQrcik7cmV0dXJuIGYuZGVjb2RlKG4pfSh0aGlzLmJ5dGVzLG4sZSk6QSYmZT4xMDI0P0kodGhpcy5ieXRlcyxuLGUpOmModGhpcy5ieXRlcyxuLGUpLHRoaXMucG9zKz10K2Uscn0sZS5wcm90b3R5cGUuc3RhdGVJc01hcEtleT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YWNrLmxlbmd0aD4wJiYxPT09dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXS50eXBlfSxlLnByb3RvdHlwZS5kZWNvZGVCaW5hcnk9ZnVuY3Rpb24oZSx0KXtpZihlPnRoaXMubWF4QmluTGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IGJpbiBsZW5ndGggKFwiK2UrXCIpID4gbWF4QmluTGVuZ3RoIChcIit0aGlzLm1heEJpbkxlbmd0aCtcIilcIik7aWYoIXRoaXMuaGFzUmVtYWluaW5nKGUrdCkpdGhyb3cgSjt2YXIgcj10aGlzLnBvcyt0LG49dGhpcy5ieXRlcy5zdWJhcnJheShyLHIrZSk7cmV0dXJuIHRoaXMucG9zKz10K2Usbn0sZS5wcm90b3R5cGUuZGVjb2RlRXh0ZW5zaW9uPWZ1bmN0aW9uKGUsdCl7aWYoZT50aGlzLm1heEV4dExlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbGVuZ3RoIGV4Y2VlZGVkOiBleHQgbGVuZ3RoIChcIitlK1wiKSA+IG1heEV4dExlbmd0aCAoXCIrdGhpcy5tYXhFeHRMZW5ndGgrXCIpXCIpO3ZhciByPXRoaXMudmlldy5nZXRJbnQ4KHRoaXMucG9zK3QpLG49dGhpcy5kZWNvZGVCaW5hcnkoZSx0KzEpO3JldHVybiB0aGlzLmV4dGVuc2lvbkNvZGVjLmRlY29kZShuLHIpfSxlLnByb3RvdHlwZS5sb29rVTg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKX0sZS5wcm90b3R5cGUubG9va1UxNj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMucG9zKX0sZS5wcm90b3R5cGUubG9va1UzMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zKX0sZS5wcm90b3R5cGUucmVhZFU4PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrKyxlfSxlLnByb3RvdHlwZS5yZWFkSTg9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKyssZX0sZS5wcm90b3R5cGUucmVhZFUxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9MixlfSxlLnByb3RvdHlwZS5yZWFkSTE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEludDE2KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTIsZX0sZS5wcm90b3R5cGUucmVhZFUzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkSTMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0sZS5wcm90b3R5cGUucmVhZFU2ND1mdW5jdGlvbigpe3ZhciBlLHQscj0oZT10aGlzLnZpZXcsdD10aGlzLnBvcyw0Mjk0OTY3Mjk2KmUuZ2V0VWludDMyKHQpK2UuZ2V0VWludDMyKHQrNCkpO3JldHVybiB0aGlzLnBvcys9OCxyfSxlLnByb3RvdHlwZS5yZWFkSTY0PWZ1bmN0aW9uKCl7dmFyIGU9ZCh0aGlzLnZpZXcsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxlLnByb3RvdHlwZS5yZWFkRjMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkRjY0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEZsb2F0NjQodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxlfSgpLCQ9e307ZnVuY3Rpb24gZWUoZSx0KXt2b2lkIDA9PT10JiYodD0kKTt2YXIgcj1uZXcgWih0LmV4dGVuc2lvbkNvZGVjLHQubWF4U3RyTGVuZ3RoLHQubWF4QmluTGVuZ3RoLHQubWF4QXJyYXlMZW5ndGgsdC5tYXhNYXBMZW5ndGgsdC5tYXhFeHRMZW5ndGgpO3JldHVybiByLnNldEJ1ZmZlcihlKSxyLmRlY29kZVNpbmdsZVN5bmMoKX12YXIgdGU9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPXMudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX0scmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByZT8odGhpcy52PWUsdGhpcyk6bmV3IHJlKGUpfSxuZT1mdW5jdGlvbihlLHQscil7aWYoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7dmFyIG4saT1yLmFwcGx5KGUsdHx8W10pLG89W107cmV0dXJuIG49e30scyhcIm5leHRcIikscyhcInRocm93XCIpLHMoXCJyZXR1cm5cIiksbltTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbjtmdW5jdGlvbiBzKGUpe2lbZV0mJihuW2VdPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLG4pe28ucHVzaChbZSx0LHIsbl0pPjF8fGEoZSx0KX0pfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIHJlP1Byb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oaCx1KTpjKG9bMF1bMl0scil9Y2F0Y2goZSl7YyhvWzBdWzNdLGUpfXZhciByfWZ1bmN0aW9uIGgoZSl7YShcIm5leHRcIixlKX1mdW5jdGlvbiB1KGUpe2EoXCJ0aHJvd1wiLGUpfWZ1bmN0aW9uIGMoZSx0KXtlKHQpLG8uc2hpZnQoKSxvLmxlbmd0aCYmYShvWzBdWzBdLG9bMF1bMV0pfX07ZnVuY3Rpb24gaWUoZSl7cmV0dXJuIG51bGwhPWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdP2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG5lKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKCl7dmFyIHQscixuLGk7cmV0dXJuIHRlKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDp0PWUuZ2V0UmVhZGVyKCksby5sYWJlbD0xO2Nhc2UgMTpvLnRyeXMucHVzaChbMSwsOSwxMF0pLG8ubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQscmUodC5yZWFkKCkpXTtjYXNlIDM6cmV0dXJuIHI9by5zZW50KCksbj1yLmRvbmUsaT1yLnZhbHVlLG4/WzQscmUodm9pZCAwKV06WzMsNV07Y2FzZSA0OnJldHVyblsyLG8uc2VudCgpXTtjYXNlIDU6cmV0dXJuWzQscmUoaSldO2Nhc2UgNjpyZXR1cm5bNCxvLnNlbnQoKV07Y2FzZSA3OnJldHVybiBvLnNlbnQoKSxbMywyXTtjYXNlIDg6cmV0dXJuWzMsMTBdO2Nhc2UgOTpyZXR1cm4gdC5yZWxlYXNlTG9jaygpLFs3XTtjYXNlIDEwOnJldHVyblsyXX19KX0pfShlKX12YXIgb2U9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoZnVuY3Rpb24oaSxvKXtmdW5jdGlvbiBzKGUpe3RyeXtoKG4ubmV4dChlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gYShlKXt0cnl7aChuLnRocm93KGUpKX1jYXRjaChlKXtvKGUpfX1mdW5jdGlvbiBoKGUpe3ZhciB0O2UuZG9uZT9pKGUudmFsdWUpOih0PWUudmFsdWUsdCBpbnN0YW5jZW9mIHI/dDpuZXcgcihmdW5jdGlvbihlKXtlKHQpfSkpLnRoZW4ocyxhKX1oKChuPW4uYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KX0sc2U9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPXMudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX07ZnVuY3Rpb24gYWUoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9JCksb2UodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIHNlKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuIHI9aWUoZSksWzIsbmV3IFoodC5leHRlbnNpb25Db2RlYyx0Lm1heFN0ckxlbmd0aCx0Lm1heEJpbkxlbmd0aCx0Lm1heEFycmF5TGVuZ3RoLHQubWF4TWFwTGVuZ3RoLHQubWF4RXh0TGVuZ3RoKS5kZWNvZGVTaW5nbGVBc3luYyhyKV19KX0pfWZ1bmN0aW9uIGhlKGUsdCl7dm9pZCAwPT09dCYmKHQ9JCk7dmFyIHI9aWUoZSk7cmV0dXJuIG5ldyBaKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCkuZGVjb2RlQXJyYXlTdHJlYW0ocil9ZnVuY3Rpb24gdWUoZSx0KXt2b2lkIDA9PT10JiYodD0kKTt2YXIgcj1pZShlKTtyZXR1cm4gbmV3IFoodC5leHRlbnNpb25Db2RlYyx0Lm1heFN0ckxlbmd0aCx0Lm1heEJpbkxlbmd0aCx0Lm1heEFycmF5TGVuZ3RoLHQubWF4TWFwTGVuZ3RoLHQubWF4RXh0TGVuZ3RoKS5kZWNvZGVTdHJlYW0ocil9ci5kKHQsXCJlbmNvZGVcIixmdW5jdGlvbigpe3JldHVybiBQfSksci5kKHQsXCJkZWNvZGVcIixmdW5jdGlvbigpe3JldHVybiBlZX0pLHIuZCh0LFwiZGVjb2RlQXN5bmNcIixmdW5jdGlvbigpe3JldHVybiBhZX0pLHIuZCh0LFwiZGVjb2RlQXJyYXlTdHJlYW1cIixmdW5jdGlvbigpe3JldHVybiBoZX0pLHIuZCh0LFwiZGVjb2RlU3RyZWFtXCIsZnVuY3Rpb24oKXtyZXR1cm4gdWV9KSxyLmQodCxcIkRlY29kZXJcIixmdW5jdGlvbigpe3JldHVybiBafSksci5kKHQsXCJFbmNvZGVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHIuZCh0LFwiRXh0ZW5zaW9uQ29kZWNcIixmdW5jdGlvbigpe3JldHVybiBTfSksci5kKHQsXCJFeHREYXRhXCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHIuZCh0LFwiRVhUX1RJTUVTVEFNUFwiLGZ1bmN0aW9uKCl7cmV0dXJuLTF9KSxyLmQodCxcImVuY29kZURhdGVUb1RpbWVTcGVjXCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHIuZCh0LFwiZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSxyLmQodCxcImRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWNcIixmdW5jdGlvbigpe3JldHVybiBtfSksci5kKHQsXCJlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIixmdW5jdGlvbigpe3JldHVybiBifSksci5kKHQsXCJkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIixmdW5jdGlvbigpe3JldHVybiBVfSksci5kKHQsXCJfX1dBU01fQVZBSUxBQkxFXCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pfV0pfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2dwYWNrLm1pbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcbmZ1bmN0aW9uIHN0cmljdCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBzdHJpY3QpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKVxuICAgID8gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKVxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICB2YXIgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLypcbiAqIFtoaS1iYXNlMzJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvaGktYmFzZTMyfVxuICpcbiAqIEB2ZXJzaW9uIDAuNS4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHt9O1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkhJX0JBU0UzMl9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5ISV9CQVNFMzJfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQkFTRTMyX0VOQ09ERV9DSEFSID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3Jy5zcGxpdCgnJyk7XG4gIHZhciBCQVNFMzJfREVDT0RFX0NIQVIgPSB7XG4gICAgJ0EnOiAwLCAnQic6IDEsICdDJzogMiwgJ0QnOiAzLCAnRSc6IDQsICdGJzogNSwgJ0cnOiA2LCAnSCc6IDcsICdJJzogOCxcbiAgICAnSic6IDksICdLJzogMTAsICdMJzogMTEsICdNJzogMTIsICdOJzogMTMsICdPJzogMTQsICdQJzogMTUsICdRJzogMTYsXG4gICAgJ1InOiAxNywgJ1MnOiAxOCwgJ1QnOiAxOSwgJ1UnOiAyMCwgJ1YnOiAyMSwgJ1cnOiAyMiwgJ1gnOiAyMywgJ1knOiAyNCxcbiAgICAnWic6IDI1LCAnMic6IDI2LCAnMyc6IDI3LCAnNCc6IDI4LCAnNSc6IDI5LCAnNic6IDMwLCAnNyc6IDMxXG4gIH07XG5cbiAgdmFyIGJsb2NrcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcblxuICB2YXIgdGhyb3dJbnZhbGlkVXRmOCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcGFydGlhbCkge1xuICAgIGlmIChwYXJ0aWFsLmxlbmd0aCA+IDEwKSB7XG4gICAgICBwYXJ0aWFsID0gJy4uLicgKyBwYXJ0aWFsLnN1YnN0cigtMTApO1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdEZWNvZGVkIGRhdGEgaXMgbm90IHZhbGlkIFVURi04LidcbiAgICAgICsgJyBNYXliZSB0cnkgYmFzZTMyLmRlY29kZS5hc0J5dGVzKCk/J1xuICAgICAgKyAnIFBhcnRpYWwgZGF0YSBhZnRlciByZWFkaW5nICcgKyBwb3NpdGlvbiArICcgYnl0ZXM6ICcgKyBwYXJ0aWFsICsgJyA8LScpO1xuICAgIGVyci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRocm93IGVycjtcbiAgfTtcblxuICB2YXIgdG9VdGY4U3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgdmFyIHN0ciA9ICcnLCBsZW5ndGggPSBieXRlcy5sZW5ndGgsIGkgPSAwLCBmb2xsb3dpbmdDaGFycyA9IDAsIGIsIGM7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIGIgPSBieXRlc1tpKytdO1xuICAgICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGIgPiAweEJGICYmIGIgPD0gMHhERikge1xuICAgICAgICBjID0gYiAmIDB4MUY7XG4gICAgICAgIGZvbGxvd2luZ0NoYXJzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYiA8PSAweEVGKSB7XG4gICAgICAgIGMgPSBiICYgMHgwRjtcbiAgICAgICAgZm9sbG93aW5nQ2hhcnMgPSAyO1xuICAgICAgfSBlbHNlIGlmIChiIDw9IDB4RjcpIHtcbiAgICAgICAgYyA9IGIgJiAweDA3O1xuICAgICAgICBmb2xsb3dpbmdDaGFycyA9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0ludmFsaWRVdGY4KGksIHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9sbG93aW5nQ2hhcnM7ICsraikge1xuICAgICAgICBiID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgaWYgKGIgPCAweDgwIHx8IGIgPiAweEJGKSB7XG4gICAgICAgICAgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGMgPDw9IDY7XG4gICAgICAgIGMgKz0gYiAmIDB4M0Y7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHtcbiAgICAgICAgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgfVxuICAgICAgaWYgKGMgPiAweDEwRkZGRikge1xuICAgICAgICB0aHJvd0ludmFsaWRVdGY4KGksIHN0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjIDw9IDB4RkZGRikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTApICsgMHhEODAwKTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDNGRikgKyAweERDMDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHZhciBkZWNvZGVBc0J5dGVzID0gZnVuY3Rpb24gKGJhc2UzMlN0cikge1xuICAgIGlmICghL15bQS1aMi03PV0rJC8udGVzdChiYXNlMzJTdHIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFzZTMyIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgYmFzZTMyU3RyID0gYmFzZTMyU3RyLnJlcGxhY2UoLz0vZywgJycpO1xuICAgIHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIGJ5dGVzID0gW10sIGluZGV4ID0gMCwgbGVuZ3RoID0gYmFzZTMyU3RyLmxlbmd0aDtcblxuICAgIC8vIDQgY2hhciB0byAzIGJ5dGVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvdW50ID0gbGVuZ3RoID4+IDMgPDwgMzsgaSA8IGNvdW50Oykge1xuICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY1ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY4ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2MSA8PCAzIHwgdjIgPj4+IDIpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2NCA8PCA0IHwgdjUgPj4+IDEpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjUgPDwgNyB8IHY2IDw8IDIgfCB2NyA+Pj4gMykgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2NyA8PCA1IHwgdjgpICYgMjU1O1xuICAgIH1cblxuICAgIC8vIHJlbWFpbiBieXRlc1xuICAgIHZhciByZW1haW4gPSBsZW5ndGggLSBjb3VudDtcbiAgICBpZiAocmVtYWluID09PSAyKSB7XG4gICAgICB2MSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTU7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDQpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2MSA8PCAzIHwgdjIgPj4+IDIpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTU7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDUpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHYyIDw8IDYgfCB2MyA8PCAxIHwgdjQgPj4+IDQpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjQgPDwgNCB8IHY1ID4+PiAxKSAmIDI1NTtcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gNykge1xuICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY1ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSAmIDI1NTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHY0IDw8IDQgfCB2NSA+Pj4gMSkgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2NSA8PCA3IHwgdjYgPDwgMiB8IHY3ID4+PiAzKSAmIDI1NTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xuXG4gIHZhciBlbmNvZGVBc2NpaSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCBiYXNlMzJTdHIgPSAnJywgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgY291bnQgPSBwYXJzZUludChsZW5ndGggLyA1KSAqIDU7IGkgPCBjb3VudDspIHtcbiAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHY0ID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHY1ID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQgfCB2MyA+Pj4gNCkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEgfCB2NCA+Pj4gNykgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0ID4+PiAyKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPDwgMyB8IHY1ID4+PiA1KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlt2NSAmIDMxXTtcbiAgICB9XG5cbiAgICAvLyByZW1haW4gY2hhclxuICAgIHZhciByZW1haW4gPSBsZW5ndGggLSBjb3VudDtcbiAgICBpZiAocmVtYWluID09PSAxKSB7XG4gICAgICB2MSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYxIDw8IDIpICYgMzFdICtcbiAgICAgICAgJz09PT09PSc7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDIpIHtcbiAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPj4+IDEpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0KSAmIDMxXSArXG4gICAgICAgICc9PT09JztcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMykge1xuICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgdjIgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgdjMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQgfCB2MyA+Pj4gNCkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEpICYgMzFdICtcbiAgICAgICAgJz09PSc7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDQpIHtcbiAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHY0ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPj4+IDEpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0IHwgdjMgPj4+IDQpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MyA8PCAxIHwgdjQgPj4+IDcpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2NCA+Pj4gMikgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0IDw8IDMpICYgMzFdICtcbiAgICAgICAgJz0nO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTMyU3RyO1xuICB9O1xuXG4gIHZhciBlbmNvZGVVdGY4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIGNvZGUsIGVuZCA9IGZhbHNlLCBiYXNlMzJTdHIgPSAnJyxcbiAgICAgIGluZGV4ID0gMCwgaSwgc3RhcnQgPSAwLCBieXRlcyA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgZG8ge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzWzVdO1xuICAgICAgYmxvY2tzWzFdID0gYmxvY2tzWzZdO1xuICAgICAgYmxvY2tzWzJdID0gYmxvY2tzWzddO1xuICAgICAgZm9yIChpID0gc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA1OyArK2luZGV4KSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJsb2Nrc1tpKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4YzAgfCAoY29kZSA+PiA2KTtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4ODAgfCAoY29kZSAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4ZTAgfCAoY29kZSA+PiAxMik7XG4gICAgICAgICAgYmxvY2tzW2krK10gPSAweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgYmxvY2tzW2krK10gPSAweDgwIHwgKGNvZGUgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4ZjAgfCAoY29kZSA+PiAxOCk7XG4gICAgICAgICAgYmxvY2tzW2krK10gPSAweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpO1xuICAgICAgICAgIGJsb2Nrc1tpKytdID0gMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpO1xuICAgICAgICAgIGJsb2Nrc1tpKytdID0gMHg4MCB8IChjb2RlICYgMHgzZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ5dGVzICs9IGkgLSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gaSAtIDU7XG4gICAgICBpZiAoaW5kZXggPT09IGxlbmd0aCkge1xuICAgICAgICArK2luZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoICYmIGkgPCA2KSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2MSA9IGJsb2Nrc1swXTtcbiAgICAgIGlmIChpID4gNCkge1xuICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgIHY0ID0gYmxvY2tzWzNdO1xuICAgICAgICB2NSA9IGJsb2Nrc1s0XTtcbiAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MyA8PCAxIHwgdjQgPj4+IDcpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0ID4+PiAyKSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2NCA8PCAzIHwgdjUgPj4+IDUpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbdjUgJiAzMV07XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMikgJiAzMV0gK1xuICAgICAgICAgICc9PT09PT0nO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAyKSB7XG4gICAgICAgIHYyID0gYmxvY2tzWzFdO1xuICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0KSAmIDMxXSArXG4gICAgICAgICAgJz09PT0nO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHYyID0gYmxvY2tzWzFdO1xuICAgICAgICB2MyA9IGJsb2Nrc1syXTtcbiAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MyA8PCAxKSAmIDMxXSArXG4gICAgICAgICAgJz09PSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgIHY0ID0gYmxvY2tzWzNdO1xuICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0IHwgdjMgPj4+IDQpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEgfCB2NCA+Pj4gNykgJiAzMV0gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPj4+IDIpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0IDw8IDMpICYgMzFdICtcbiAgICAgICAgICAnPSc7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIWVuZCk7XG4gICAgcmV0dXJuIGJhc2UzMlN0cjtcbiAgfTtcblxuICB2YXIgZW5jb2RlQnl0ZXMgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCBiYXNlMzJTdHIgPSAnJywgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IHBhcnNlSW50KGxlbmd0aCAvIDUpICogNTsgaSA8IGNvdW50Oykge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgdjQgPSBieXRlc1tpKytdO1xuICAgICAgdjUgPSBieXRlc1tpKytdO1xuICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYxIDw8IDIgfCB2MiA+Pj4gNikgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjMgPDwgMSB8IHY0ID4+PiA3KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPj4+IDIpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2NCA8PCAzIHwgdjUgPj4+IDUpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSW3Y1ICYgMzFdO1xuICAgIH1cblxuICAgIC8vIHJlbWFpbiBjaGFyXG4gICAgdmFyIHJlbWFpbiA9IGxlbmd0aCAtIGNvdW50O1xuICAgIGlmIChyZW1haW4gPT09IDEpIHtcbiAgICAgIHYxID0gYnl0ZXNbaV07XG4gICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMikgJiAzMV0gK1xuICAgICAgICAnPT09PT09JztcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMikge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpXTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQpICYgMzFdICtcbiAgICAgICAgJz09PT0nO1xuICAgIH0gZWxzZSBpZiAocmVtYWluID09PSAzKSB7XG4gICAgICB2MSA9IGJ5dGVzW2krK107XG4gICAgICB2MiA9IGJ5dGVzW2krK107XG4gICAgICB2MyA9IGJ5dGVzW2ldO1xuICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYxIDw8IDIgfCB2MiA+Pj4gNikgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjMgPDwgMSkgJiAzMV0gK1xuICAgICAgICAnPT09JztcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gNCkge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgdjQgPSBieXRlc1tpXTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQgfCB2MyA+Pj4gNCkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEgfCB2NCA+Pj4gNykgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0ID4+PiAyKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPDwgMykgJiAzMV0gK1xuICAgICAgICAnPSc7XG4gICAgfVxuICAgIHJldHVybiBiYXNlMzJTdHI7XG4gIH07XG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCwgYXNjaWlPbmx5KSB7XG4gICAgdmFyIG5vdFN0cmluZyA9IHR5cGVvZihpbnB1dCkgIT09ICdzdHJpbmcnO1xuICAgIGlmIChub3RTdHJpbmcgJiYgaW5wdXQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICBpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKGFzY2lpT25seSkge1xuICAgICAgcmV0dXJuIGVuY29kZUFzY2lpKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVuY29kZVV0ZjgoaW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJhc2UzMlN0ciwgYXNjaWlPbmx5KSB7XG4gICAgaWYgKCFhc2NpaU9ubHkpIHtcbiAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoZGVjb2RlQXNCeXRlcyhiYXNlMzJTdHIpKTtcbiAgICB9XG4gICAgaWYgKCEvXltBLVoyLTc9XSskLy50ZXN0KGJhc2UzMlN0cikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlMzIgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCBzdHIgPSAnJywgbGVuZ3RoID0gYmFzZTMyU3RyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAobGVuZ3RoID09PSAtMSkge1xuICAgICAgbGVuZ3RoID0gYmFzZTMyU3RyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyA4IGNoYXIgdG8gNSBieXRlc1xuICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IGxlbmd0aCA+PiAzIDw8IDM7IGkgPCBjb3VudDspIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjYgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2OCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjQgPDwgNCB8IHY1ID4+PiAxKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2NSA8PCA3IHwgdjYgPDwgMiB8IHY3ID4+PiAzKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2NyA8PCA1IHwgdjgpICYgMjU1KTtcbiAgICB9XG5cbiAgICAvLyByZW1haW4gYnl0ZXNcbiAgICB2YXIgcmVtYWluID0gbGVuZ3RoIC0gY291bnQ7XG4gICAgaWYgKHJlbWFpbiA9PT0gMikge1xuICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NSk7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDQpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSAmIDI1NSk7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDUpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjQgPDwgNCB8IHY1ID4+PiAxKSAmIDI1NSk7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDcpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjYgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2NCA8PCA0IHwgdjUgPj4+IDEpICYgMjU1KSArXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKHY1IDw8IDcgfCB2NiA8PCAyIHwgdjcgPj4+IDMpICYgMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9O1xuICBkZWNvZGUuYXNCeXRlcyA9IGRlY29kZUFzQnl0ZXM7XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICByb290LmJhc2UzMiA9IGV4cG9ydHM7XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8qXG4gKiBbanMtc2hhNTEyXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTUxMn1cbiAqXG4gKiBAdmVyc2lvbiAwLjguMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJTlBVVF9FUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgRklOQUxJWkVfRVJST1IgPSAnZmluYWxpemUgYWxyZWFkeSBjYWxsZWQnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTUxMl9OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTUxMl9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHtcbiAgICByb290ID0gc2VsZjtcbiAgfVxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBNTEyX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTUxMl9OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG4gIHZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xuICB2YXIgSyA9IFtcbiAgICAweDQyOEEyRjk4LCAweEQ3MjhBRTIyLCAweDcxMzc0NDkxLCAweDIzRUY2NUNELFxuICAgIDB4QjVDMEZCQ0YsIDB4RUM0RDNCMkYsIDB4RTlCNURCQTUsIDB4ODE4OURCQkMsXG4gICAgMHgzOTU2QzI1QiwgMHhGMzQ4QjUzOCwgMHg1OUYxMTFGMSwgMHhCNjA1RDAxOSxcbiAgICAweDkyM0Y4MkE0LCAweEFGMTk0RjlCLCAweEFCMUM1RUQ1LCAweERBNkQ4MTE4LFxuICAgIDB4RDgwN0FBOTgsIDB4QTMwMzAyNDIsIDB4MTI4MzVCMDEsIDB4NDU3MDZGQkUsXG4gICAgMHgyNDMxODVCRSwgMHg0RUU0QjI4QywgMHg1NTBDN0RDMywgMHhENUZGQjRFMixcbiAgICAweDcyQkU1RDc0LCAweEYyN0I4OTZGLCAweDgwREVCMUZFLCAweDNCMTY5NkIxLFxuICAgIDB4OUJEQzA2QTcsIDB4MjVDNzEyMzUsIDB4QzE5QkYxNzQsIDB4Q0Y2OTI2OTQsXG4gICAgMHhFNDlCNjlDMSwgMHg5RUYxNEFEMiwgMHhFRkJFNDc4NiwgMHgzODRGMjVFMyxcbiAgICAweDBGQzE5REM2LCAweDhCOENENUI1LCAweDI0MENBMUNDLCAweDc3QUM5QzY1LFxuICAgIDB4MkRFOTJDNkYsIDB4NTkyQjAyNzUsIDB4NEE3NDg0QUEsIDB4NkVBNkU0ODMsXG4gICAgMHg1Q0IwQTlEQywgMHhCRDQxRkJENCwgMHg3NkY5ODhEQSwgMHg4MzExNTNCNSxcbiAgICAweDk4M0U1MTUyLCAweEVFNjZERkFCLCAweEE4MzFDNjZELCAweDJEQjQzMjEwLFxuICAgIDB4QjAwMzI3QzgsIDB4OThGQjIxM0YsIDB4QkY1OTdGQzcsIDB4QkVFRjBFRTQsXG4gICAgMHhDNkUwMEJGMywgMHgzREE4OEZDMiwgMHhENUE3OTE0NywgMHg5MzBBQTcyNSxcbiAgICAweDA2Q0E2MzUxLCAweEUwMDM4MjZGLCAweDE0MjkyOTY3LCAweDBBMEU2RTcwLFxuICAgIDB4MjdCNzBBODUsIDB4NDZEMjJGRkMsIDB4MkUxQjIxMzgsIDB4NUMyNkM5MjYsXG4gICAgMHg0RDJDNkRGQywgMHg1QUM0MkFFRCwgMHg1MzM4MEQxMywgMHg5RDk1QjNERixcbiAgICAweDY1MEE3MzU0LCAweDhCQUY2M0RFLCAweDc2NkEwQUJCLCAweDNDNzdCMkE4LFxuICAgIDB4ODFDMkM5MkUsIDB4NDdFREFFRTYsIDB4OTI3MjJDODUsIDB4MTQ4MjM1M0IsXG4gICAgMHhBMkJGRThBMSwgMHg0Q0YxMDM2NCwgMHhBODFBNjY0QiwgMHhCQzQyMzAwMSxcbiAgICAweEMyNEI4QjcwLCAweEQwRjg5NzkxLCAweEM3NkM1MUEzLCAweDA2NTRCRTMwLFxuICAgIDB4RDE5MkU4MTksIDB4RDZFRjUyMTgsIDB4RDY5OTA2MjQsIDB4NTU2NUE5MTAsXG4gICAgMHhGNDBFMzU4NSwgMHg1NzcxMjAyQSwgMHgxMDZBQTA3MCwgMHgzMkJCRDFCOCxcbiAgICAweDE5QTRDMTE2LCAweEI4RDJEMEM4LCAweDFFMzc2QzA4LCAweDUxNDFBQjUzLFxuICAgIDB4Mjc0ODc3NEMsIDB4REY4RUVCOTksIDB4MzRCMEJDQjUsIDB4RTE5QjQ4QTgsXG4gICAgMHgzOTFDMENCMywgMHhDNUM5NUE2MywgMHg0RUQ4QUE0QSwgMHhFMzQxOEFDQixcbiAgICAweDVCOUNDQTRGLCAweDc3NjNFMzczLCAweDY4MkU2RkYzLCAweEQ2QjJCOEEzLFxuICAgIDB4NzQ4RjgyRUUsIDB4NURFRkIyRkMsIDB4NzhBNTYzNkYsIDB4NDMxNzJGNjAsXG4gICAgMHg4NEM4NzgxNCwgMHhBMUYwQUI3MiwgMHg4Q0M3MDIwOCwgMHgxQTY0MzlFQyxcbiAgICAweDkwQkVGRkZBLCAweDIzNjMxRTI4LCAweEE0NTA2Q0VCLCAweERFODJCREU5LFxuICAgIDB4QkVGOUEzRjcsIDB4QjJDNjc5MTUsIDB4QzY3MTc4RjIsIDB4RTM3MjUzMkIsXG4gICAgMHhDQTI3M0VDRSwgMHhFQTI2NjE5QywgMHhEMTg2QjhDNywgMHgyMUMwQzIwNyxcbiAgICAweEVBREE3REQ2LCAweENERTBFQjFFLCAweEY1N0Q0RjdGLCAweEVFNkVEMTc4LFxuICAgIDB4MDZGMDY3QUEsIDB4NzIxNzZGQkEsIDB4MEE2MzdEQzUsIDB4QTJDODk4QTYsXG4gICAgMHgxMTNGOTgwNCwgMHhCRUY5MERBRSwgMHgxQjcxMEIzNSwgMHgxMzFDNDcxQixcbiAgICAweDI4REI3N0Y1LCAweDIzMDQ3RDg0LCAweDMyQ0FBQjdCLCAweDQwQzcyNDkzLFxuICAgIDB4M0M5RUJFMEEsIDB4MTVDOUJFQkMsIDB4NDMxRDY3QzQsIDB4OUMxMDBENEMsXG4gICAgMHg0Q0M1RDRCRSwgMHhDQjNFNDJCNiwgMHg1OTdGMjk5QywgMHhGQzY1N0UyQSxcbiAgICAweDVGQ0I2RkFCLCAweDNBRDZGQUVDLCAweDZDNDQxOThDLCAweDRBNDc1ODE3XG4gIF07XG5cbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2FycmF5JywgJ2RpZ2VzdCcsICdhcnJheUJ1ZmZlciddO1xuXG4gIHZhciBibG9ja3MgPSBbXTtcblxuICBpZiAocm9vdC5KU19TSEE1MTJfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBNTEyX05PX0FSUkFZX0JVRkZFUl9JU19WSUVXIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgYml0cykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBTaGE1MTIoYml0cywgdHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKCdoZXgnLCBiaXRzKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGE1MTIoYml0cyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlT3V0cHV0TWV0aG9kKHR5cGUsIGJpdHMpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKG91dHB1dFR5cGUsIGJpdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBIbWFjU2hhNTEyKGtleSwgYml0cywgdHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSG1hY01ldGhvZCA9IGZ1bmN0aW9uIChiaXRzKSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QoJ2hleCcsIGJpdHMpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEhtYWNTaGE1MTIoa2V5LCBiaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShrZXkpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QodHlwZSwgYml0cyk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgZnVuY3Rpb24gU2hhNTEyKGJpdHMsIHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9IGJsb2Nrc1s0XSA9XG4gICAgICBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPSBibG9ja3NbOF0gPVxuICAgICAgYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPSBibG9ja3NbMTJdID1cbiAgICAgIGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IGJsb2Nrc1sxNl0gPVxuICAgICAgYmxvY2tzWzE3XSA9IGJsb2Nrc1sxOF0gPSBibG9ja3NbMTldID0gYmxvY2tzWzIwXSA9XG4gICAgICBibG9ja3NbMjFdID0gYmxvY2tzWzIyXSA9IGJsb2Nrc1syM10gPSBibG9ja3NbMjRdID1cbiAgICAgIGJsb2Nrc1syNV0gPSBibG9ja3NbMjZdID0gYmxvY2tzWzI3XSA9IGJsb2Nrc1syOF0gPVxuICAgICAgYmxvY2tzWzI5XSA9IGJsb2Nrc1szMF0gPSBibG9ja3NbMzFdID0gYmxvY2tzWzMyXSA9IDA7XG4gICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ibG9ja3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgfVxuXG4gICAgaWYgKGJpdHMgPT0gMzg0KSB7XG4gICAgICB0aGlzLmgwaCA9IDB4Q0JCQjlENUQ7XG4gICAgICB0aGlzLmgwbCA9IDB4QzEwNTlFRDg7XG4gICAgICB0aGlzLmgxaCA9IDB4NjI5QTI5MkE7XG4gICAgICB0aGlzLmgxbCA9IDB4MzY3Q0Q1MDc7XG4gICAgICB0aGlzLmgyaCA9IDB4OTE1OTAxNUE7XG4gICAgICB0aGlzLmgybCA9IDB4MzA3MEREMTc7XG4gICAgICB0aGlzLmgzaCA9IDB4MTUyRkVDRDg7XG4gICAgICB0aGlzLmgzbCA9IDB4RjcwRTU5Mzk7XG4gICAgICB0aGlzLmg0aCA9IDB4NjczMzI2Njc7XG4gICAgICB0aGlzLmg0bCA9IDB4RkZDMDBCMzE7XG4gICAgICB0aGlzLmg1aCA9IDB4OEVCNDRBODc7XG4gICAgICB0aGlzLmg1bCA9IDB4Njg1ODE1MTE7XG4gICAgICB0aGlzLmg2aCA9IDB4REIwQzJFMEQ7XG4gICAgICB0aGlzLmg2bCA9IDB4NjRGOThGQTc7XG4gICAgICB0aGlzLmg3aCA9IDB4NDdCNTQ4MUQ7XG4gICAgICB0aGlzLmg3bCA9IDB4QkVGQTRGQTQ7XG4gICAgfSBlbHNlIGlmIChiaXRzID09IDI1Nikge1xuICAgICAgdGhpcy5oMGggPSAweDIyMzEyMTk0O1xuICAgICAgdGhpcy5oMGwgPSAweEZDMkJGNzJDO1xuICAgICAgdGhpcy5oMWggPSAweDlGNTU1RkEzO1xuICAgICAgdGhpcy5oMWwgPSAweEM4NEM2NEMyO1xuICAgICAgdGhpcy5oMmggPSAweDIzOTNCODZCO1xuICAgICAgdGhpcy5oMmwgPSAweDZGNTNCMTUxO1xuICAgICAgdGhpcy5oM2ggPSAweDk2Mzg3NzE5O1xuICAgICAgdGhpcy5oM2wgPSAweDU5NDBFQUJEO1xuICAgICAgdGhpcy5oNGggPSAweDk2MjgzRUUyO1xuICAgICAgdGhpcy5oNGwgPSAweEE4OEVGRkUzO1xuICAgICAgdGhpcy5oNWggPSAweEJFNUUxRTI1O1xuICAgICAgdGhpcy5oNWwgPSAweDUzODYzOTkyO1xuICAgICAgdGhpcy5oNmggPSAweDJCMDE5OUZDO1xuICAgICAgdGhpcy5oNmwgPSAweDJDODVCOEFBO1xuICAgICAgdGhpcy5oN2ggPSAweDBFQjcyRERDO1xuICAgICAgdGhpcy5oN2wgPSAweDgxQzUyQ0EyO1xuICAgIH0gZWxzZSBpZiAoYml0cyA9PSAyMjQpIHtcbiAgICAgIHRoaXMuaDBoID0gMHg4QzNEMzdDODtcbiAgICAgIHRoaXMuaDBsID0gMHgxOTU0NERBMjtcbiAgICAgIHRoaXMuaDFoID0gMHg3M0UxOTk2NjtcbiAgICAgIHRoaXMuaDFsID0gMHg4OURDRDRENjtcbiAgICAgIHRoaXMuaDJoID0gMHgxREZBQjdBRTtcbiAgICAgIHRoaXMuaDJsID0gMHgzMkZGOUM4MjtcbiAgICAgIHRoaXMuaDNoID0gMHg2NzlERDUxNDtcbiAgICAgIHRoaXMuaDNsID0gMHg1ODJGOUZDRjtcbiAgICAgIHRoaXMuaDRoID0gMHgwRjZEMkI2OTtcbiAgICAgIHRoaXMuaDRsID0gMHg3QkQ0NERBODtcbiAgICAgIHRoaXMuaDVoID0gMHg3N0UzNkY3MztcbiAgICAgIHRoaXMuaDVsID0gMHgwNEM0ODk0MjtcbiAgICAgIHRoaXMuaDZoID0gMHgzRjlEODVBODtcbiAgICAgIHRoaXMuaDZsID0gMHg2QTFEMzZDODtcbiAgICAgIHRoaXMuaDdoID0gMHgxMTEyRTZBRDtcbiAgICAgIHRoaXMuaDdsID0gMHg5MUQ2OTJBMTtcbiAgICB9IGVsc2UgeyAvLyA1MTJcbiAgICAgIHRoaXMuaDBoID0gMHg2QTA5RTY2NztcbiAgICAgIHRoaXMuaDBsID0gMHhGM0JDQzkwODtcbiAgICAgIHRoaXMuaDFoID0gMHhCQjY3QUU4NTtcbiAgICAgIHRoaXMuaDFsID0gMHg4NENBQTczQjtcbiAgICAgIHRoaXMuaDJoID0gMHgzQzZFRjM3MjtcbiAgICAgIHRoaXMuaDJsID0gMHhGRTk0RjgyQjtcbiAgICAgIHRoaXMuaDNoID0gMHhBNTRGRjUzQTtcbiAgICAgIHRoaXMuaDNsID0gMHg1RjFEMzZGMTtcbiAgICAgIHRoaXMuaDRoID0gMHg1MTBFNTI3RjtcbiAgICAgIHRoaXMuaDRsID0gMHhBREU2ODJEMTtcbiAgICAgIHRoaXMuaDVoID0gMHg5QjA1Njg4QztcbiAgICAgIHRoaXMuaDVsID0gMHgyQjNFNkMxRjtcbiAgICAgIHRoaXMuaDZoID0gMHgxRjgzRDlBQjtcbiAgICAgIHRoaXMuaDZsID0gMHhGQjQxQkQ2QjtcbiAgICAgIHRoaXMuaDdoID0gMHg1QkUwQ0QxOTtcbiAgICAgIHRoaXMuaDdsID0gMHgxMzdFMjE3OTtcbiAgICB9XG4gICAgdGhpcy5iaXRzID0gYml0cztcblxuICAgIHRoaXMuYmxvY2sgPSB0aGlzLnN0YXJ0ID0gdGhpcy5ieXRlcyA9IHRoaXMuaEJ5dGVzID0gMDtcbiAgICB0aGlzLmZpbmFsaXplZCA9IHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gIH1cblxuICBTaGE1MTIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRklOQUxJWkVfRVJST1IpO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNvZGUsIGluZGV4ID0gMCwgaSwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5oYXNoZWQpIHtcbiAgICAgICAgdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID0gYmxvY2tzWzRdID1cbiAgICAgICAgYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID0gYmxvY2tzWzhdID1cbiAgICAgICAgYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPSBibG9ja3NbMTJdID1cbiAgICAgICAgYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gYmxvY2tzWzE2XSA9XG4gICAgICAgIGJsb2Nrc1sxN10gPSBibG9ja3NbMThdID0gYmxvY2tzWzE5XSA9IGJsb2Nrc1syMF0gPVxuICAgICAgICBibG9ja3NbMjFdID0gYmxvY2tzWzIyXSA9IGJsb2Nrc1syM10gPSBibG9ja3NbMjRdID1cbiAgICAgICAgYmxvY2tzWzI1XSA9IGJsb2Nrc1syNl0gPSBibG9ja3NbMjddID0gYmxvY2tzWzI4XSA9XG4gICAgICAgIGJsb2Nrc1syOV0gPSBibG9ja3NbMzBdID0gYmxvY2tzWzMxXSA9IGJsb2Nrc1szMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZihub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDEyODsgKytpbmRleCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgMTI4OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgIHRoaXMuYnl0ZXMgKz0gaSAtIHRoaXMuc3RhcnQ7XG4gICAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1szMl07XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gMTI4O1xuICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgdGhpcy5oYXNoZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmJ5dGVzID4gNDI5NDk2NzI5NSkge1xuICAgICAgdGhpcy5oQnl0ZXMgKz0gdGhpcy5ieXRlcyAvIDQyOTQ5NjcyOTYgPDwgMDtcbiAgICAgIHRoaXMuYnl0ZXMgPSB0aGlzLmJ5dGVzICUgNDI5NDk2NzI5NjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU2hhNTEyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleDtcbiAgICBibG9ja3NbMzJdID0gdGhpcy5ibG9jaztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSBFWFRSQVtpICYgM107XG4gICAgdGhpcy5ibG9jayA9IGJsb2Nrc1szMl07XG4gICAgaWYgKGkgPj0gMTEyKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgfVxuICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgIGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9IGJsb2Nrc1s0XSA9XG4gICAgICBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPSBibG9ja3NbOF0gPVxuICAgICAgYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPSBibG9ja3NbMTJdID1cbiAgICAgIGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IGJsb2Nrc1sxNl0gPVxuICAgICAgYmxvY2tzWzE3XSA9IGJsb2Nrc1sxOF0gPSBibG9ja3NbMTldID0gYmxvY2tzWzIwXSA9XG4gICAgICBibG9ja3NbMjFdID0gYmxvY2tzWzIyXSA9IGJsb2Nrc1syM10gPSBibG9ja3NbMjRdID1cbiAgICAgIGJsb2Nrc1syNV0gPSBibG9ja3NbMjZdID0gYmxvY2tzWzI3XSA9IGJsb2Nrc1syOF0gPVxuICAgICAgYmxvY2tzWzI5XSA9IGJsb2Nrc1szMF0gPSBibG9ja3NbMzFdID0gYmxvY2tzWzMyXSA9IDA7XG4gICAgfVxuICAgIGJsb2Nrc1szMF0gPSB0aGlzLmhCeXRlcyA8PCAzIHwgdGhpcy5ieXRlcyA+Pj4gMjk7XG4gICAgYmxvY2tzWzMxXSA9IHRoaXMuYnl0ZXMgPDwgMztcbiAgICB0aGlzLmhhc2goKTtcbiAgfTtcblxuICBTaGE1MTIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGgwaCA9IHRoaXMuaDBoLCBoMGwgPSB0aGlzLmgwbCwgaDFoID0gdGhpcy5oMWgsIGgxbCA9IHRoaXMuaDFsLFxuICAgICAgaDJoID0gdGhpcy5oMmgsIGgybCA9IHRoaXMuaDJsLCBoM2ggPSB0aGlzLmgzaCwgaDNsID0gdGhpcy5oM2wsXG4gICAgICBoNGggPSB0aGlzLmg0aCwgaDRsID0gdGhpcy5oNGwsIGg1aCA9IHRoaXMuaDVoLCBoNWwgPSB0aGlzLmg1bCxcbiAgICAgIGg2aCA9IHRoaXMuaDZoLCBoNmwgPSB0aGlzLmg2bCwgaDdoID0gdGhpcy5oN2gsIGg3bCA9IHRoaXMuaDdsLFxuICAgICAgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGosIHMwaCwgczBsLCBzMWgsIHMxbCwgYzEsIGMyLCBjMywgYzQsXG4gICAgICBhYmgsIGFibCwgZGFoLCBkYWwsIGNkaCwgY2RsLCBiY2gsIGJjbCxcbiAgICAgIG1hamgsIG1hamwsIHQxaCwgdDFsLCB0MmgsIHQybCwgY2hoLCBjaGw7XG5cbiAgICBmb3IgKGogPSAzMjsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgICB0MWggPSBibG9ja3NbaiAtIDMwXTtcbiAgICAgIHQxbCA9IGJsb2Nrc1tqIC0gMjldO1xuICAgICAgczBoID0gKCh0MWggPj4+IDEpIHwgKHQxbCA8PCAzMSkpIF4gKCh0MWggPj4+IDgpIHwgKHQxbCA8PCAyNCkpIF4gKHQxaCA+Pj4gNyk7XG4gICAgICBzMGwgPSAoKHQxbCA+Pj4gMSkgfCAodDFoIDw8IDMxKSkgXiAoKHQxbCA+Pj4gOCkgfCAodDFoIDw8IDI0KSkgXiAoKHQxbCA+Pj4gNykgfCB0MWggPDwgMjUpO1xuXG4gICAgICB0MWggPSBibG9ja3NbaiAtIDRdO1xuICAgICAgdDFsID0gYmxvY2tzW2ogLSAzXTtcbiAgICAgIHMxaCA9ICgodDFoID4+PiAxOSkgfCAodDFsIDw8IDEzKSkgXiAoKHQxbCA+Pj4gMjkpIHwgKHQxaCA8PCAzKSkgXiAodDFoID4+PiA2KTtcbiAgICAgIHMxbCA9ICgodDFsID4+PiAxOSkgfCAodDFoIDw8IDEzKSkgXiAoKHQxaCA+Pj4gMjkpIHwgKHQxbCA8PCAzKSkgXiAoKHQxbCA+Pj4gNikgfCB0MWggPDwgMjYpO1xuXG4gICAgICB0MWggPSBibG9ja3NbaiAtIDMyXTtcbiAgICAgIHQxbCA9IGJsb2Nrc1tqIC0gMzFdO1xuICAgICAgdDJoID0gYmxvY2tzW2ogLSAxNF07XG4gICAgICB0MmwgPSBibG9ja3NbaiAtIDEzXTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpICsgKHMwbCAmIDB4RkZGRikgKyAoczFsICYgMHhGRkZGKTtcbiAgICAgIGMyID0gKHQybCA+Pj4gMTYpICsgKHQxbCA+Pj4gMTYpICsgKHMwbCA+Pj4gMTYpICsgKHMxbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9ICh0MmggJiAweEZGRkYpICsgKHQxaCAmIDB4RkZGRikgKyAoczBoICYgMHhGRkZGKSArIChzMWggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgICBjNCA9ICh0MmggPj4+IDE2KSArICh0MWggPj4+IDE2KSArIChzMGggPj4+IDE2KSArIChzMWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICBibG9ja3Nbal0gPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIGJsb2Nrc1tqICsgMV0gPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcbiAgICB9XG5cbiAgICB2YXIgYWggPSBoMGgsIGFsID0gaDBsLCBiaCA9IGgxaCwgYmwgPSBoMWwsIGNoID0gaDJoLCBjbCA9IGgybCwgZGggPSBoM2gsIGRsID0gaDNsLCBlaCA9IGg0aCwgZWwgPSBoNGwsIGZoID0gaDVoLCBmbCA9IGg1bCwgZ2ggPSBoNmgsIGdsID0gaDZsLCBoaCA9IGg3aCwgaGwgPSBoN2w7XG4gICAgYmNoID0gYmggJiBjaDtcbiAgICBiY2wgPSBibCAmIGNsO1xuICAgIGZvciAoaiA9IDA7IGogPCAxNjA7IGogKz0gOCkge1xuICAgICAgczBoID0gKChhaCA+Pj4gMjgpIHwgKGFsIDw8IDQpKSBeICgoYWwgPj4+IDIpIHwgKGFoIDw8IDMwKSkgXiAoKGFsID4+PiA3KSB8IChhaCA8PCAyNSkpO1xuICAgICAgczBsID0gKChhbCA+Pj4gMjgpIHwgKGFoIDw8IDQpKSBeICgoYWggPj4+IDIpIHwgKGFsIDw8IDMwKSkgXiAoKGFoID4+PiA3KSB8IChhbCA8PCAyNSkpO1xuXG4gICAgICBzMWggPSAoKGVoID4+PiAxNCkgfCAoZWwgPDwgMTgpKSBeICgoZWggPj4+IDE4KSB8IChlbCA8PCAxNCkpIF4gKChlbCA+Pj4gOSkgfCAoZWggPDwgMjMpKTtcbiAgICAgIHMxbCA9ICgoZWwgPj4+IDE0KSB8IChlaCA8PCAxOCkpIF4gKChlbCA+Pj4gMTgpIHwgKGVoIDw8IDE0KSkgXiAoKGVoID4+PiA5KSB8IChlbCA8PCAyMykpO1xuXG4gICAgICBhYmggPSBhaCAmIGJoO1xuICAgICAgYWJsID0gYWwgJiBibDtcbiAgICAgIG1hamggPSBhYmggXiAoYWggJiBjaCkgXiBiY2g7XG4gICAgICBtYWpsID0gYWJsIF4gKGFsICYgY2wpIF4gYmNsO1xuXG4gICAgICBjaGggPSAoZWggJiBmaCkgXiAofmVoICYgZ2gpO1xuICAgICAgY2hsID0gKGVsICYgZmwpIF4gKH5lbCAmIGdsKTtcblxuICAgICAgdDFoID0gYmxvY2tzW2pdO1xuICAgICAgdDFsID0gYmxvY2tzW2ogKyAxXTtcbiAgICAgIHQyaCA9IEtbal07XG4gICAgICB0MmwgPSBLW2ogKyAxXTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpICsgKGNobCAmIDB4RkZGRikgKyAoczFsICYgMHhGRkZGKSArIChobCAmIDB4RkZGRik7XG4gICAgICBjMiA9ICh0MmwgPj4+IDE2KSArICh0MWwgPj4+IDE2KSArIChjaGwgPj4+IDE2KSArIChzMWwgPj4+IDE2KSArIChobCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9ICh0MmggJiAweEZGRkYpICsgKHQxaCAmIDB4RkZGRikgKyAoY2hoICYgMHhGRkZGKSArIChzMWggJiAweEZGRkYpICsgKGhoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoY2hoID4+PiAxNikgKyAoczFoID4+PiAxNikgKyAoaGggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICB0MWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIHQxbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgICBjMSA9IChtYWpsICYgMHhGRkZGKSArIChzMGwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAobWFqbCA+Pj4gMTYpICsgKHMwbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChtYWpoICYgMHhGRkZGKSArIChzMGggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgICBjNCA9IChtYWpoID4+PiAxNikgKyAoczBoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgdDJoID0gKGM0IDw8IDE2KSB8IChjMyAmIDB4RkZGRik7XG4gICAgICB0MmwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAoZGwgJiAweEZGRkYpICsgKHQxbCAmIDB4RkZGRik7XG4gICAgICBjMiA9IChkbCA+Pj4gMTYpICsgKHQxbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChkaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAoZGggPj4+IDE2KSArICh0MWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICBoaCA9IChjNCA8PCAxNikgfCAoYzMgJiAweEZGRkYpO1xuICAgICAgaGwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAodDJsID4+PiAxNikgKyAodDFsID4+PiAxNikgKyAoYzEgPj4+IDE2KTtcbiAgICAgIGMzID0gKHQyaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgZGggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIGRsID0gKGMyIDw8IDE2KSB8IChjMSAmIDB4RkZGRik7XG5cbiAgICAgIHMwaCA9ICgoZGggPj4+IDI4KSB8IChkbCA8PCA0KSkgXiAoKGRsID4+PiAyKSB8IChkaCA8PCAzMCkpIF4gKChkbCA+Pj4gNykgfCAoZGggPDwgMjUpKTtcbiAgICAgIHMwbCA9ICgoZGwgPj4+IDI4KSB8IChkaCA8PCA0KSkgXiAoKGRoID4+PiAyKSB8IChkbCA8PCAzMCkpIF4gKChkaCA+Pj4gNykgfCAoZGwgPDwgMjUpKTtcblxuICAgICAgczFoID0gKChoaCA+Pj4gMTQpIHwgKGhsIDw8IDE4KSkgXiAoKGhoID4+PiAxOCkgfCAoaGwgPDwgMTQpKSBeICgoaGwgPj4+IDkpIHwgKGhoIDw8IDIzKSk7XG4gICAgICBzMWwgPSAoKGhsID4+PiAxNCkgfCAoaGggPDwgMTgpKSBeICgoaGwgPj4+IDE4KSB8IChoaCA8PCAxNCkpIF4gKChoaCA+Pj4gOSkgfCAoaGwgPDwgMjMpKTtcblxuICAgICAgZGFoID0gZGggJiBhaDtcbiAgICAgIGRhbCA9IGRsICYgYWw7XG4gICAgICBtYWpoID0gZGFoIF4gKGRoICYgYmgpIF4gYWJoO1xuICAgICAgbWFqbCA9IGRhbCBeIChkbCAmIGJsKSBeIGFibDtcblxuICAgICAgY2hoID0gKGhoICYgZWgpIF4gKH5oaCAmIGZoKTtcbiAgICAgIGNobCA9IChobCAmIGVsKSBeICh+aGwgJiBmbCk7XG5cbiAgICAgIHQxaCA9IGJsb2Nrc1tqICsgMl07XG4gICAgICB0MWwgPSBibG9ja3NbaiArIDNdO1xuICAgICAgdDJoID0gS1tqICsgMl07XG4gICAgICB0MmwgPSBLW2ogKyAzXTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpICsgKGNobCAmIDB4RkZGRikgKyAoczFsICYgMHhGRkZGKSArIChnbCAmIDB4RkZGRik7XG4gICAgICBjMiA9ICh0MmwgPj4+IDE2KSArICh0MWwgPj4+IDE2KSArIChjaGwgPj4+IDE2KSArIChzMWwgPj4+IDE2KSArIChnbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9ICh0MmggJiAweEZGRkYpICsgKHQxaCAmIDB4RkZGRikgKyAoY2hoICYgMHhGRkZGKSArIChzMWggJiAweEZGRkYpICsgKGdoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoY2hoID4+PiAxNikgKyAoczFoID4+PiAxNikgKyAoZ2ggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICB0MWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIHQxbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgICBjMSA9IChtYWpsICYgMHhGRkZGKSArIChzMGwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAobWFqbCA+Pj4gMTYpICsgKHMwbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChtYWpoICYgMHhGRkZGKSArIChzMGggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgICBjNCA9IChtYWpoID4+PiAxNikgKyAoczBoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgdDJoID0gKGM0IDw8IDE2KSB8IChjMyAmIDB4RkZGRik7XG4gICAgICB0MmwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAoY2wgJiAweEZGRkYpICsgKHQxbCAmIDB4RkZGRik7XG4gICAgICBjMiA9IChjbCA+Pj4gMTYpICsgKHQxbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChjaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAoY2ggPj4+IDE2KSArICh0MWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICBnaCA9IChjNCA8PCAxNikgfCAoYzMgJiAweEZGRkYpO1xuICAgICAgZ2wgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAodDJsID4+PiAxNikgKyAodDFsID4+PiAxNikgKyAoYzEgPj4+IDE2KTtcbiAgICAgIGMzID0gKHQyaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgY2ggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIGNsID0gKGMyIDw8IDE2KSB8IChjMSAmIDB4RkZGRik7XG5cbiAgICAgIHMwaCA9ICgoY2ggPj4+IDI4KSB8IChjbCA8PCA0KSkgXiAoKGNsID4+PiAyKSB8IChjaCA8PCAzMCkpIF4gKChjbCA+Pj4gNykgfCAoY2ggPDwgMjUpKTtcbiAgICAgIHMwbCA9ICgoY2wgPj4+IDI4KSB8IChjaCA8PCA0KSkgXiAoKGNoID4+PiAyKSB8IChjbCA8PCAzMCkpIF4gKChjaCA+Pj4gNykgfCAoY2wgPDwgMjUpKTtcblxuICAgICAgczFoID0gKChnaCA+Pj4gMTQpIHwgKGdsIDw8IDE4KSkgXiAoKGdoID4+PiAxOCkgfCAoZ2wgPDwgMTQpKSBeICgoZ2wgPj4+IDkpIHwgKGdoIDw8IDIzKSk7XG4gICAgICBzMWwgPSAoKGdsID4+PiAxNCkgfCAoZ2ggPDwgMTgpKSBeICgoZ2wgPj4+IDE4KSB8IChnaCA8PCAxNCkpIF4gKChnaCA+Pj4gOSkgfCAoZ2wgPDwgMjMpKTtcblxuICAgICAgY2RoID0gY2ggJiBkaDtcbiAgICAgIGNkbCA9IGNsICYgZGw7XG4gICAgICBtYWpoID0gY2RoIF4gKGNoICYgYWgpIF4gZGFoO1xuICAgICAgbWFqbCA9IGNkbCBeIChjbCAmIGFsKSBeIGRhbDtcblxuICAgICAgY2hoID0gKGdoICYgaGgpIF4gKH5naCAmIGVoKTtcbiAgICAgIGNobCA9IChnbCAmIGhsKSBeICh+Z2wgJiBlbCk7XG5cbiAgICAgIHQxaCA9IGJsb2Nrc1tqICsgNF07XG4gICAgICB0MWwgPSBibG9ja3NbaiArIDVdO1xuICAgICAgdDJoID0gS1tqICsgNF07XG4gICAgICB0MmwgPSBLW2ogKyA1XTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpICsgKGNobCAmIDB4RkZGRikgKyAoczFsICYgMHhGRkZGKSArIChmbCAmIDB4RkZGRik7XG4gICAgICBjMiA9ICh0MmwgPj4+IDE2KSArICh0MWwgPj4+IDE2KSArIChjaGwgPj4+IDE2KSArIChzMWwgPj4+IDE2KSArIChmbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9ICh0MmggJiAweEZGRkYpICsgKHQxaCAmIDB4RkZGRikgKyAoY2hoICYgMHhGRkZGKSArIChzMWggJiAweEZGRkYpICsgKGZoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoY2hoID4+PiAxNikgKyAoczFoID4+PiAxNikgKyAoZmggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICB0MWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIHQxbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgICBjMSA9IChtYWpsICYgMHhGRkZGKSArIChzMGwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAobWFqbCA+Pj4gMTYpICsgKHMwbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChtYWpoICYgMHhGRkZGKSArIChzMGggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgICBjNCA9IChtYWpoID4+PiAxNikgKyAoczBoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgdDJoID0gKGM0IDw8IDE2KSB8IChjMyAmIDB4RkZGRik7XG4gICAgICB0MmwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAoYmwgJiAweEZGRkYpICsgKHQxbCAmIDB4RkZGRik7XG4gICAgICBjMiA9IChibCA+Pj4gMTYpICsgKHQxbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChiaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAoYmggPj4+IDE2KSArICh0MWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICBmaCA9IChjNCA8PCAxNikgfCAoYzMgJiAweEZGRkYpO1xuICAgICAgZmwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAodDJsID4+PiAxNikgKyAodDFsID4+PiAxNikgKyAoYzEgPj4+IDE2KTtcbiAgICAgIGMzID0gKHQyaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgYmggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIGJsID0gKGMyIDw8IDE2KSB8IChjMSAmIDB4RkZGRik7XG5cbiAgICAgIHMwaCA9ICgoYmggPj4+IDI4KSB8IChibCA8PCA0KSkgXiAoKGJsID4+PiAyKSB8IChiaCA8PCAzMCkpIF4gKChibCA+Pj4gNykgfCAoYmggPDwgMjUpKTtcbiAgICAgIHMwbCA9ICgoYmwgPj4+IDI4KSB8IChiaCA8PCA0KSkgXiAoKGJoID4+PiAyKSB8IChibCA8PCAzMCkpIF4gKChiaCA+Pj4gNykgfCAoYmwgPDwgMjUpKTtcblxuICAgICAgczFoID0gKChmaCA+Pj4gMTQpIHwgKGZsIDw8IDE4KSkgXiAoKGZoID4+PiAxOCkgfCAoZmwgPDwgMTQpKSBeICgoZmwgPj4+IDkpIHwgKGZoIDw8IDIzKSk7XG4gICAgICBzMWwgPSAoKGZsID4+PiAxNCkgfCAoZmggPDwgMTgpKSBeICgoZmwgPj4+IDE4KSB8IChmaCA8PCAxNCkpIF4gKChmaCA+Pj4gOSkgfCAoZmwgPDwgMjMpKTtcblxuICAgICAgYmNoID0gYmggJiBjaDtcbiAgICAgIGJjbCA9IGJsICYgY2w7XG4gICAgICBtYWpoID0gYmNoIF4gKGJoICYgZGgpIF4gY2RoO1xuICAgICAgbWFqbCA9IGJjbCBeIChibCAmIGRsKSBeIGNkbDtcblxuICAgICAgY2hoID0gKGZoICYgZ2gpIF4gKH5maCAmIGhoKTtcbiAgICAgIGNobCA9IChmbCAmIGdsKSBeICh+ZmwgJiBobCk7XG5cbiAgICAgIHQxaCA9IGJsb2Nrc1tqICsgNl07XG4gICAgICB0MWwgPSBibG9ja3NbaiArIDddO1xuICAgICAgdDJoID0gS1tqICsgNl07XG4gICAgICB0MmwgPSBLW2ogKyA3XTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpICsgKGNobCAmIDB4RkZGRikgKyAoczFsICYgMHhGRkZGKSArIChlbCAmIDB4RkZGRik7XG4gICAgICBjMiA9ICh0MmwgPj4+IDE2KSArICh0MWwgPj4+IDE2KSArIChjaGwgPj4+IDE2KSArIChzMWwgPj4+IDE2KSArIChlbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9ICh0MmggJiAweEZGRkYpICsgKHQxaCAmIDB4RkZGRikgKyAoY2hoICYgMHhGRkZGKSArIChzMWggJiAweEZGRkYpICsgKGVoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoY2hoID4+PiAxNikgKyAoczFoID4+PiAxNikgKyAoZWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICB0MWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIHQxbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgICBjMSA9IChtYWpsICYgMHhGRkZGKSArIChzMGwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAobWFqbCA+Pj4gMTYpICsgKHMwbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChtYWpoICYgMHhGRkZGKSArIChzMGggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgICBjNCA9IChtYWpoID4+PiAxNikgKyAoczBoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgdDJoID0gKGM0IDw8IDE2KSB8IChjMyAmIDB4RkZGRik7XG4gICAgICB0MmwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAoYWwgJiAweEZGRkYpICsgKHQxbCAmIDB4RkZGRik7XG4gICAgICBjMiA9IChhbCA+Pj4gMTYpICsgKHQxbCA+Pj4gMTYpICsgKGMxID4+PiAxNik7XG4gICAgICBjMyA9IChhaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAoYWggPj4+IDE2KSArICh0MWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgICBlaCA9IChjNCA8PCAxNikgfCAoYzMgJiAweEZGRkYpO1xuICAgICAgZWwgPSAoYzIgPDwgMTYpIHwgKGMxICYgMHhGRkZGKTtcblxuICAgICAgYzEgPSAodDJsICYgMHhGRkZGKSArICh0MWwgJiAweEZGRkYpO1xuICAgICAgYzIgPSAodDJsID4+PiAxNikgKyAodDFsID4+PiAxNikgKyAoYzEgPj4+IDE2KTtcbiAgICAgIGMzID0gKHQyaCAmIDB4RkZGRikgKyAodDFoICYgMHhGRkZGKSArIChjMiA+Pj4gMTYpO1xuICAgICAgYzQgPSAodDJoID4+PiAxNikgKyAodDFoID4+PiAxNikgKyAoYzMgPj4+IDE2KTtcblxuICAgICAgYWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICAgIGFsID0gKGMyIDw8IDE2KSB8IChjMSAmIDB4RkZGRik7XG4gICAgfVxuXG4gICAgYzEgPSAoaDBsICYgMHhGRkZGKSArIChhbCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDBsID4+PiAxNikgKyAoYWwgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGgwaCAmIDB4RkZGRikgKyAoYWggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDBoID4+PiAxNikgKyAoYWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oMGggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmgwbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDFsICYgMHhGRkZGKSArIChibCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDFsID4+PiAxNikgKyAoYmwgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGgxaCAmIDB4RkZGRikgKyAoYmggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDFoID4+PiAxNikgKyAoYmggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oMWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmgxbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDJsICYgMHhGRkZGKSArIChjbCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDJsID4+PiAxNikgKyAoY2wgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGgyaCAmIDB4RkZGRikgKyAoY2ggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDJoID4+PiAxNikgKyAoY2ggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oMmggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmgybCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDNsICYgMHhGRkZGKSArIChkbCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDNsID4+PiAxNikgKyAoZGwgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGgzaCAmIDB4RkZGRikgKyAoZGggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDNoID4+PiAxNikgKyAoZGggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oM2ggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmgzbCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDRsICYgMHhGRkZGKSArIChlbCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDRsID4+PiAxNikgKyAoZWwgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGg0aCAmIDB4RkZGRikgKyAoZWggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDRoID4+PiAxNikgKyAoZWggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oNGggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmg0bCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDVsICYgMHhGRkZGKSArIChmbCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDVsID4+PiAxNikgKyAoZmwgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGg1aCAmIDB4RkZGRikgKyAoZmggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDVoID4+PiAxNikgKyAoZmggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oNWggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmg1bCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDZsICYgMHhGRkZGKSArIChnbCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDZsID4+PiAxNikgKyAoZ2wgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGg2aCAmIDB4RkZGRikgKyAoZ2ggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDZoID4+PiAxNikgKyAoZ2ggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oNmggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmg2bCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuXG4gICAgYzEgPSAoaDdsICYgMHhGRkZGKSArIChobCAmIDB4RkZGRik7XG4gICAgYzIgPSAoaDdsID4+PiAxNikgKyAoaGwgPj4+IDE2KSArIChjMSA+Pj4gMTYpO1xuICAgIGMzID0gKGg3aCAmIDB4RkZGRikgKyAoaGggJiAweEZGRkYpICsgKGMyID4+PiAxNik7XG4gICAgYzQgPSAoaDdoID4+PiAxNikgKyAoaGggPj4+IDE2KSArIChjMyA+Pj4gMTYpO1xuXG4gICAgdGhpcy5oN2ggPSAoYzQgPDwgMTYpIHwgKGMzICYgMHhGRkZGKTtcbiAgICB0aGlzLmg3bCA9IChjMiA8PCAxNikgfCAoYzEgJiAweEZGRkYpO1xuICB9O1xuXG4gIFNoYTUxMi5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMGggPSB0aGlzLmgwaCwgaDBsID0gdGhpcy5oMGwsIGgxaCA9IHRoaXMuaDFoLCBoMWwgPSB0aGlzLmgxbCxcbiAgICAgIGgyaCA9IHRoaXMuaDJoLCBoMmwgPSB0aGlzLmgybCwgaDNoID0gdGhpcy5oM2gsIGgzbCA9IHRoaXMuaDNsLFxuICAgICAgaDRoID0gdGhpcy5oNGgsIGg0bCA9IHRoaXMuaDRsLCBoNWggPSB0aGlzLmg1aCwgaDVsID0gdGhpcy5oNWwsXG4gICAgICBoNmggPSB0aGlzLmg2aCwgaDZsID0gdGhpcy5oNmwsIGg3aCA9IHRoaXMuaDdoLCBoN2wgPSB0aGlzLmg3bCxcbiAgICAgIGJpdHMgPSB0aGlzLmJpdHM7XG5cbiAgICB2YXIgaGV4ID0gSEVYX0NIQVJTWyhoMGggPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwaCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwaCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDBoID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDBoID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMGggPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwaCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gwaCAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDBsID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMGwgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMGwgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwbCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwbCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDBsID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMGwgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMGwgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxaCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDFoID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDFoID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMWggPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMWggPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxaCA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDFoID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDFoICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMWwgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxbCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxbCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDFsID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDFsID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMWwgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxbCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gxbCAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDJoID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMmggPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMmggPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyaCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyaCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDJoID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMmggPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMmggJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgybCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDJsID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDJsID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMmwgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMmwgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgybCA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDJsID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDJsICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoM2ggPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzaCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzaCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDNoID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDNoID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoM2ggPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzaCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gzaCAmIDB4MEZdO1xuICAgIGlmIChiaXRzID49IDI1Nikge1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soaDNsID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoM2wgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzbCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDNsID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoM2wgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzbCA+PiA4KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoM2wgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toM2wgJiAweDBGXTtcbiAgICB9XG4gICAgaWYgKGJpdHMgPj0gMzg0KSB7XG4gICAgICBoZXggKz0gSEVYX0NIQVJTWyhoNGggPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg0aCA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDRoID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNGggPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0aCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDRoID4+IDgpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0aCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g0aCAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNGwgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg0bCA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDRsID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNGwgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0bCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDRsID4+IDgpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0bCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g0bCAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNWggPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1aCA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDVoID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNWggPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1aCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDVoID4+IDgpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1aCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g1aCAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNWwgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1bCA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDVsID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNWwgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1bCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDVsID4+IDgpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1bCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g1bCAmIDB4MEZdO1xuICAgIH1cbiAgICBpZiAoYml0cyA9PSA1MTIpIHtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGg2aCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDZoID4+IDI0KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNmggPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2aCA+PiAxNikgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDZoID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNmggPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDZoID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDZoICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2bCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDZsID4+IDI0KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNmwgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2bCA+PiAxNikgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDZsID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNmwgPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDZsID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDZsICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3aCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDdoID4+IDI0KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoN2ggPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3aCA+PiAxNikgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDdoID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoN2ggPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDdoID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDdoICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3bCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDdsID4+IDI0KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoN2wgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3bCA+PiAxNikgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDdsID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoN2wgPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDdsID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDdsICYgMHgwRl07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH07XG5cbiAgU2hhNTEyLnByb3RvdHlwZS50b1N0cmluZyA9IFNoYTUxMi5wcm90b3R5cGUuaGV4O1xuXG4gIFNoYTUxMi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMGggPSB0aGlzLmgwaCwgaDBsID0gdGhpcy5oMGwsIGgxaCA9IHRoaXMuaDFoLCBoMWwgPSB0aGlzLmgxbCxcbiAgICAgIGgyaCA9IHRoaXMuaDJoLCBoMmwgPSB0aGlzLmgybCwgaDNoID0gdGhpcy5oM2gsIGgzbCA9IHRoaXMuaDNsLFxuICAgICAgaDRoID0gdGhpcy5oNGgsIGg0bCA9IHRoaXMuaDRsLCBoNWggPSB0aGlzLmg1aCwgaDVsID0gdGhpcy5oNWwsXG4gICAgICBoNmggPSB0aGlzLmg2aCwgaDZsID0gdGhpcy5oNmwsIGg3aCA9IHRoaXMuaDdoLCBoN2wgPSB0aGlzLmg3bCxcbiAgICAgIGJpdHMgPSB0aGlzLmJpdHM7XG5cbiAgICB2YXIgYXJyID0gW1xuICAgICAgKGgwaCA+PiAyNCkgJiAweEZGLCAoaDBoID4+IDE2KSAmIDB4RkYsIChoMGggPj4gOCkgJiAweEZGLCBoMGggJiAweEZGLFxuICAgICAgKGgwbCA+PiAyNCkgJiAweEZGLCAoaDBsID4+IDE2KSAmIDB4RkYsIChoMGwgPj4gOCkgJiAweEZGLCBoMGwgJiAweEZGLFxuICAgICAgKGgxaCA+PiAyNCkgJiAweEZGLCAoaDFoID4+IDE2KSAmIDB4RkYsIChoMWggPj4gOCkgJiAweEZGLCBoMWggJiAweEZGLFxuICAgICAgKGgxbCA+PiAyNCkgJiAweEZGLCAoaDFsID4+IDE2KSAmIDB4RkYsIChoMWwgPj4gOCkgJiAweEZGLCBoMWwgJiAweEZGLFxuICAgICAgKGgyaCA+PiAyNCkgJiAweEZGLCAoaDJoID4+IDE2KSAmIDB4RkYsIChoMmggPj4gOCkgJiAweEZGLCBoMmggJiAweEZGLFxuICAgICAgKGgybCA+PiAyNCkgJiAweEZGLCAoaDJsID4+IDE2KSAmIDB4RkYsIChoMmwgPj4gOCkgJiAweEZGLCBoMmwgJiAweEZGLFxuICAgICAgKGgzaCA+PiAyNCkgJiAweEZGLCAoaDNoID4+IDE2KSAmIDB4RkYsIChoM2ggPj4gOCkgJiAweEZGLCBoM2ggJiAweEZGXG4gICAgXTtcblxuICAgIGlmIChiaXRzID49IDI1Nikge1xuICAgICAgYXJyLnB1c2goKGgzbCA+PiAyNCkgJiAweEZGLCAoaDNsID4+IDE2KSAmIDB4RkYsIChoM2wgPj4gOCkgJiAweEZGLCBoM2wgJiAweEZGKTtcbiAgICB9XG4gICAgaWYgKGJpdHMgPj0gMzg0KSB7XG4gICAgICBhcnIucHVzaChcbiAgICAgICAgKGg0aCA+PiAyNCkgJiAweEZGLCAoaDRoID4+IDE2KSAmIDB4RkYsIChoNGggPj4gOCkgJiAweEZGLCBoNGggJiAweEZGLFxuICAgICAgICAoaDRsID4+IDI0KSAmIDB4RkYsIChoNGwgPj4gMTYpICYgMHhGRiwgKGg0bCA+PiA4KSAmIDB4RkYsIGg0bCAmIDB4RkYsXG4gICAgICAgIChoNWggPj4gMjQpICYgMHhGRiwgKGg1aCA+PiAxNikgJiAweEZGLCAoaDVoID4+IDgpICYgMHhGRiwgaDVoICYgMHhGRixcbiAgICAgICAgKGg1bCA+PiAyNCkgJiAweEZGLCAoaDVsID4+IDE2KSAmIDB4RkYsIChoNWwgPj4gOCkgJiAweEZGLCBoNWwgJiAweEZGXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYml0cyA9PSA1MTIpIHtcbiAgICAgIGFyci5wdXNoKFxuICAgICAgICAoaDZoID4+IDI0KSAmIDB4RkYsIChoNmggPj4gMTYpICYgMHhGRiwgKGg2aCA+PiA4KSAmIDB4RkYsIGg2aCAmIDB4RkYsXG4gICAgICAgIChoNmwgPj4gMjQpICYgMHhGRiwgKGg2bCA+PiAxNikgJiAweEZGLCAoaDZsID4+IDgpICYgMHhGRiwgaDZsICYgMHhGRixcbiAgICAgICAgKGg3aCA+PiAyNCkgJiAweEZGLCAoaDdoID4+IDE2KSAmIDB4RkYsIChoN2ggPj4gOCkgJiAweEZGLCBoN2ggJiAweEZGLFxuICAgICAgICAoaDdsID4+IDI0KSAmIDB4RkYsIChoN2wgPj4gMTYpICYgMHhGRiwgKGg3bCA+PiA4KSAmIDB4RkYsIGg3bCAmIDB4RkZcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07XG5cbiAgU2hhNTEyLnByb3RvdHlwZS5hcnJheSA9IFNoYTUxMi5wcm90b3R5cGUuZGlnZXN0O1xuXG4gIFNoYTUxMi5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihiaXRzIC8gOCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDAsIHRoaXMuaDBoKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMGwpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgxaCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDEyLCB0aGlzLmgxbCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmgyaCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDIwLCB0aGlzLmgybCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDI0LCB0aGlzLmgzaCk7XG5cbiAgICBpZiAoYml0cyA+PSAyNTYpIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMigyOCwgdGhpcy5oM2wpO1xuICAgIH1cbiAgICBpZiAoYml0cyA+PSAzODQpIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMigzMiwgdGhpcy5oNGgpO1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKDM2LCB0aGlzLmg0bCk7XG4gICAgICBkYXRhVmlldy5zZXRVaW50MzIoNDAsIHRoaXMuaDVoKTtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMig0NCwgdGhpcy5oNWwpO1xuICAgIH1cbiAgICBpZiAoYml0cyA9PSA1MTIpIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMig0OCwgdGhpcy5oNmgpO1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKDUyLCB0aGlzLmg2bCk7XG4gICAgICBkYXRhVmlldy5zZXRVaW50MzIoNTYsIHRoaXMuaDdoKTtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMig2MCwgdGhpcy5oN2wpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFNoYTUxMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgU2hhNTEyKHRoaXMuYml0cywgZmFsc2UpO1xuICAgIHRoaXMuY29weVRvKGhhc2gpO1xuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIFNoYTUxMi5wcm90b3R5cGUuY29weVRvID0gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICB2YXIgaSA9IDAsIGF0dHJzID0gW1xuICAgICAgJ2gwaCcsICdoMGwnLCAnaDFoJywgJ2gxbCcsICdoMmgnLCAnaDJsJywgJ2gzaCcsICdoM2wnLCAnaDRoJywgJ2g0bCcsICdoNWgnLCAnaDVsJywgJ2g2aCcsICdoNmwnLCAnaDdoJywgJ2g3bCcsXG4gICAgICAnc3RhcnQnLCAnYnl0ZXMnLCAnaEJ5dGVzJywgJ2ZpbmFsaXplZCcsICdoYXNoZWQnLCAnbGFzdEJ5dGVJbmRleCdcbiAgICBdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgICAgaGFzaFthdHRyc1tpXV0gPSB0aGlzW2F0dHJzW2ldXTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICBoYXNoLmJsb2Nrc1tpXSA9IHRoaXMuYmxvY2tzW2ldO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIbWFjU2hhNTEyKGtleSwgYml0cywgc2hhcmVkTWVtb3J5KSB7XG4gICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBrZXk7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIGtleS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBrZXkgPSBuZXcgVWludDhBcnJheShrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGtleS5sZW5ndGg7XG4gICAgaWYgKCFub3RTdHJpbmcpIHtcbiAgICAgIHZhciBieXRlcyA9IFtdLCBsZW5ndGggPSBrZXkubGVuZ3RoLCBpbmRleCA9IDAsIGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4YzAgfCAoY29kZSA+PiA2KSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweGUwIHwgKGNvZGUgPj4gMTIpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXkgPSBieXRlcztcbiAgICB9XG5cbiAgICBpZiAoa2V5Lmxlbmd0aCA+IDEyOCkge1xuICAgICAga2V5ID0gKG5ldyBTaGE1MTIoYml0cywgdHJ1ZSkpLnVwZGF0ZShrZXkpLmFycmF5KCk7XG4gICAgfVxuXG4gICAgdmFyIG9LZXlQYWQgPSBbXSwgaUtleVBhZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI4OyArK2kpIHtcbiAgICAgIHZhciBiID0ga2V5W2ldIHx8IDA7XG4gICAgICBvS2V5UGFkW2ldID0gMHg1YyBeIGI7XG4gICAgICBpS2V5UGFkW2ldID0gMHgzNiBeIGI7XG4gICAgfVxuXG4gICAgU2hhNTEyLmNhbGwodGhpcywgYml0cywgc2hhcmVkTWVtb3J5KTtcblxuICAgIHRoaXMudXBkYXRlKGlLZXlQYWQpO1xuICAgIHRoaXMub0tleVBhZCA9IG9LZXlQYWQ7XG4gICAgdGhpcy5pbm5lciA9IHRydWU7XG4gICAgdGhpcy5zaGFyZWRNZW1vcnkgPSBzaGFyZWRNZW1vcnk7XG4gIH1cbiAgSG1hY1NoYTUxMi5wcm90b3R5cGUgPSBuZXcgU2hhNTEyKCk7XG5cbiAgSG1hY1NoYTUxMi5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgU2hhNTEyLnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICB0aGlzLmlubmVyID0gZmFsc2U7XG4gICAgICB2YXIgaW5uZXJIYXNoID0gdGhpcy5hcnJheSgpO1xuICAgICAgU2hhNTEyLmNhbGwodGhpcywgdGhpcy5iaXRzLCB0aGlzLnNoYXJlZE1lbW9yeSk7XG4gICAgICB0aGlzLnVwZGF0ZSh0aGlzLm9LZXlQYWQpO1xuICAgICAgdGhpcy51cGRhdGUoaW5uZXJIYXNoKTtcbiAgICAgIFNoYTUxMi5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgSG1hY1NoYTUxMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgSG1hY1NoYTUxMihbXSwgdGhpcy5iaXRzLCBmYWxzZSk7XG4gICAgdGhpcy5jb3B5VG8oaGFzaCk7XG4gICAgaGFzaC5pbm5lciA9IHRoaXMuaW5uZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9LZXlQYWQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGhhc2gub0tleVBhZFtpXSA9IHRoaXMub0tleVBhZFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSBjcmVhdGVNZXRob2QoNTEyKTtcbiAgZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzO1xuICBleHBvcnRzLnNoYTM4NCA9IGNyZWF0ZU1ldGhvZCgzODQpO1xuICBleHBvcnRzLnNoYTUxMl8yNTYgPSBjcmVhdGVNZXRob2QoMjU2KTtcbiAgZXhwb3J0cy5zaGE1MTJfMjI0ID0gY3JlYXRlTWV0aG9kKDIyNCk7XG4gIGV4cG9ydHMuc2hhNTEyLmhtYWMgPSBjcmVhdGVIbWFjTWV0aG9kKDUxMik7XG4gIGV4cG9ydHMuc2hhMzg0LmhtYWMgPSBjcmVhdGVIbWFjTWV0aG9kKDM4NCk7XG4gIGV4cG9ydHMuc2hhNTEyXzI1Ni5obWFjID0gY3JlYXRlSG1hY01ldGhvZCgyNTYpO1xuICBleHBvcnRzLnNoYTUxMl8yMjQuaG1hYyA9IGNyZWF0ZUhtYWNNZXRob2QoMjI0KTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc2hhNTEyID0gZXhwb3J0cy5zaGE1MTI7XG4gICAgcm9vdC5zaGEzODQgPSBleHBvcnRzLnNoYTM4NDtcbiAgICByb290LnNoYTUxMl8yNTYgPSBleHBvcnRzLnNoYTUxMl8yNTY7XG4gICAgcm9vdC5zaGE1MTJfMjI0ID0gZXhwb3J0cy5zaGE1MTJfMjI0O1xuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1widXNlXCIsIFwib25cIiwgXCJvbmNlXCIsIFwic2V0XCIsIFwicXVlcnlcIiwgXCJ0eXBlXCIsIFwiYWNjZXB0XCIsIFwiYXV0aFwiLCBcIndpdGhDcmVkZW50aWFsc1wiLCBcInNvcnRRdWVyeVwiLCBcInJldHJ5XCIsIFwib2tcIiwgXCJyZWRpcmVjdHNcIixcbiBcInRpbWVvdXRcIiwgXCJidWZmZXJcIiwgXCJzZXJpYWxpemVcIiwgXCJwYXJzZVwiLCBcImNhXCIsIFwia2V5XCIsIFwicGZ4XCIsIFwiY2VydFwiXS5mb3JFYWNoKGZuID0+IHtcbiAgLyoqIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudCAqL1xuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHRoaXMuX2RlZmF1bHRzLnB1c2goe2ZuLCBhcmdzfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5BZ2VudC5wcm90b3R5cGUuX3NldERlZmF1bHRzID0gZnVuY3Rpb24ocmVxKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMuZm9yRWFjaChkZWYgPT4ge1xuICAgICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBkZWYuYXJncyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50O1xuIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG5sZXQgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxuY29uc3QgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5jb25zdCBSZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5jb25zdCBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudC1iYXNlJyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbmNvbnN0IHJlcXVlc3QgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufTtcblxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gKCkgPT4ge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICAgJiYgKCFyb290LmxvY2F0aW9uIHx8ICdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbFxuICAgICAgICAgIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgfSBlbHNlIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICB9XG4gIHRocm93IEVycm9yKFwiQnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBjb3VsZCBub3QgZmluZCBYSFJcIik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgdHJpbSA9ICcnLnRyaW1cbiAgPyBzID0+IHMudHJpbSgpXG4gIDogcyA9PiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpO1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIGNvbnN0IHBhaXJzID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGZvcihjb25zdCBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBgJHtrZXl9WyR7c3Via2V5fV1gLCB2YWxbc3Via2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICBsZXQgcGFpcjtcbiAgbGV0IHBvcztcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAndGV4dC94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcbn07XG5cbi8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGNvbnN0IGZpZWxkcyA9IHt9O1xuICBsZXQgaW5kZXg7XG4gIGxldCBsaW5lO1xuICBsZXQgZmllbGQ7XG4gIGxldCB2YWw7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgeyAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgbGV0IHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgc3RhdHVzID0gMjA0O1xuICB9XG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAobnVsbCA9PT0gdGhpcy50ZXh0ICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuUmVzcG9uc2VCYXNlKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3BhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cikge1xuICBsZXQgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHJlcSA9IHRoaXMucmVxO1xuICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kO1xuICBjb25zdCB1cmwgPSByZXEudXJsO1xuXG4gIGNvbnN0IG1zZyA9IGBjYW5ub3QgJHttZXRob2R9ICR7dXJsfSAoJHt0aGlzLnN0YXR1c30pYDtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1BhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlJyk7XG4gICAgICBlcnIucGFyc2UgPSB0cnVlO1xuICAgICAgZXJyLm9yaWdpbmFsID0gZTtcbiAgICAgIC8vIGlzc3VlICM2NzU6IHJldHVybiB0aGUgcmF3IHJlc3BvbnNlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgLy8gaWU5IGRvZXNuJ3QgaGF2ZSAncmVzcG9uc2UnIHByb3BlcnR5XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT0gJ3VuZGVmaW5lZCcgPyBzZWxmLnhoci5yZXNwb25zZVRleHQgOiBzZWxmLnhoci5yZXNwb25zZTtcbiAgICAgICAgLy8gaXNzdWUgIzg3NjogcmV0dXJuIHRoZSBodHRwIHN0YXR1cyBjb2RlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICBsZXQgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goY3VzdG9tX2Vycikge1xuICAgICAgbmV3X2VyciA9IGN1c3RvbV9lcnI7IC8vIG9rKCkgY2FsbGJhY2sgY2FuIHRocm93XG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIG5ld19lcnIub3JpZ2luYWwgPSBlcnI7XG4gICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgc2VsZi5jYWxsYmFjayhuZXdfZXJyLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5SZXF1ZXN0QmFzZShSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXNzXSBvcHRpb25hbCBpbiBjYXNlIG9mIHVzaW5nICdiZWFyZXInIGFzIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGggJ3R5cGUnIHByb3BlcnR5ICdhdXRvJywgJ2Jhc2ljJyBvciAnYmVhcmVyJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHBhc3MgPSAnJztcbiAgaWYgKHR5cGVvZiBwYXNzID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7IC8vIHBhc3MgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZXBsYWNlZCB3aXRoIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgICBwYXNzID0gJyc7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hID8gJ2Jhc2ljJyA6ICdhdXRvJyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZW5jb2RlciA9IHN0cmluZyA9PiB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcblxuLyoqXG4gKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4gKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiAqICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIG9wdGlvbnMpe1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICBjb25zdCBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyLnJldHJpZXMgPSB0aGlzLl9yZXRyaWVzIC0gMTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24oKXtcbiAgY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSAoKSA9PiB7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIik7XG4gIH1cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHRoaXMuX2VuZCgpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fYWJvcnRlZCkgcmV0dXJuIHRoaXMuY2FsbGJhY2soRXJyb3IoXCJUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGV2ZW4gYmVmb3JlIC5lbmQoKSB3YXMgY2FsbGVkXCIpKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgeGhyID0gKHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKSk7XG4gIGxldCBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyICYmIHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICBpZiAoNCAhPSByZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIGxldCBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICBjb25zdCBoYW5kbGVQcm9ncmVzcyA9IChkaXJlY3Rpb24sIGUpID0+IHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gc2VlICMxMTQ5XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmICdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgY29uc3QgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGxldCBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yIChjb25zdCBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmIChudWxsID09IHRoaXMuaGVhZGVyW2ZpZWxkXSkgY29udGludWU7XG5cbiAgICBpZiAodGhpcy5oZWFkZXIuaGFzT3duUHJvcGVydHkoZmllbGQpKVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xufTtcblxucmVxdWVzdC5hZ2VudCA9ICgpID0+IG5ldyBBZ2VudCgpO1xuXG5bXCJHRVRcIiwgXCJQT1NUXCIsIFwiT1BUSU9OU1wiLCBcIlBBVENIXCIsIFwiUFVUXCIsIFwiREVMRVRFXCJdLmZvckVhY2gobWV0aG9kID0+IHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgZm4pIHtcbiAgICBjb25zdCByZXEgPSBuZXcgcmVxdWVzdC5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB0aGlzLl9zZXREZWZhdWx0cyhyZXEpO1xuICAgIGlmIChmbikge1xuICAgICAgcmVxLmVuZChmbik7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLmRlbCA9IEFnZW50LnByb3RvdHlwZVsnZGVsZXRlJ107XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSAodXJsLCBkYXRhLCBmbikgPT4ge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSAodXJsLCBkYXRhLCBmbikgPT4ge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGRhdGEsIGZuKSB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufVxuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0QmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0QmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBSZXF1ZXN0QmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKXtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqXG4gKiBWYWx1ZSBvZiAwIG9yIGZhbHNlIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBtcyBvciB7cmVzcG9uc2UsIGRlYWRsaW5lfVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2gob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHRpbWVvdXQgb3B0aW9uXCIsIG9wdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIG9uIGVycm9yLlxuICpcbiAqIEZhaWxlZCByZXF1ZXN0cyB3aWxsIGJlIHJldHJpZWQgJ2NvdW50JyB0aW1lcyBpZiB0aW1lb3V0IG9yIGVyci5jb2RlID49IDUwMC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbiByZXRyeShjb3VudCwgZm4pe1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgdGhpcy5fcmV0cnlDYWxsYmFjayA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmNvbnN0IEVSUk9SX0NPREVTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUFERFJJTkZPJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCdcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChCb3Jyb3dlZCBmcm9tIHNlZ21lbnRpby9zdXBlcmFnZW50LXJldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlID0gdGhpcy5fcmV0cnlDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gdW5kZWZpbmVkIGZhbGxzIGJhY2sgdG8gZGVmYXVsdHNcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXMgJiYgcmVzLnN0YXR1cyAmJiByZXMuc3RhdHVzID49IDUwMCAmJiByZXMuc3RhdHVzICE9IDUwMSkgcmV0dXJuIHRydWU7XG4gIGlmIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgJiYgfkVSUk9SX0NPREVTLmluZGV4T2YoZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTdXBlcmFnZW50IHRpbWVvdXRcbiAgICBpZiAoZXJyLnRpbWVvdXQgJiYgZXJyLmNvZGUgPT0gJ0VDT05OQUJPUlRFRCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIuY3Jvc3NEb21haW4pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cnkgcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgLy8gbm9kZVxuICBpZiAodGhpcy5yZXEpIHtcbiAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgdGhpcy5yZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aW1lZG91dCA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSA9PiB7XG4gICAgICBzZWxmLm9uKCdlcnJvcicsIGlubmVyUmVqZWN0KTtcbiAgICAgIHNlbGYub24oJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgICAgZXJyLmNvZGUgPSBcIkFCT1JURURcIjtcbiAgICAgICAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gICAgICAgIGVyci51cmwgPSB0aGlzLnVybDtcbiAgICAgICAgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5lbmQoKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIGlubmVyUmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24oY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYikgdGhyb3cgRXJyb3IoXCJDYWxsYmFjayByZXF1aXJlZFwiKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24ocmVzKSB7XG4gIGlmICghcmVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX29rQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fb2tDYWxsYmFjayhyZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDA7XG59O1xuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIGBmaWVsZGAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgZGVwcmVjYXRlZCBpbnRlcm5hbCBBUEkuIFVzZSBgLmdldChmaWVsZClgIGluc3RlYWQuXG4gKlxuICogKGdldEhlYWRlciBpcyBubyBsb25nZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzdXBlcmFnZW50IGNvZGUgYmFzZSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWwpe1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3RcbiAqIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCh7IGZvbzogJ2JhcicsIGJhejogJ3F1eCcgfSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobnVsbCA9PT0gbmFtZSB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWUpIHtcbiAgICAgIHRoaXMuZmllbGQoa2V5LCBuYW1lW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdmFsKSB7XG4gICAgICB0aGlzLmZpZWxkKG5hbWUsIHZhbFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWwpIHtcbiAgICB2YWwgPSAnJyArIHZhbDtcbiAgfVxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmFzaWMgJHtiYXNlNjRFbmNvZGVyKGAke3VzZXJ9OiR7cGFzc31gKX1gKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dXNlcn1gKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24ob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXhpbXVtIHNpemUgb2YgYnVmZmVyZWQgcmVzcG9uc2UgYm9keSwgaW4gYnl0ZXMuIENvdW50cyB1bmNvbXByZXNzZWQgc2l6ZS5cbiAqIERlZmF1bHQgMjAwTUIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24obil7XG4gIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIG4pIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICB9XG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXIsXG4gIH07XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIGNvbnN0IGlzT2JqID0gaXNPYmplY3QoZGF0YSk7XG4gIGxldCB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBtZXJnZSB0aGVzZSBzZW5kIGNhbGxzXCIpO1xuICB9XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKGlzT2JqICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyBgJHt0aGlzLl9kYXRhfSYke2RhdGF9YFxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbihzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICBjb25zdCBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gKHRoaXMudXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArIHF1ZXJ5O1xuICB9XG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBxdWVyeUFyciA9IHRoaXMudXJsLnN1YnN0cmluZyhpbmRleCArIDEpLnNwbGl0KCcmJyk7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX3NvcnQpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSAoKSA9PiB7Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkXCIpO31cblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCB0aW1lb3V0LCBlcnJubyl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgJHtyZWFzb24gKyB0aW1lb3V0fW1zIGV4Y2VlZGVkYCk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZGVhZGxpbmVcbiAgaWYgKHRoaXMuX3RpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignVGltZW91dCBvZiAnLCBzZWxmLl90aW1lb3V0LCAnRVRJTUUnKTtcbiAgICB9LCB0aGlzLl90aW1lb3V0KTtcbiAgfVxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZUJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzcG9uc2VCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlQmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZUJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVzcG9uc2VCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVzcG9uc2VCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gICAgLy8gVE9ETzogbW9hciFcbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG5cbiAgICAvLyBjb250ZW50LXR5cGVcbiAgICBjb25zdCBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgdGhpcy50eXBlID0gdXRpbHMudHlwZShjdCk7XG5cbiAgICAvLyBwYXJhbXNcbiAgICBjb25zdCBwYXJhbXMgPSB1dGlscy5wYXJhbXMoY3QpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG5cbiAgICB0aGlzLmxpbmtzID0ge307XG5cbiAgICAvLyBsaW5rc1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gICAgY29uc3QgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgICAvLyBzdGF0dXMgLyBjbGFzc1xuICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgICAvLyBiYXNpY3NcbiAgICB0aGlzLmluZm8gPSAxID09IHR5cGU7XG4gICAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgICB0aGlzLnJlZGlyZWN0ID0gMyA9PSB0eXBlO1xuICAgIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XG4gICAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgICAgID8gdGhpcy50b0Vycm9yKClcbiAgICAgICAgOiBmYWxzZTtcblxuICAgIC8vIHN1Z2FyXG4gICAgdGhpcy5jcmVhdGVkID0gMjAxID09IHN0YXR1cztcbiAgICB0aGlzLmFjY2VwdGVkID0gMjAyID09IHN0YXR1cztcbiAgICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gICAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgICB0aGlzLnVuYXV0aG9yaXplZCA9IDQwMSA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgICB0aGlzLmZvcmJpZGRlbiA9IDQwMyA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5ID0gNDIyID09IHN0YXR1cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyYW1zID0gc3RyID0+IHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoKG9iaiwgc3RyKSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KC8gKj0gKi8pO1xuICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICBjb25zdCB2YWwgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gc3RyID0+IHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoKG9iaiwgc3RyKSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KC8gKjsgKi8pO1xuICBjb25zdCB1cmwgPSBwYXJ0c1swXS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHJlbCA9IHBhcnRzWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsIC0xKTtcbiAgb2JqW3JlbF0gPSB1cmw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogU3RyaXAgY29udGVudCByZWxhdGVkIGZpZWxkcyBmcm9tIGBoZWFkZXJgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmNsZWFuSGVhZGVyID0gKGhlYWRlciwgY2hhbmdlc09yaWdpbikgPT4ge1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlclsnaG9zdCddO1xuICAvLyBzZWN1aXJ0eVxuICBpZiAoY2hhbmdlc09yaWdpbikge1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgaGVhZGVyWydjb29raWUnXTtcbiAgfVxuICByZXR1cm4gaGVhZGVyO1xufTtcbiIsIihmdW5jdGlvbihuYWNsKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFBvcnRlZCBpbiAyMDE0IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIFR3ZWV0TmFDbCB2ZXJzaW9uIDIwMTQwNDI3LlxuLy8gU2VlIGZvciBkZXRhaWxzOiBodHRwOi8vdHdlZXRuYWNsLmNyLnlwLnRvL1xuXG52YXIgZ2YgPSBmdW5jdGlvbihpbml0KSB7XG4gIHZhciBpLCByID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gIGlmIChpbml0KSBmb3IgKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKykgcltpXSA9IGluaXRbaV07XG4gIHJldHVybiByO1xufTtcblxuLy8gIFBsdWdnYWJsZSwgaW5pdGlhbGl6ZWQgaW4gaGlnaC1sZXZlbCBBUEkgYmVsb3cuXG52YXIgcmFuZG9tYnl0ZXMgPSBmdW5jdGlvbigvKiB4LCBuICovKSB7IHRocm93IG5ldyBFcnJvcignbm8gUFJORycpOyB9O1xuXG52YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG52YXIgXzkgPSBuZXcgVWludDhBcnJheSgzMik7IF85WzBdID0gOTtcblxudmFyIGdmMCA9IGdmKCksXG4gICAgZ2YxID0gZ2YoWzFdKSxcbiAgICBfMTIxNjY1ID0gZ2YoWzB4ZGI0MSwgMV0pLFxuICAgIEQgPSBnZihbMHg3OGEzLCAweDEzNTksIDB4NGRjYSwgMHg3NWViLCAweGQ4YWIsIDB4NDE0MSwgMHgwYTRkLCAweDAwNzAsIDB4ZTg5OCwgMHg3Nzc5LCAweDQwNzksIDB4OGNjNywgMHhmZTczLCAweDJiNmYsIDB4NmNlZSwgMHg1MjAzXSksXG4gICAgRDIgPSBnZihbMHhmMTU5LCAweDI2YjIsIDB4OWI5NCwgMHhlYmQ2LCAweGIxNTYsIDB4ODI4MywgMHgxNDlhLCAweDAwZTAsIDB4ZDEzMCwgMHhlZWYzLCAweDgwZjIsIDB4MTk4ZSwgMHhmY2U3LCAweDU2ZGYsIDB4ZDlkYywgMHgyNDA2XSksXG4gICAgWCA9IGdmKFsweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYywgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKSxcbiAgICBZID0gZ2YoWzB4NjY1OCwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2Nl0pLFxuICAgIEkgPSBnZihbMHhhMGIwLCAweDRhMGUsIDB4MWIyNywgMHhjNGVlLCAweGU0NzgsIDB4YWQyZiwgMHgxODA2LCAweDJmNDMsIDB4ZDdhNywgMHgzZGZiLCAweDAwOTksIDB4MmI0ZCwgMHhkZjBiLCAweDRmYzEsIDB4MjQ4MCwgMHgyYjgzXSk7XG5cbmZ1bmN0aW9uIHRzNjQoeCwgaSwgaCwgbCkge1xuICB4W2ldICAgPSAoaCA+PiAyNCkgJiAweGZmO1xuICB4W2krMV0gPSAoaCA+PiAxNikgJiAweGZmO1xuICB4W2krMl0gPSAoaCA+PiAgOCkgJiAweGZmO1xuICB4W2krM10gPSBoICYgMHhmZjtcbiAgeFtpKzRdID0gKGwgPj4gMjQpICAmIDB4ZmY7XG4gIHhbaSs1XSA9IChsID4+IDE2KSAgJiAweGZmO1xuICB4W2krNl0gPSAobCA+PiAgOCkgICYgMHhmZjtcbiAgeFtpKzddID0gbCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIHZuKHgsIHhpLCB5LCB5aSwgbikge1xuICB2YXIgaSxkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZCB8PSB4W3hpK2ldXnlbeWkraV07XG4gIHJldHVybiAoMSAmICgoZCAtIDEpID4+PiA4KSkgLSAxO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDE2KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwzMik7XG59XG5cbmZ1bmN0aW9uIGNvcmVfc2Fsc2EyMChvLCBwLCBrLCBjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG4gICB4MCA9ICB4MCArICBqMCB8IDA7XG4gICB4MSA9ICB4MSArICBqMSB8IDA7XG4gICB4MiA9ICB4MiArICBqMiB8IDA7XG4gICB4MyA9ICB4MyArICBqMyB8IDA7XG4gICB4NCA9ICB4NCArICBqNCB8IDA7XG4gICB4NSA9ICB4NSArICBqNSB8IDA7XG4gICB4NiA9ICB4NiArICBqNiB8IDA7XG4gICB4NyA9ICB4NyArICBqNyB8IDA7XG4gICB4OCA9ICB4OCArICBqOCB8IDA7XG4gICB4OSA9ICB4OSArICBqOSB8IDA7XG4gIHgxMCA9IHgxMCArIGoxMCB8IDA7XG4gIHgxMSA9IHgxMSArIGoxMSB8IDA7XG4gIHgxMiA9IHgxMiArIGoxMiB8IDA7XG4gIHgxMyA9IHgxMyArIGoxMyB8IDA7XG4gIHgxNCA9IHgxNCArIGoxNCB8IDA7XG4gIHgxNSA9IHgxNSArIGoxNSB8IDA7XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDEgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4MSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHgxID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDEgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgyID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDIgPj4+ICA4ICYgMHhmZjtcbiAgb1sxMF0gPSB4MiA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgyID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MyA+Pj4gIDAgJiAweGZmO1xuICBvWzEzXSA9IHgzID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDMgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTZdID0geDQgPj4+ICAwICYgMHhmZjtcbiAgb1sxN10gPSB4NCA+Pj4gIDggJiAweGZmO1xuICBvWzE4XSA9IHg0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTldID0geDQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzIwXSA9IHg1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjFdID0geDUgPj4+ICA4ICYgMHhmZjtcbiAgb1syMl0gPSB4NSA+Pj4gMTYgJiAweGZmO1xuICBvWzIzXSA9IHg1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syNF0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzI1XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjZdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1syN10gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjhdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syOV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzMwXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzFdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzMyXSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMzNdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1szNF0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzM1XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szNl0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzM3XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzhdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szOV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDBdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDFdID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDJdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDNdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0NF0gPSB4MTEgPj4+ICAwICYgMHhmZjtcbiAgb1s0NV0gPSB4MTEgPj4+ICA4ICYgMHhmZjtcbiAgb1s0Nl0gPSB4MTEgPj4+IDE2ICYgMHhmZjtcbiAgb1s0N10gPSB4MTEgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQ4XSA9IHgxMiA+Pj4gIDAgJiAweGZmO1xuICBvWzQ5XSA9IHgxMiA+Pj4gIDggJiAweGZmO1xuICBvWzUwXSA9IHgxMiA+Pj4gMTYgJiAweGZmO1xuICBvWzUxXSA9IHgxMiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTJdID0geDEzID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTNdID0geDEzID4+PiAgOCAmIDB4ZmY7XG4gIG9bNTRdID0geDEzID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTVdID0geDEzID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s1Nl0gPSB4MTQgPj4+ICAwICYgMHhmZjtcbiAgb1s1N10gPSB4MTQgPj4+ICA4ICYgMHhmZjtcbiAgb1s1OF0gPSB4MTQgPj4+IDE2ICYgMHhmZjtcbiAgb1s1OV0gPSB4MTQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzYwXSA9IHgxNSA+Pj4gIDAgJiAweGZmO1xuICBvWzYxXSA9IHgxNSA+Pj4gIDggJiAweGZmO1xuICBvWzYyXSA9IHgxNSA+Pj4gMTYgJiAweGZmO1xuICBvWzYzXSA9IHgxNSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjb3JlX2hzYWxzYTIwKG8scCxrLGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpPDw4IHwgKGNbIDJdICYgMHhmZik8PDE2IHwgKGNbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZik8PDggfCAoa1sgMl0gJiAweGZmKTw8MTYgfCAoa1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKTw8OCB8IChrWyA2XSAmIDB4ZmYpPDwxNiB8IChrWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpPDw4IHwgKGtbMTBdICYgMHhmZik8PDE2IHwgKGtbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZik8PDggfCAoa1sxNF0gJiAweGZmKTw8MTYgfCAoa1sxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKTw8OCB8IChjWyA2XSAmIDB4ZmYpPDwxNiB8IChjWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpPDw4IHwgKHBbIDJdICYgMHhmZik8PDE2IHwgKHBbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZik8PDggfCAocFsgNl0gJiAweGZmKTw8MTYgfCAocFsgN10gJiAweGZmKTw8MjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKTw8OCB8IChwWzEwXSAmIDB4ZmYpPDwxNiB8IChwWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpPDw4IHwgKHBbMTRdICYgMHhmZik8PDE2IHwgKHBbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZik8PDggfCAoY1sxMF0gJiAweGZmKTw8MTYgfCAoY1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKTw8OCB8IChrWzE4XSAmIDB4ZmYpPDwxNiB8IChrWzE5XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpPDw4IHwgKGtbMjJdICYgMHhmZik8PDE2IHwgKGtbMjNdICYgMHhmZik8PDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZik8PDggfCAoa1syNl0gJiAweGZmKTw8MTYgfCAoa1syN10gJiAweGZmKTw8MjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKTw8OCB8IChrWzMwXSAmIDB4ZmYpPDwxNiB8IChrWzMxXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpPDw4IHwgKGNbMTRdICYgMHhmZik8PDE2IHwgKGNbMTVdICYgMHhmZik8PDI0O1xuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMDtcbiAgICB4NCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDQgKyB4MCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDQgfCAwO1xuICAgIHgxMiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTIgKyB4OCB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHgxIHwgMDtcbiAgICB4OSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDkgKyB4NSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4OSB8IDA7XG4gICAgeDEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEgKyB4MTMgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDYgfCAwO1xuICAgIHgxNCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDE0ICsgeDEwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MTQgfCAwO1xuICAgIHg2IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg2ICsgeDIgfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxMSB8IDA7XG4gICAgeDMgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgzICsgeDE1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4MyB8IDA7XG4gICAgeDExIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMSArIHg3IHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MCArIHgzIHwgMDtcbiAgICB4MSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEgKyB4MCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDEgfCAwO1xuICAgIHgzIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgzICsgeDIgfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4NCB8IDA7XG4gICAgeDYgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg2ICsgeDUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHg2IHwgMDtcbiAgICB4NCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NCArIHg3IHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg5IHwgMDtcbiAgICB4MTEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMSArIHgxMCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDExIHwgMDtcbiAgICB4OSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4OSArIHg4IHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwO1xuICAgIHgxMiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEyICsgeDE1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHgxMiB8IDA7XG4gICAgeDE0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxNCArIHgxMyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG4gIH1cblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZjtcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmO1xuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgNF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWyA1XSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDZdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1sgN10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDhdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTFdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1sxNF0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MTUgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg2ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDYgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NiA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg2ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NyA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg3ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDcgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDggPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4OCA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg4ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDggPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg5ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDkgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4OSA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg5ID4+PiAyNCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX3NhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2NvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9oc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbnZhciBzaWdtYSA9IG5ldyBVaW50OEFycmF5KFsxMDEsIDEyMCwgMTEyLCA5NywgMTEwLCAxMDAsIDMyLCA1MSwgNTAsIDQ1LCA5OCwgMTIxLCAxMTYsIDEwMSwgMzIsIDEwN10pO1xuICAgICAgICAgICAgLy8gXCJleHBhbmQgMzItYnl0ZSBrXCJcblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gICAgbXBvcyArPSA2NDtcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYjsgaSsrKSBjW2Nwb3MraV0gPSBtW21wb3MraV0gXiB4W2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbShjLGNwb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGQsc24scyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yKGMsY3BvcyxtLG1wb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsY3BvcyxtLG1wb3MsZCxzbixzKTtcbn1cblxuLypcbiogUG9ydCBvZiBBbmRyZXcgTW9vbidzIFBvbHkxMzA1LWRvbm5hLTE2LiBQdWJsaWMgZG9tYWluLlxuKiBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbiovXG5cbnZhciBwb2x5MTMwNSA9IGZ1bmN0aW9uKGtleSkge1xuICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgdGhpcy5yID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5oID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5wYWQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gIHRoaXMubGVmdG92ZXIgPSAwO1xuICB0aGlzLmZpbiA9IDA7XG5cbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NztcblxuICB0MCA9IGtleVsgMF0gJiAweGZmIHwgKGtleVsgMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMF0gPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgdDEgPSBrZXlbIDJdICYgMHhmZiB8IChrZXlbIDNdICYgMHhmZikgPDwgODsgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gIHQyID0ga2V5WyA0XSAmIDB4ZmYgfCAoa2V5WyA1XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZjAzO1xuICB0MyA9IGtleVsgNl0gJiAweGZmIHwgKGtleVsgN10gJiAweGZmKSA8PCA4OyB0aGlzLnJbM10gPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgdDQgPSBrZXlbIDhdICYgMHhmZiB8IChrZXlbIDldICYgMHhmZikgPDwgODsgdGhpcy5yWzRdID0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gIHRoaXMucls1XSA9ICgodDQgPj4+ICAxKSkgJiAweDFmZmU7XG4gIHQ1ID0ga2V5WzEwXSAmIDB4ZmYgfCAoa2V5WzExXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICB0NiA9IGtleVsxMl0gJiAweGZmIHwgKGtleVsxM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWY4MTtcbiAgdDcgPSBrZXlbMTRdICYgMHhmZiB8IChrZXlbMTVdICYgMHhmZikgPDwgODsgdGhpcy5yWzhdID0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gIHRoaXMucls5XSA9ICgodDcgPj4+ICA1KSkgJiAweDAwN2Y7XG5cbiAgdGhpcy5wYWRbMF0gPSBrZXlbMTZdICYgMHhmZiB8IChrZXlbMTddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMV0gPSBrZXlbMThdICYgMHhmZiB8IChrZXlbMTldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMl0gPSBrZXlbMjBdICYgMHhmZiB8IChrZXlbMjFdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbM10gPSBrZXlbMjJdICYgMHhmZiB8IChrZXlbMjNdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNF0gPSBrZXlbMjRdICYgMHhmZiB8IChrZXlbMjVdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNV0gPSBrZXlbMjZdICYgMHhmZiB8IChrZXlbMjddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNl0gPSBrZXlbMjhdICYgMHhmZiB8IChrZXlbMjldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbN10gPSBrZXlbMzBdICYgMHhmZiB8IChrZXlbMzFdICYgMHhmZikgPDwgODtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5ibG9ja3MgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaGliaXQgPSB0aGlzLmZpbiA/IDAgOiAoMSA8PCAxMSk7XG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDcsIGM7XG4gIHZhciBkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOTtcblxuICB2YXIgaDAgPSB0aGlzLmhbMF0sXG4gICAgICBoMSA9IHRoaXMuaFsxXSxcbiAgICAgIGgyID0gdGhpcy5oWzJdLFxuICAgICAgaDMgPSB0aGlzLmhbM10sXG4gICAgICBoNCA9IHRoaXMuaFs0XSxcbiAgICAgIGg1ID0gdGhpcy5oWzVdLFxuICAgICAgaDYgPSB0aGlzLmhbNl0sXG4gICAgICBoNyA9IHRoaXMuaFs3XSxcbiAgICAgIGg4ID0gdGhpcy5oWzhdLFxuICAgICAgaDkgPSB0aGlzLmhbOV07XG5cbiAgdmFyIHIwID0gdGhpcy5yWzBdLFxuICAgICAgcjEgPSB0aGlzLnJbMV0sXG4gICAgICByMiA9IHRoaXMuclsyXSxcbiAgICAgIHIzID0gdGhpcy5yWzNdLFxuICAgICAgcjQgPSB0aGlzLnJbNF0sXG4gICAgICByNSA9IHRoaXMucls1XSxcbiAgICAgIHI2ID0gdGhpcy5yWzZdLFxuICAgICAgcjcgPSB0aGlzLnJbN10sXG4gICAgICByOCA9IHRoaXMucls4XSxcbiAgICAgIHI5ID0gdGhpcy5yWzldO1xuXG4gIHdoaWxlIChieXRlcyA+PSAxNikge1xuICAgIHQwID0gbVttcG9zKyAwXSAmIDB4ZmYgfCAobVttcG9zKyAxXSAmIDB4ZmYpIDw8IDg7IGgwICs9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICAgIHQxID0gbVttcG9zKyAyXSAmIDB4ZmYgfCAobVttcG9zKyAzXSAmIDB4ZmYpIDw8IDg7IGgxICs9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICAgIHQyID0gbVttcG9zKyA0XSAmIDB4ZmYgfCAobVttcG9zKyA1XSAmIDB4ZmYpIDw8IDg7IGgyICs9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZmZmO1xuICAgIHQzID0gbVttcG9zKyA2XSAmIDB4ZmYgfCAobVttcG9zKyA3XSAmIDB4ZmYpIDw8IDg7IGgzICs9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICAgIHQ0ID0gbVttcG9zKyA4XSAmIDB4ZmYgfCAobVttcG9zKyA5XSAmIDB4ZmYpIDw8IDg7IGg0ICs9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmO1xuICAgIGg1ICs9ICgodDQgPj4+ICAxKSkgJiAweDFmZmY7XG4gICAgdDUgPSBtW21wb3MrMTBdICYgMHhmZiB8IChtW21wb3MrMTFdICYgMHhmZikgPDwgODsgaDYgKz0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gICAgdDYgPSBtW21wb3MrMTJdICYgMHhmZiB8IChtW21wb3MrMTNdICYgMHhmZikgPDwgODsgaDcgKz0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmZmY7XG4gICAgdDcgPSBtW21wb3MrMTRdICYgMHhmZiB8IChtW21wb3MrMTVdICYgMHhmZikgPDwgODsgaDggKz0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gICAgaDkgKz0gKCh0NyA+Pj4gNSkpIHwgaGliaXQ7XG5cbiAgICBjID0gMDtcblxuICAgIGQwID0gYztcbiAgICBkMCArPSBoMCAqIHIwO1xuICAgIGQwICs9IGgxICogKDUgKiByOSk7XG4gICAgZDAgKz0gaDIgKiAoNSAqIHI4KTtcbiAgICBkMCArPSBoMyAqICg1ICogcjcpO1xuICAgIGQwICs9IGg0ICogKDUgKiByNik7XG4gICAgYyA9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG4gICAgZDAgKz0gaDUgKiAoNSAqIHI1KTtcbiAgICBkMCArPSBoNiAqICg1ICogcjQpO1xuICAgIGQwICs9IGg3ICogKDUgKiByMyk7XG4gICAgZDAgKz0gaDggKiAoNSAqIHIyKTtcbiAgICBkMCArPSBoOSAqICg1ICogcjEpO1xuICAgIGMgKz0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcblxuICAgIGQxID0gYztcbiAgICBkMSArPSBoMCAqIHIxO1xuICAgIGQxICs9IGgxICogcjA7XG4gICAgZDEgKz0gaDIgKiAoNSAqIHI5KTtcbiAgICBkMSArPSBoMyAqICg1ICogcjgpO1xuICAgIGQxICs9IGg0ICogKDUgKiByNyk7XG4gICAgYyA9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KTtcbiAgICBkMSArPSBoNiAqICg1ICogcjUpO1xuICAgIGQxICs9IGg3ICogKDUgKiByNCk7XG4gICAgZDEgKz0gaDggKiAoNSAqIHIzKTtcbiAgICBkMSArPSBoOSAqICg1ICogcjIpO1xuICAgIGMgKz0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcblxuICAgIGQyID0gYztcbiAgICBkMiArPSBoMCAqIHIyO1xuICAgIGQyICs9IGgxICogcjE7XG4gICAgZDIgKz0gaDIgKiByMDtcbiAgICBkMiArPSBoMyAqICg1ICogcjkpO1xuICAgIGQyICs9IGg0ICogKDUgKiByOCk7XG4gICAgYyA9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG4gICAgZDIgKz0gaDUgKiAoNSAqIHI3KTtcbiAgICBkMiArPSBoNiAqICg1ICogcjYpO1xuICAgIGQyICs9IGg3ICogKDUgKiByNSk7XG4gICAgZDIgKz0gaDggKiAoNSAqIHI0KTtcbiAgICBkMiArPSBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcblxuICAgIGQzID0gYztcbiAgICBkMyArPSBoMCAqIHIzO1xuICAgIGQzICs9IGgxICogcjI7XG4gICAgZDMgKz0gaDIgKiByMTtcbiAgICBkMyArPSBoMyAqIHIwO1xuICAgIGQzICs9IGg0ICogKDUgKiByOSk7XG4gICAgYyA9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG4gICAgZDMgKz0gaDUgKiAoNSAqIHI4KTtcbiAgICBkMyArPSBoNiAqICg1ICogcjcpO1xuICAgIGQzICs9IGg3ICogKDUgKiByNik7XG4gICAgZDMgKz0gaDggKiAoNSAqIHI1KTtcbiAgICBkMyArPSBoOSAqICg1ICogcjQpO1xuICAgIGMgKz0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcblxuICAgIGQ0ID0gYztcbiAgICBkNCArPSBoMCAqIHI0O1xuICAgIGQ0ICs9IGgxICogcjM7XG4gICAgZDQgKz0gaDIgKiByMjtcbiAgICBkNCArPSBoMyAqIHIxO1xuICAgIGQ0ICs9IGg0ICogcjA7XG4gICAgYyA9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KTtcbiAgICBkNCArPSBoNiAqICg1ICogcjgpO1xuICAgIGQ0ICs9IGg3ICogKDUgKiByNyk7XG4gICAgZDQgKz0gaDggKiAoNSAqIHI2KTtcbiAgICBkNCArPSBoOSAqICg1ICogcjUpO1xuICAgIGMgKz0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcblxuICAgIGQ1ID0gYztcbiAgICBkNSArPSBoMCAqIHI1O1xuICAgIGQ1ICs9IGgxICogcjQ7XG4gICAgZDUgKz0gaDIgKiByMztcbiAgICBkNSArPSBoMyAqIHIyO1xuICAgIGQ1ICs9IGg0ICogcjE7XG4gICAgYyA9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG4gICAgZDUgKz0gaDUgKiByMDtcbiAgICBkNSArPSBoNiAqICg1ICogcjkpO1xuICAgIGQ1ICs9IGg3ICogKDUgKiByOCk7XG4gICAgZDUgKz0gaDggKiAoNSAqIHI3KTtcbiAgICBkNSArPSBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcblxuICAgIGQ2ID0gYztcbiAgICBkNiArPSBoMCAqIHI2O1xuICAgIGQ2ICs9IGgxICogcjU7XG4gICAgZDYgKz0gaDIgKiByNDtcbiAgICBkNiArPSBoMyAqIHIzO1xuICAgIGQ2ICs9IGg0ICogcjI7XG4gICAgYyA9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG4gICAgZDYgKz0gaDUgKiByMTtcbiAgICBkNiArPSBoNiAqIHIwO1xuICAgIGQ2ICs9IGg3ICogKDUgKiByOSk7XG4gICAgZDYgKz0gaDggKiAoNSAqIHI4KTtcbiAgICBkNiArPSBoOSAqICg1ICogcjcpO1xuICAgIGMgKz0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcblxuICAgIGQ3ID0gYztcbiAgICBkNyArPSBoMCAqIHI3O1xuICAgIGQ3ICs9IGgxICogcjY7XG4gICAgZDcgKz0gaDIgKiByNTtcbiAgICBkNyArPSBoMyAqIHI0O1xuICAgIGQ3ICs9IGg0ICogcjM7XG4gICAgYyA9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMjtcbiAgICBkNyArPSBoNiAqIHIxO1xuICAgIGQ3ICs9IGg3ICogcjA7XG4gICAgZDcgKz0gaDggKiAoNSAqIHI5KTtcbiAgICBkNyArPSBoOSAqICg1ICogcjgpO1xuICAgIGMgKz0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcblxuICAgIGQ4ID0gYztcbiAgICBkOCArPSBoMCAqIHI4O1xuICAgIGQ4ICs9IGgxICogcjc7XG4gICAgZDggKz0gaDIgKiByNjtcbiAgICBkOCArPSBoMyAqIHI1O1xuICAgIGQ4ICs9IGg0ICogcjQ7XG4gICAgYyA9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG4gICAgZDggKz0gaDUgKiByMztcbiAgICBkOCArPSBoNiAqIHIyO1xuICAgIGQ4ICs9IGg3ICogcjE7XG4gICAgZDggKz0gaDggKiByMDtcbiAgICBkOCArPSBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcblxuICAgIGQ5ID0gYztcbiAgICBkOSArPSBoMCAqIHI5O1xuICAgIGQ5ICs9IGgxICogcjg7XG4gICAgZDkgKz0gaDIgKiByNztcbiAgICBkOSArPSBoMyAqIHI2O1xuICAgIGQ5ICs9IGg0ICogcjU7XG4gICAgYyA9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG4gICAgZDkgKz0gaDUgKiByNDtcbiAgICBkOSArPSBoNiAqIHIzO1xuICAgIGQ5ICs9IGg3ICogcjI7XG4gICAgZDkgKz0gaDggKiByMTtcbiAgICBkOSArPSBoOSAqIHIwO1xuICAgIGMgKz0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcblxuICAgIGMgPSAoKChjIDw8IDIpICsgYykpIHwgMDtcbiAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICBjID0gKGMgPj4+IDEzKTtcbiAgICBkMSArPSBjO1xuXG4gICAgaDAgPSBkMDtcbiAgICBoMSA9IGQxO1xuICAgIGgyID0gZDI7XG4gICAgaDMgPSBkMztcbiAgICBoNCA9IGQ0O1xuICAgIGg1ID0gZDU7XG4gICAgaDYgPSBkNjtcbiAgICBoNyA9IGQ3O1xuICAgIGg4ID0gZDg7XG4gICAgaDkgPSBkOTtcblxuICAgIG1wb3MgKz0gMTY7XG4gICAgYnl0ZXMgLT0gMTY7XG4gIH1cbiAgdGhpcy5oWzBdID0gaDA7XG4gIHRoaXMuaFsxXSA9IGgxO1xuICB0aGlzLmhbMl0gPSBoMjtcbiAgdGhpcy5oWzNdID0gaDM7XG4gIHRoaXMuaFs0XSA9IGg0O1xuICB0aGlzLmhbNV0gPSBoNTtcbiAgdGhpcy5oWzZdID0gaDY7XG4gIHRoaXMuaFs3XSA9IGg3O1xuICB0aGlzLmhbOF0gPSBoODtcbiAgdGhpcy5oWzldID0gaDk7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24obWFjLCBtYWNwb3MpIHtcbiAgdmFyIGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB2YXIgYywgbWFzaywgZiwgaTtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIGkgPSB0aGlzLmxlZnRvdmVyO1xuICAgIHRoaXMuYnVmZmVyW2krK10gPSAxO1xuICAgIGZvciAoOyBpIDwgMTY7IGkrKykgdGhpcy5idWZmZXJbaV0gPSAwO1xuICAgIHRoaXMuZmluID0gMTtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICB9XG5cbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgdGhpcy5oW2ldICs9IGM7XG4gICAgYyA9IHRoaXMuaFtpXSA+Pj4gMTM7XG4gICAgdGhpcy5oW2ldICY9IDB4MWZmZjtcbiAgfVxuICB0aGlzLmhbMF0gKz0gKGMgKiA1KTtcbiAgYyA9IHRoaXMuaFswXSA+Pj4gMTM7XG4gIHRoaXMuaFswXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsxXSArPSBjO1xuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzJdICs9IGM7XG5cbiAgZ1swXSA9IHRoaXMuaFswXSArIDU7XG4gIGMgPSBnWzBdID4+PiAxMztcbiAgZ1swXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgZ1tpXSA9IHRoaXMuaFtpXSArIGM7XG4gICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgIGdbaV0gJj0gMHgxZmZmO1xuICB9XG4gIGdbOV0gLT0gKDEgPDwgMTMpO1xuXG4gIG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIGdbaV0gJj0gbWFzaztcbiAgbWFzayA9IH5tYXNrO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgdGhpcy5oW2ldID0gKHRoaXMuaFtpXSAmIG1hc2spIHwgZ1tpXTtcblxuICB0aGlzLmhbMF0gPSAoKHRoaXMuaFswXSAgICAgICApIHwgKHRoaXMuaFsxXSA8PCAxMykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsxXSA9ICgodGhpcy5oWzFdID4+PiAgMykgfCAodGhpcy5oWzJdIDw8IDEwKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzJdID0gKCh0aGlzLmhbMl0gPj4+ICA2KSB8ICh0aGlzLmhbM10gPDwgIDcpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbM10gPSAoKHRoaXMuaFszXSA+Pj4gIDkpIHwgKHRoaXMuaFs0XSA8PCAgNCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs0XSA9ICgodGhpcy5oWzRdID4+PiAxMikgfCAodGhpcy5oWzVdIDw8ICAxKSB8ICh0aGlzLmhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzVdID0gKCh0aGlzLmhbNl0gPj4+ICAyKSB8ICh0aGlzLmhbN10gPDwgMTEpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNl0gPSAoKHRoaXMuaFs3XSA+Pj4gIDUpIHwgKHRoaXMuaFs4XSA8PCAgOCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs3XSA9ICgodGhpcy5oWzhdID4+PiAgOCkgfCAodGhpcy5oWzldIDw8ICA1KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcblxuICBmID0gdGhpcy5oWzBdICsgdGhpcy5wYWRbMF07XG4gIHRoaXMuaFswXSA9IGYgJiAweGZmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBmID0gKCgodGhpcy5oW2ldICsgdGhpcy5wYWRbaV0pIHwgMCkgKyAoZiA+Pj4gMTYpKSB8IDA7XG4gICAgdGhpcy5oW2ldID0gZiAmIDB4ZmZmZjtcbiAgfVxuXG4gIG1hY1ttYWNwb3MrIDBdID0gKHRoaXMuaFswXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAxXSA9ICh0aGlzLmhbMF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMl0gPSAodGhpcy5oWzFdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDNdID0gKHRoaXMuaFsxXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA0XSA9ICh0aGlzLmhbMl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNV0gPSAodGhpcy5oWzJdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDZdID0gKHRoaXMuaFszXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA3XSA9ICh0aGlzLmhbM10gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOF0gPSAodGhpcy5oWzRdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDldID0gKHRoaXMuaFs0XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEwXSA9ICh0aGlzLmhbNV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMV0gPSAodGhpcy5oWzVdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTJdID0gKHRoaXMuaFs2XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEzXSA9ICh0aGlzLmhbNl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNF0gPSAodGhpcy5oWzddID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTVdID0gKHRoaXMuaFs3XSA+Pj4gOCkgJiAweGZmO1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBpLCB3YW50O1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgd2FudCA9ICgxNiAtIHRoaXMubGVmdG92ZXIpO1xuICAgIGlmICh3YW50ID4gYnl0ZXMpXG4gICAgICB3YW50ID0gYnl0ZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHdhbnQ7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICBieXRlcyAtPSB3YW50O1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICB0aGlzLmxlZnRvdmVyICs9IHdhbnQ7XG4gICAgaWYgKHRoaXMubGVmdG92ZXIgPCAxNilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICAgIHRoaXMubGVmdG92ZXIgPSAwO1xuICB9XG5cbiAgaWYgKGJ5dGVzID49IDE2KSB7XG4gICAgd2FudCA9IGJ5dGVzIC0gKGJ5dGVzICUgMTYpO1xuICAgIHRoaXMuYmxvY2tzKG0sIG1wb3MsIHdhbnQpO1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICBieXRlcyAtPSB3YW50O1xuICB9XG5cbiAgaWYgKGJ5dGVzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgdGhpcy5sZWZ0b3ZlciArPSBieXRlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciBzID0gbmV3IHBvbHkxMzA1KGspO1xuICBzLnVwZGF0ZShtLCBtcG9zLCBuKTtcbiAgcy5maW5pc2gob3V0LCBvdXRwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShoLCBocG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjcnlwdG9fb25ldGltZWF1dGgoeCwwLG0sbXBvcyxuLGspO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8xNihoLGhwb3MseCwwKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveChjLG0sZCxuLGspIHtcbiAgdmFyIGk7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IoYywwLG0sMCxkLG4sayk7XG4gIGNyeXB0b19vbmV0aW1lYXV0aChjLCAxNiwgYywgMzIsIGQgLSAzMiwgYyk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBjW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLGMsZCxuLGspIHtcbiAgdmFyIGk7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW0oeCwwLDMyLG4sayk7XG4gIGlmIChjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGMsIDE2LGMsIDMyLGQgLSAzMix4KSAhPT0gMCkgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihtLDAsYywwLGQsbixrKTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHJbaV0gPSBhW2ldfDA7XG59XG5cbmZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgdmFyIGksIHYsIGMgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHYgPSBvW2ldICsgYyArIDY1NTM1O1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgb1tpXSA9IHYgLSBjICogNjU1MzY7XG4gIH1cbiAgb1swXSArPSBjLTEgKyAzNyAqIChjLTEpO1xufVxuXG5mdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gIHZhciB0LCBjID0gfihiLTEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSk7XG4gICAgcFtpXSBePSB0O1xuICAgIHFbaV0gXj0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICB2YXIgaSwgaiwgYjtcbiAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHRbaV0gPSBuW2ldO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgbVswXSA9IHRbMF0gLSAweGZmZWQ7XG4gICAgZm9yIChpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgIG1baV0gPSB0W2ldIC0gMHhmZmZmIC0gKChtW2ktMV0+PjE2KSAmIDEpO1xuICAgICAgbVtpLTFdICY9IDB4ZmZmZjtcbiAgICB9XG4gICAgbVsxNV0gPSB0WzE1XSAtIDB4N2ZmZiAtICgobVsxNF0+PjE2KSAmIDEpO1xuICAgIGIgPSAobVsxNV0+PjE2KSAmIDE7XG4gICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgIHNlbDI1NTE5KHQsIG0sIDEtYik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBvWzIqaV0gPSB0W2ldICYgMHhmZjtcbiAgICBvWzIqaSsxXSA9IHRbaV0+Pjg7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVxMjU1MTkoYSwgYikge1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KDMyKSwgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGMsIGEpO1xuICBwYWNrMjU1MTkoZCwgYik7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzMyKGMsIDAsIGQsIDApO1xufVxuXG5mdW5jdGlvbiBwYXIyNTUxOShhKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoZCwgYSk7XG4gIHJldHVybiBkWzBdICYgMTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrMjU1MTkobywgbikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBuWzIqaV0gKyAoblsyKmkrMV0gPDwgOCk7XG4gIG9bMTVdICY9IDB4N2ZmZjtcbn1cblxuZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gKyBiW2ldO1xufVxuXG5mdW5jdGlvbiBaKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSAtIGJbaV07XG59XG5cbmZ1bmN0aW9uIE0obywgYSwgYikge1xuICB2YXIgdiwgYyxcbiAgICAgdDAgPSAwLCAgdDEgPSAwLCAgdDIgPSAwLCAgdDMgPSAwLCAgdDQgPSAwLCAgdDUgPSAwLCAgdDYgPSAwLCAgdDcgPSAwLFxuICAgICB0OCA9IDAsICB0OSA9IDAsIHQxMCA9IDAsIHQxMSA9IDAsIHQxMiA9IDAsIHQxMyA9IDAsIHQxNCA9IDAsIHQxNSA9IDAsXG4gICAgdDE2ID0gMCwgdDE3ID0gMCwgdDE4ID0gMCwgdDE5ID0gMCwgdDIwID0gMCwgdDIxID0gMCwgdDIyID0gMCwgdDIzID0gMCxcbiAgICB0MjQgPSAwLCB0MjUgPSAwLCB0MjYgPSAwLCB0MjcgPSAwLCB0MjggPSAwLCB0MjkgPSAwLCB0MzAgPSAwLFxuICAgIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXSxcbiAgICBiNCA9IGJbNF0sXG4gICAgYjUgPSBiWzVdLFxuICAgIGI2ID0gYls2XSxcbiAgICBiNyA9IGJbN10sXG4gICAgYjggPSBiWzhdLFxuICAgIGI5ID0gYls5XSxcbiAgICBiMTAgPSBiWzEwXSxcbiAgICBiMTEgPSBiWzExXSxcbiAgICBiMTIgPSBiWzEyXSxcbiAgICBiMTMgPSBiWzEzXSxcbiAgICBiMTQgPSBiWzE0XSxcbiAgICBiMTUgPSBiWzE1XTtcblxuICB2ID0gYVswXTtcbiAgdDAgKz0gdiAqIGIwO1xuICB0MSArPSB2ICogYjE7XG4gIHQyICs9IHYgKiBiMjtcbiAgdDMgKz0gdiAqIGIzO1xuICB0NCArPSB2ICogYjQ7XG4gIHQ1ICs9IHYgKiBiNTtcbiAgdDYgKz0gdiAqIGI2O1xuICB0NyArPSB2ICogYjc7XG4gIHQ4ICs9IHYgKiBiODtcbiAgdDkgKz0gdiAqIGI5O1xuICB0MTAgKz0gdiAqIGIxMDtcbiAgdDExICs9IHYgKiBiMTE7XG4gIHQxMiArPSB2ICogYjEyO1xuICB0MTMgKz0gdiAqIGIxMztcbiAgdDE0ICs9IHYgKiBiMTQ7XG4gIHQxNSArPSB2ICogYjE1O1xuICB2ID0gYVsxXTtcbiAgdDEgKz0gdiAqIGIwO1xuICB0MiArPSB2ICogYjE7XG4gIHQzICs9IHYgKiBiMjtcbiAgdDQgKz0gdiAqIGIzO1xuICB0NSArPSB2ICogYjQ7XG4gIHQ2ICs9IHYgKiBiNTtcbiAgdDcgKz0gdiAqIGI2O1xuICB0OCArPSB2ICogYjc7XG4gIHQ5ICs9IHYgKiBiODtcbiAgdDEwICs9IHYgKiBiOTtcbiAgdDExICs9IHYgKiBiMTA7XG4gIHQxMiArPSB2ICogYjExO1xuICB0MTMgKz0gdiAqIGIxMjtcbiAgdDE0ICs9IHYgKiBiMTM7XG4gIHQxNSArPSB2ICogYjE0O1xuICB0MTYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMl07XG4gIHQyICs9IHYgKiBiMDtcbiAgdDMgKz0gdiAqIGIxO1xuICB0NCArPSB2ICogYjI7XG4gIHQ1ICs9IHYgKiBiMztcbiAgdDYgKz0gdiAqIGI0O1xuICB0NyArPSB2ICogYjU7XG4gIHQ4ICs9IHYgKiBiNjtcbiAgdDkgKz0gdiAqIGI3O1xuICB0MTAgKz0gdiAqIGI4O1xuICB0MTEgKz0gdiAqIGI5O1xuICB0MTIgKz0gdiAqIGIxMDtcbiAgdDEzICs9IHYgKiBiMTE7XG4gIHQxNCArPSB2ICogYjEyO1xuICB0MTUgKz0gdiAqIGIxMztcbiAgdDE2ICs9IHYgKiBiMTQ7XG4gIHQxNyArPSB2ICogYjE1O1xuICB2ID0gYVszXTtcbiAgdDMgKz0gdiAqIGIwO1xuICB0NCArPSB2ICogYjE7XG4gIHQ1ICs9IHYgKiBiMjtcbiAgdDYgKz0gdiAqIGIzO1xuICB0NyArPSB2ICogYjQ7XG4gIHQ4ICs9IHYgKiBiNTtcbiAgdDkgKz0gdiAqIGI2O1xuICB0MTAgKz0gdiAqIGI3O1xuICB0MTEgKz0gdiAqIGI4O1xuICB0MTIgKz0gdiAqIGI5O1xuICB0MTMgKz0gdiAqIGIxMDtcbiAgdDE0ICs9IHYgKiBiMTE7XG4gIHQxNSArPSB2ICogYjEyO1xuICB0MTYgKz0gdiAqIGIxMztcbiAgdDE3ICs9IHYgKiBiMTQ7XG4gIHQxOCArPSB2ICogYjE1O1xuICB2ID0gYVs0XTtcbiAgdDQgKz0gdiAqIGIwO1xuICB0NSArPSB2ICogYjE7XG4gIHQ2ICs9IHYgKiBiMjtcbiAgdDcgKz0gdiAqIGIzO1xuICB0OCArPSB2ICogYjQ7XG4gIHQ5ICs9IHYgKiBiNTtcbiAgdDEwICs9IHYgKiBiNjtcbiAgdDExICs9IHYgKiBiNztcbiAgdDEyICs9IHYgKiBiODtcbiAgdDEzICs9IHYgKiBiOTtcbiAgdDE0ICs9IHYgKiBiMTA7XG4gIHQxNSArPSB2ICogYjExO1xuICB0MTYgKz0gdiAqIGIxMjtcbiAgdDE3ICs9IHYgKiBiMTM7XG4gIHQxOCArPSB2ICogYjE0O1xuICB0MTkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNV07XG4gIHQ1ICs9IHYgKiBiMDtcbiAgdDYgKz0gdiAqIGIxO1xuICB0NyArPSB2ICogYjI7XG4gIHQ4ICs9IHYgKiBiMztcbiAgdDkgKz0gdiAqIGI0O1xuICB0MTAgKz0gdiAqIGI1O1xuICB0MTEgKz0gdiAqIGI2O1xuICB0MTIgKz0gdiAqIGI3O1xuICB0MTMgKz0gdiAqIGI4O1xuICB0MTQgKz0gdiAqIGI5O1xuICB0MTUgKz0gdiAqIGIxMDtcbiAgdDE2ICs9IHYgKiBiMTE7XG4gIHQxNyArPSB2ICogYjEyO1xuICB0MTggKz0gdiAqIGIxMztcbiAgdDE5ICs9IHYgKiBiMTQ7XG4gIHQyMCArPSB2ICogYjE1O1xuICB2ID0gYVs2XTtcbiAgdDYgKz0gdiAqIGIwO1xuICB0NyArPSB2ICogYjE7XG4gIHQ4ICs9IHYgKiBiMjtcbiAgdDkgKz0gdiAqIGIzO1xuICB0MTAgKz0gdiAqIGI0O1xuICB0MTEgKz0gdiAqIGI1O1xuICB0MTIgKz0gdiAqIGI2O1xuICB0MTMgKz0gdiAqIGI3O1xuICB0MTQgKz0gdiAqIGI4O1xuICB0MTUgKz0gdiAqIGI5O1xuICB0MTYgKz0gdiAqIGIxMDtcbiAgdDE3ICs9IHYgKiBiMTE7XG4gIHQxOCArPSB2ICogYjEyO1xuICB0MTkgKz0gdiAqIGIxMztcbiAgdDIwICs9IHYgKiBiMTQ7XG4gIHQyMSArPSB2ICogYjE1O1xuICB2ID0gYVs3XTtcbiAgdDcgKz0gdiAqIGIwO1xuICB0OCArPSB2ICogYjE7XG4gIHQ5ICs9IHYgKiBiMjtcbiAgdDEwICs9IHYgKiBiMztcbiAgdDExICs9IHYgKiBiNDtcbiAgdDEyICs9IHYgKiBiNTtcbiAgdDEzICs9IHYgKiBiNjtcbiAgdDE0ICs9IHYgKiBiNztcbiAgdDE1ICs9IHYgKiBiODtcbiAgdDE2ICs9IHYgKiBiOTtcbiAgdDE3ICs9IHYgKiBiMTA7XG4gIHQxOCArPSB2ICogYjExO1xuICB0MTkgKz0gdiAqIGIxMjtcbiAgdDIwICs9IHYgKiBiMTM7XG4gIHQyMSArPSB2ICogYjE0O1xuICB0MjIgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOF07XG4gIHQ4ICs9IHYgKiBiMDtcbiAgdDkgKz0gdiAqIGIxO1xuICB0MTAgKz0gdiAqIGIyO1xuICB0MTEgKz0gdiAqIGIzO1xuICB0MTIgKz0gdiAqIGI0O1xuICB0MTMgKz0gdiAqIGI1O1xuICB0MTQgKz0gdiAqIGI2O1xuICB0MTUgKz0gdiAqIGI3O1xuICB0MTYgKz0gdiAqIGI4O1xuICB0MTcgKz0gdiAqIGI5O1xuICB0MTggKz0gdiAqIGIxMDtcbiAgdDE5ICs9IHYgKiBiMTE7XG4gIHQyMCArPSB2ICogYjEyO1xuICB0MjEgKz0gdiAqIGIxMztcbiAgdDIyICs9IHYgKiBiMTQ7XG4gIHQyMyArPSB2ICogYjE1O1xuICB2ID0gYVs5XTtcbiAgdDkgKz0gdiAqIGIwO1xuICB0MTAgKz0gdiAqIGIxO1xuICB0MTEgKz0gdiAqIGIyO1xuICB0MTIgKz0gdiAqIGIzO1xuICB0MTMgKz0gdiAqIGI0O1xuICB0MTQgKz0gdiAqIGI1O1xuICB0MTUgKz0gdiAqIGI2O1xuICB0MTYgKz0gdiAqIGI3O1xuICB0MTcgKz0gdiAqIGI4O1xuICB0MTggKz0gdiAqIGI5O1xuICB0MTkgKz0gdiAqIGIxMDtcbiAgdDIwICs9IHYgKiBiMTE7XG4gIHQyMSArPSB2ICogYjEyO1xuICB0MjIgKz0gdiAqIGIxMztcbiAgdDIzICs9IHYgKiBiMTQ7XG4gIHQyNCArPSB2ICogYjE1O1xuICB2ID0gYVsxMF07XG4gIHQxMCArPSB2ICogYjA7XG4gIHQxMSArPSB2ICogYjE7XG4gIHQxMiArPSB2ICogYjI7XG4gIHQxMyArPSB2ICogYjM7XG4gIHQxNCArPSB2ICogYjQ7XG4gIHQxNSArPSB2ICogYjU7XG4gIHQxNiArPSB2ICogYjY7XG4gIHQxNyArPSB2ICogYjc7XG4gIHQxOCArPSB2ICogYjg7XG4gIHQxOSArPSB2ICogYjk7XG4gIHQyMCArPSB2ICogYjEwO1xuICB0MjEgKz0gdiAqIGIxMTtcbiAgdDIyICs9IHYgKiBiMTI7XG4gIHQyMyArPSB2ICogYjEzO1xuICB0MjQgKz0gdiAqIGIxNDtcbiAgdDI1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzExXTtcbiAgdDExICs9IHYgKiBiMDtcbiAgdDEyICs9IHYgKiBiMTtcbiAgdDEzICs9IHYgKiBiMjtcbiAgdDE0ICs9IHYgKiBiMztcbiAgdDE1ICs9IHYgKiBiNDtcbiAgdDE2ICs9IHYgKiBiNTtcbiAgdDE3ICs9IHYgKiBiNjtcbiAgdDE4ICs9IHYgKiBiNztcbiAgdDE5ICs9IHYgKiBiODtcbiAgdDIwICs9IHYgKiBiOTtcbiAgdDIxICs9IHYgKiBiMTA7XG4gIHQyMiArPSB2ICogYjExO1xuICB0MjMgKz0gdiAqIGIxMjtcbiAgdDI0ICs9IHYgKiBiMTM7XG4gIHQyNSArPSB2ICogYjE0O1xuICB0MjYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTJdO1xuICB0MTIgKz0gdiAqIGIwO1xuICB0MTMgKz0gdiAqIGIxO1xuICB0MTQgKz0gdiAqIGIyO1xuICB0MTUgKz0gdiAqIGIzO1xuICB0MTYgKz0gdiAqIGI0O1xuICB0MTcgKz0gdiAqIGI1O1xuICB0MTggKz0gdiAqIGI2O1xuICB0MTkgKz0gdiAqIGI3O1xuICB0MjAgKz0gdiAqIGI4O1xuICB0MjEgKz0gdiAqIGI5O1xuICB0MjIgKz0gdiAqIGIxMDtcbiAgdDIzICs9IHYgKiBiMTE7XG4gIHQyNCArPSB2ICogYjEyO1xuICB0MjUgKz0gdiAqIGIxMztcbiAgdDI2ICs9IHYgKiBiMTQ7XG4gIHQyNyArPSB2ICogYjE1O1xuICB2ID0gYVsxM107XG4gIHQxMyArPSB2ICogYjA7XG4gIHQxNCArPSB2ICogYjE7XG4gIHQxNSArPSB2ICogYjI7XG4gIHQxNiArPSB2ICogYjM7XG4gIHQxNyArPSB2ICogYjQ7XG4gIHQxOCArPSB2ICogYjU7XG4gIHQxOSArPSB2ICogYjY7XG4gIHQyMCArPSB2ICogYjc7XG4gIHQyMSArPSB2ICogYjg7XG4gIHQyMiArPSB2ICogYjk7XG4gIHQyMyArPSB2ICogYjEwO1xuICB0MjQgKz0gdiAqIGIxMTtcbiAgdDI1ICs9IHYgKiBiMTI7XG4gIHQyNiArPSB2ICogYjEzO1xuICB0MjcgKz0gdiAqIGIxNDtcbiAgdDI4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE0XTtcbiAgdDE0ICs9IHYgKiBiMDtcbiAgdDE1ICs9IHYgKiBiMTtcbiAgdDE2ICs9IHYgKiBiMjtcbiAgdDE3ICs9IHYgKiBiMztcbiAgdDE4ICs9IHYgKiBiNDtcbiAgdDE5ICs9IHYgKiBiNTtcbiAgdDIwICs9IHYgKiBiNjtcbiAgdDIxICs9IHYgKiBiNztcbiAgdDIyICs9IHYgKiBiODtcbiAgdDIzICs9IHYgKiBiOTtcbiAgdDI0ICs9IHYgKiBiMTA7XG4gIHQyNSArPSB2ICogYjExO1xuICB0MjYgKz0gdiAqIGIxMjtcbiAgdDI3ICs9IHYgKiBiMTM7XG4gIHQyOCArPSB2ICogYjE0O1xuICB0MjkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTVdO1xuICB0MTUgKz0gdiAqIGIwO1xuICB0MTYgKz0gdiAqIGIxO1xuICB0MTcgKz0gdiAqIGIyO1xuICB0MTggKz0gdiAqIGIzO1xuICB0MTkgKz0gdiAqIGI0O1xuICB0MjAgKz0gdiAqIGI1O1xuICB0MjEgKz0gdiAqIGI2O1xuICB0MjIgKz0gdiAqIGI3O1xuICB0MjMgKz0gdiAqIGI4O1xuICB0MjQgKz0gdiAqIGI5O1xuICB0MjUgKz0gdiAqIGIxMDtcbiAgdDI2ICs9IHYgKiBiMTE7XG4gIHQyNyArPSB2ICogYjEyO1xuICB0MjggKz0gdiAqIGIxMztcbiAgdDI5ICs9IHYgKiBiMTQ7XG4gIHQzMCArPSB2ICogYjE1O1xuXG4gIHQwICArPSAzOCAqIHQxNjtcbiAgdDEgICs9IDM4ICogdDE3O1xuICB0MiAgKz0gMzggKiB0MTg7XG4gIHQzICArPSAzOCAqIHQxOTtcbiAgdDQgICs9IDM4ICogdDIwO1xuICB0NSAgKz0gMzggKiB0MjE7XG4gIHQ2ICArPSAzOCAqIHQyMjtcbiAgdDcgICs9IDM4ICogdDIzO1xuICB0OCAgKz0gMzggKiB0MjQ7XG4gIHQ5ICArPSAzOCAqIHQyNTtcbiAgdDEwICs9IDM4ICogdDI2O1xuICB0MTEgKz0gMzggKiB0Mjc7XG4gIHQxMiArPSAzOCAqIHQyODtcbiAgdDEzICs9IDM4ICogdDI5O1xuICB0MTQgKz0gMzggKiB0MzA7XG4gIC8vIHQxNSBsZWZ0IGFzIGlzXG5cbiAgLy8gZmlyc3QgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIC8vIHNlY29uZCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgb1sgMF0gPSB0MDtcbiAgb1sgMV0gPSB0MTtcbiAgb1sgMl0gPSB0MjtcbiAgb1sgM10gPSB0MztcbiAgb1sgNF0gPSB0NDtcbiAgb1sgNV0gPSB0NTtcbiAgb1sgNl0gPSB0NjtcbiAgb1sgN10gPSB0NztcbiAgb1sgOF0gPSB0ODtcbiAgb1sgOV0gPSB0OTtcbiAgb1sxMF0gPSB0MTA7XG4gIG9bMTFdID0gdDExO1xuICBvWzEyXSA9IHQxMjtcbiAgb1sxM10gPSB0MTM7XG4gIG9bMTRdID0gdDE0O1xuICBvWzE1XSA9IHQxNTtcbn1cblxuZnVuY3Rpb24gUyhvLCBhKSB7XG4gIE0obywgYSwgYSk7XG59XG5cbmZ1bmN0aW9uIGludjI1NTE5KG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgYS0tKSB7XG4gICAgUyhjLCBjKTtcbiAgICBpZihhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTA7IGEgPj0gMDsgYS0tKSB7XG4gICAgICBTKGMsIGMpO1xuICAgICAgaWYoYSAhPT0gMSkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg4MCksIHIsIGk7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDMxOyBpKyspIHpbaV0gPSBuW2ldO1xuICB6WzMxXT0oblszMV0mMTI3KXw2NDtcbiAgelswXSY9MjQ4O1xuICB1bnBhY2syNTUxOSh4LHApO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGJbaV09eFtpXTtcbiAgICBkW2ldPWFbaV09Y1tpXT0wO1xuICB9XG4gIGFbMF09ZFswXT0xO1xuICBmb3IgKGk9MjU0OyBpPj0wOyAtLWkpIHtcbiAgICByPSh6W2k+Pj4zXT4+PihpJjcpKSYxO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgQShjLGIsZCk7XG4gICAgWihiLGIsZCk7XG4gICAgUyhkLGUpO1xuICAgIFMoZixhKTtcbiAgICBNKGEsYyxhKTtcbiAgICBNKGMsYixlKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBTKGIsYSk7XG4gICAgWihjLGQsZik7XG4gICAgTShhLGMsXzEyMTY2NSk7XG4gICAgQShhLGEsZCk7XG4gICAgTShjLGMsYSk7XG4gICAgTShhLGQsZik7XG4gICAgTShkLGIseCk7XG4gICAgUyhiLGUpO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB4W2krMTZdPWFbaV07XG4gICAgeFtpKzMyXT1jW2ldO1xuICAgIHhbaSs0OF09YltpXTtcbiAgICB4W2krNjRdPWRbaV07XG4gIH1cbiAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gIGludjI1NTE5KHgzMix4MzIpO1xuICBNKHgxNix4MTYseDMyKTtcbiAgcGFjazI1NTE5KHEseDE2KTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbikge1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgXzkpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2tleXBhaXIoeSwgeCkge1xuICByYW5kb21ieXRlcyh4LCAzMik7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHksIHgpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHMsIHgsIHkpO1xuICByZXR1cm4gY3J5cHRvX2NvcmVfaHNhbHNhMjAoaywgXzAsIHMsIHNpZ21hKTtcbn1cblxudmFyIGNyeXB0b19ib3hfYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3g7XG52YXIgY3J5cHRvX2JveF9vcGVuX2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94X29wZW47XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3goYywgbSwgZCwgbiwgeSwgeCkge1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgcmV0dXJuIGNyeXB0b19ib3hfYWZ0ZXJubShjLCBtLCBkLCBuLCBrKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9vcGVuKG0sIGMsIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubShtLCBjLCBkLCBuLCBrKTtcbn1cblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbikge1xuICB2YXIgd2ggPSBuZXcgSW50MzJBcnJheSgxNiksIHdsID0gbmV3IEludDMyQXJyYXkoMTYpLFxuICAgICAgYmgwLCBiaDEsIGJoMiwgYmgzLCBiaDQsIGJoNSwgYmg2LCBiaDcsXG4gICAgICBibDAsIGJsMSwgYmwyLCBibDMsIGJsNCwgYmw1LCBibDYsIGJsNyxcbiAgICAgIHRoLCB0bCwgaSwgaiwgaCwgbCwgYSwgYiwgYywgZDtcblxuICB2YXIgYWgwID0gaGhbMF0sXG4gICAgICBhaDEgPSBoaFsxXSxcbiAgICAgIGFoMiA9IGhoWzJdLFxuICAgICAgYWgzID0gaGhbM10sXG4gICAgICBhaDQgPSBoaFs0XSxcbiAgICAgIGFoNSA9IGhoWzVdLFxuICAgICAgYWg2ID0gaGhbNl0sXG4gICAgICBhaDcgPSBoaFs3XSxcblxuICAgICAgYWwwID0gaGxbMF0sXG4gICAgICBhbDEgPSBobFsxXSxcbiAgICAgIGFsMiA9IGhsWzJdLFxuICAgICAgYWwzID0gaGxbM10sXG4gICAgICBhbDQgPSBobFs0XSxcbiAgICAgIGFsNSA9IGhsWzVdLFxuICAgICAgYWw2ID0gaGxbNl0sXG4gICAgICBhbDcgPSBobFs3XTtcblxuICB2YXIgcG9zID0gMDtcbiAgd2hpbGUgKG4gPj0gMTI4KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGogPSA4ICogaSArIHBvcztcbiAgICAgIHdoW2ldID0gKG1baiswXSA8PCAyNCkgfCAobVtqKzFdIDw8IDE2KSB8IChtW2orMl0gPDwgOCkgfCBtW2orM107XG4gICAgICB3bFtpXSA9IChtW2orNF0gPDwgMjQpIHwgKG1bais1XSA8PCAxNikgfCAobVtqKzZdIDw8IDgpIHwgbVtqKzddO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgYmgwID0gYWgwO1xuICAgICAgYmgxID0gYWgxO1xuICAgICAgYmgyID0gYWgyO1xuICAgICAgYmgzID0gYWgzO1xuICAgICAgYmg0ID0gYWg0O1xuICAgICAgYmg1ID0gYWg1O1xuICAgICAgYmg2ID0gYWg2O1xuICAgICAgYmg3ID0gYWg3O1xuXG4gICAgICBibDAgPSBhbDA7XG4gICAgICBibDEgPSBhbDE7XG4gICAgICBibDIgPSBhbDI7XG4gICAgICBibDMgPSBhbDM7XG4gICAgICBibDQgPSBhbDQ7XG4gICAgICBibDUgPSBhbDU7XG4gICAgICBibDYgPSBhbDY7XG4gICAgICBibDcgPSBhbDc7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGFoNztcbiAgICAgIGwgPSBhbDc7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTFcbiAgICAgIGggPSAoKGFoNCA+Pj4gMTQpIHwgKGFsNCA8PCAoMzItMTQpKSkgXiAoKGFoNCA+Pj4gMTgpIHwgKGFsNCA8PCAoMzItMTgpKSkgXiAoKGFsNCA+Pj4gKDQxLTMyKSkgfCAoYWg0IDw8ICgzMi0oNDEtMzIpKSkpO1xuICAgICAgbCA9ICgoYWw0ID4+PiAxNCkgfCAoYWg0IDw8ICgzMi0xNCkpKSBeICgoYWw0ID4+PiAxOCkgfCAoYWg0IDw8ICgzMi0xOCkpKSBeICgoYWg0ID4+PiAoNDEtMzIpKSB8IChhbDQgPDwgKDMyLSg0MS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gQ2hcbiAgICAgIGggPSAoYWg0ICYgYWg1KSBeICh+YWg0ICYgYWg2KTtcbiAgICAgIGwgPSAoYWw0ICYgYWw1KSBeICh+YWw0ICYgYWw2KTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBLXG4gICAgICBoID0gS1tpKjJdO1xuICAgICAgbCA9IEtbaSoyKzFdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIHdcbiAgICAgIGggPSB3aFtpJTE2XTtcbiAgICAgIGwgPSB3bFtpJTE2XTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIHRoID0gYyAmIDB4ZmZmZiB8IGQgPDwgMTY7XG4gICAgICB0bCA9IGEgJiAweGZmZmYgfCBiIDw8IDE2O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMFxuICAgICAgaCA9ICgoYWgwID4+PiAyOCkgfCAoYWwwIDw8ICgzMi0yOCkpKSBeICgoYWwwID4+PiAoMzQtMzIpKSB8IChhaDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFsMCA+Pj4gKDM5LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzktMzIpKSkpO1xuICAgICAgbCA9ICgoYWwwID4+PiAyOCkgfCAoYWgwIDw8ICgzMi0yOCkpKSBeICgoYWgwID4+PiAoMzQtMzIpKSB8IChhbDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFoMCA+Pj4gKDM5LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzktMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIE1halxuICAgICAgaCA9IChhaDAgJiBhaDEpIF4gKGFoMCAmIGFoMikgXiAoYWgxICYgYWgyKTtcbiAgICAgIGwgPSAoYWwwICYgYWwxKSBeIChhbDAgJiBhbDIpIF4gKGFsMSAmIGFsMik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGJoMztcbiAgICAgIGwgPSBibDM7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIGFoMSA9IGJoMDtcbiAgICAgIGFoMiA9IGJoMTtcbiAgICAgIGFoMyA9IGJoMjtcbiAgICAgIGFoNCA9IGJoMztcbiAgICAgIGFoNSA9IGJoNDtcbiAgICAgIGFoNiA9IGJoNTtcbiAgICAgIGFoNyA9IGJoNjtcbiAgICAgIGFoMCA9IGJoNztcblxuICAgICAgYWwxID0gYmwwO1xuICAgICAgYWwyID0gYmwxO1xuICAgICAgYWwzID0gYmwyO1xuICAgICAgYWw0ID0gYmwzO1xuICAgICAgYWw1ID0gYmw0O1xuICAgICAgYWw2ID0gYmw1O1xuICAgICAgYWw3ID0gYmw2O1xuICAgICAgYWwwID0gYmw3O1xuXG4gICAgICBpZiAoaSUxNiA9PT0gMTUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICBoID0gd2hbal07XG4gICAgICAgICAgbCA9IHdsW2pdO1xuXG4gICAgICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAgICAgaCA9IHdoWyhqKzkpJTE2XTtcbiAgICAgICAgICBsID0gd2xbKGorOSklMTZdO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMFxuICAgICAgICAgIHRoID0gd2hbKGorMSklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMSklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxKSB8ICh0bCA8PCAoMzItMSkpKSBeICgodGggPj4+IDgpIHwgKHRsIDw8ICgzMi04KSkpIF4gKHRoID4+PiA3KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMSkgfCAodGggPDwgKDMyLTEpKSkgXiAoKHRsID4+PiA4KSB8ICh0aCA8PCAoMzItOCkpKSBeICgodGwgPj4+IDcpIHwgKHRoIDw8ICgzMi03KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMVxuICAgICAgICAgIHRoID0gd2hbKGorMTQpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzE0KSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDE5KSB8ICh0bCA8PCAoMzItMTkpKSkgXiAoKHRsID4+PiAoNjEtMzIpKSB8ICh0aCA8PCAoMzItKDYxLTMyKSkpKSBeICh0aCA+Pj4gNik7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDE5KSB8ICh0aCA8PCAoMzItMTkpKSkgXiAoKHRoID4+PiAoNjEtMzIpKSB8ICh0bCA8PCAoMzItKDYxLTMyKSkpKSBeICgodGwgPj4+IDYpIHwgKHRoIDw8ICgzMi02KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICAgICAgd2hbal0gPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICAgICAgd2xbal0gPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGRcbiAgICBoID0gYWgwO1xuICAgIGwgPSBhbDA7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMF07XG4gICAgbCA9IGhsWzBdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMF0gPSBhaDAgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMF0gPSBhbDAgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgxO1xuICAgIGwgPSBhbDE7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMV07XG4gICAgbCA9IGhsWzFdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMV0gPSBhaDEgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMV0gPSBhbDEgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgyO1xuICAgIGwgPSBhbDI7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMl07XG4gICAgbCA9IGhsWzJdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMl0gPSBhaDIgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMl0gPSBhbDIgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgzO1xuICAgIGwgPSBhbDM7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbM107XG4gICAgbCA9IGhsWzNdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbM10gPSBhaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbM10gPSBhbDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg0O1xuICAgIGwgPSBhbDQ7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNF07XG4gICAgbCA9IGhsWzRdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNF0gPSBhaDQgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNF0gPSBhbDQgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg1O1xuICAgIGwgPSBhbDU7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNV07XG4gICAgbCA9IGhsWzVdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNV0gPSBhaDUgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNV0gPSBhbDUgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg2O1xuICAgIGwgPSBhbDY7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNl07XG4gICAgbCA9IGhsWzZdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNl0gPSBhaDYgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNl0gPSBhbDYgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg3O1xuICAgIGwgPSBhbDc7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbN107XG4gICAgbCA9IGhsWzddO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbN10gPSBhaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbN10gPSBhbDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBwb3MgKz0gMTI4O1xuICAgIG4gLT0gMTI4O1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoKG91dCwgbSwgbikge1xuICB2YXIgaGggPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIGhsID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICB4ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSxcbiAgICAgIGksIGIgPSBuO1xuXG4gIGhoWzBdID0gMHg2YTA5ZTY2NztcbiAgaGhbMV0gPSAweGJiNjdhZTg1O1xuICBoaFsyXSA9IDB4M2M2ZWYzNzI7XG4gIGhoWzNdID0gMHhhNTRmZjUzYTtcbiAgaGhbNF0gPSAweDUxMGU1MjdmO1xuICBoaFs1XSA9IDB4OWIwNTY4OGM7XG4gIGhoWzZdID0gMHgxZjgzZDlhYjtcbiAgaGhbN10gPSAweDViZTBjZDE5O1xuXG4gIGhsWzBdID0gMHhmM2JjYzkwODtcbiAgaGxbMV0gPSAweDg0Y2FhNzNiO1xuICBobFsyXSA9IDB4ZmU5NGY4MmI7XG4gIGhsWzNdID0gMHg1ZjFkMzZmMTtcbiAgaGxbNF0gPSAweGFkZTY4MmQxO1xuICBobFs1XSA9IDB4MmIzZTZjMWY7XG4gIGhsWzZdID0gMHhmYjQxYmQ2YjtcbiAgaGxbN10gPSAweDEzN2UyMTc5O1xuXG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbik7XG4gIG4gJT0gMTI4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSBtW2ItbitpXTtcbiAgeFtuXSA9IDEyODtcblxuICBuID0gMjU2LTEyOCoobjwxMTI/MTowKTtcbiAgeFtuLTldID0gMDtcbiAgdHM2NCh4LCBuLTgsICAoYiAvIDB4MjAwMDAwMDApIHwgMCwgYiA8PCAzKTtcbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCB4LCBuKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB0czY0KG91dCwgOCppLCBoaFtpXSwgaGxbaV0pO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhZGQocCwgcSkge1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksXG4gICAgICBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuXG4gIFooYSwgcFsxXSwgcFswXSk7XG4gIFoodCwgcVsxXSwgcVswXSk7XG4gIE0oYSwgYSwgdCk7XG4gIEEoYiwgcFswXSwgcFsxXSk7XG4gIEEodCwgcVswXSwgcVsxXSk7XG4gIE0oYiwgYiwgdCk7XG4gIE0oYywgcFszXSwgcVszXSk7XG4gIE0oYywgYywgRDIpO1xuICBNKGQsIHBbMl0sIHFbMl0pO1xuICBBKGQsIGQsIGQpO1xuICBaKGUsIGIsIGEpO1xuICBaKGYsIGQsIGMpO1xuICBBKGcsIGQsIGMpO1xuICBBKGgsIGIsIGEpO1xuXG4gIE0ocFswXSwgZSwgZik7XG4gIE0ocFsxXSwgaCwgZyk7XG4gIE0ocFsyXSwgZywgZik7XG4gIE0ocFszXSwgZSwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzd2FwKHAsIHEsIGIpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrKHIsIHApIHtcbiAgdmFyIHR4ID0gZ2YoKSwgdHkgPSBnZigpLCB6aSA9IGdmKCk7XG4gIGludjI1NTE5KHppLCBwWzJdKTtcbiAgTSh0eCwgcFswXSwgemkpO1xuICBNKHR5LCBwWzFdLCB6aSk7XG4gIHBhY2syNTUxOShyLCB0eSk7XG4gIHJbMzFdIF49IHBhcjI1NTE5KHR4KSA8PCA3O1xufVxuXG5mdW5jdGlvbiBzY2FsYXJtdWx0KHAsIHEsIHMpIHtcbiAgdmFyIGIsIGk7XG4gIHNldDI1NTE5KHBbMF0sIGdmMCk7XG4gIHNldDI1NTE5KHBbMV0sIGdmMSk7XG4gIHNldDI1NTE5KHBbMl0sIGdmMSk7XG4gIHNldDI1NTE5KHBbM10sIGdmMCk7XG4gIGZvciAoaSA9IDI1NTsgaSA+PSAwOyAtLWkpIHtcbiAgICBiID0gKHNbKGkvOCl8MF0gPj4gKGkmNykpICYgMTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgICBhZGQocSwgcCk7XG4gICAgYWRkKHAsIHApO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICB2YXIgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgc2V0MjU1MTkocVswXSwgWCk7XG4gIHNldDI1NTE5KHFbMV0sIFkpO1xuICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICBNKHFbM10sIFgsIFkpO1xuICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgdmFyIGk7XG5cbiAgaWYgKCFzZWVkZWQpIHJhbmRvbWJ5dGVzKHNrLCAzMik7XG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHNjYWxhcmJhc2UocCwgZCk7XG4gIHBhY2socGssIHApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpKzMyXSA9IHBrW2ldO1xuICByZXR1cm4gMDtcbn1cblxudmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFsweGVkLCAweGQzLCAweGY1LCAweDVjLCAweDFhLCAweDYzLCAweDEyLCAweDU4LCAweGQ2LCAweDljLCAweGY3LCAweGEyLCAweGRlLCAweGY5LCAweGRlLCAweDE0LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDEwXSk7XG5cbmZ1bmN0aW9uIG1vZEwociwgeCkge1xuICB2YXIgY2FycnksIGksIGosIGs7XG4gIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChqID0gaSAtIDMyLCBrID0gaSAtIDEyOyBqIDwgazsgKytqKSB7XG4gICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgY2FycnkgPSAoeFtqXSArIDEyOCkgPj4gODtcbiAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgfVxuICAgIHhbal0gKz0gY2Fycnk7XG4gICAgeFtpXSA9IDA7XG4gIH1cbiAgY2FycnkgPSAwO1xuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgIHhbal0gKz0gY2FycnkgLSAoeFszMV0gPj4gNCkgKiBMW2pdO1xuICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgIHhbal0gJj0gMjU1O1xuICB9XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB4W2krMV0gKz0geFtpXSA+PiA4O1xuICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShyKSB7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHJbaV0gPSAwO1xuICBtb2RMKHIsIHgpO1xufVxuXG4vLyBOb3RlOiBkaWZmZXJlbmNlIGZyb20gQyAtIHNtbGVuIHJldHVybmVkLCBub3QgcGFzc2VkIGFzIGFyZ3VtZW50LlxuZnVuY3Rpb24gY3J5cHRvX3NpZ24oc20sIG0sIG4sIHNrKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCByID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgaSwgaiwgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHNtWzY0ICsgaV0gPSBtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcblxuICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4rMzIpO1xuICByZWR1Y2Uocik7XG4gIHNjYWxhcmJhc2UocCwgcik7XG4gIHBhY2soc20sIHApO1xuXG4gIGZvciAoaSA9IDMyOyBpIDwgNjQ7IGkrKykgc21baV0gPSBza1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgc20sIG4gKyA2NCk7XG4gIHJlZHVjZShoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpK2pdICs9IGhbaV0gKiBkW2pdO1xuICAgIH1cbiAgfVxuXG4gIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgcmV0dXJuIHNtbGVuO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksXG4gICAgICBkZW4gPSBnZigpLCBkZW4yID0gZ2YoKSwgZGVuNCA9IGdmKCksXG4gICAgICBkZW42ID0gZ2YoKTtcblxuICBzZXQyNTUxOShyWzJdLCBnZjEpO1xuICB1bnBhY2syNTUxOShyWzFdLCBwKTtcbiAgUyhudW0sIHJbMV0pO1xuICBNKGRlbiwgbnVtLCBEKTtcbiAgWihudW0sIG51bSwgclsyXSk7XG4gIEEoZGVuLCByWzJdLCBkZW4pO1xuXG4gIFMoZGVuMiwgZGVuKTtcbiAgUyhkZW40LCBkZW4yKTtcbiAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgTSh0LCBkZW42LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG5cbiAgcG93MjUyMyh0LCB0KTtcbiAgTSh0LCB0LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0odCwgdCwgZGVuKTtcbiAgTShyWzBdLCB0LCBkZW4pO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgTShyWzBdLCByWzBdLCBJKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcblxuICBpZiAocGFyMjU1MTkoclswXSkgPT09IChwWzMxXT4+NykpIFooclswXSwgZ2YwLCByWzBdKTtcblxuICBNKHJbM10sIHJbMF0sIHJbMV0pO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgbiwgcGspIHtcbiAgdmFyIGksIG1sZW47XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSxcbiAgICAgIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgbWxlbiA9IC0xO1xuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIG1sZW4gPSBuO1xuICByZXR1cm4gbWxlbjtcbn1cblxudmFyIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCxcbiAgICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTID0gMTYsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9OT05DRUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICAgIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gICAgY3J5cHRvX2JveF9CT1haRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgICBjcnlwdG9fc2lnbl9CWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9TRUVEQllURVMgPSAzMixcbiAgICBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuXG5uYWNsLmxvd2xldmVsID0ge1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMDogY3J5cHRvX2NvcmVfaHNhbHNhMjAsXG4gIGNyeXB0b19zdHJlYW1feG9yOiBjcnlwdG9fc3RyZWFtX3hvcixcbiAgY3J5cHRvX3N0cmVhbTogY3J5cHRvX3N0cmVhbSxcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcjogY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcixcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAsXG4gIGNyeXB0b19vbmV0aW1lYXV0aDogY3J5cHRvX29uZXRpbWVhdXRoLFxuICBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5OiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5LFxuICBjcnlwdG9fdmVyaWZ5XzE2OiBjcnlwdG9fdmVyaWZ5XzE2LFxuICBjcnlwdG9fdmVyaWZ5XzMyOiBjcnlwdG9fdmVyaWZ5XzMyLFxuICBjcnlwdG9fc2VjcmV0Ym94OiBjcnlwdG9fc2VjcmV0Ym94LFxuICBjcnlwdG9fc2VjcmV0Ym94X29wZW46IGNyeXB0b19zZWNyZXRib3hfb3BlbixcbiAgY3J5cHRvX3NjYWxhcm11bHQ6IGNyeXB0b19zY2FsYXJtdWx0LFxuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlOiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlLFxuICBjcnlwdG9fYm94X2JlZm9yZW5tOiBjcnlwdG9fYm94X2JlZm9yZW5tLFxuICBjcnlwdG9fYm94X2FmdGVybm06IGNyeXB0b19ib3hfYWZ0ZXJubSxcbiAgY3J5cHRvX2JveDogY3J5cHRvX2JveCxcbiAgY3J5cHRvX2JveF9vcGVuOiBjcnlwdG9fYm94X29wZW4sXG4gIGNyeXB0b19ib3hfa2V5cGFpcjogY3J5cHRvX2JveF9rZXlwYWlyLFxuICBjcnlwdG9faGFzaDogY3J5cHRvX2hhc2gsXG4gIGNyeXB0b19zaWduOiBjcnlwdG9fc2lnbixcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcjogY3J5cHRvX3NpZ25fa2V5cGFpcixcbiAgY3J5cHRvX3NpZ25fb3BlbjogY3J5cHRvX3NpZ25fb3BlbixcblxuICBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM6IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTLFxuICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM6IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyxcbiAgY3J5cHRvX2JveF9OT05DRUJZVEVTOiBjcnlwdG9fYm94X05PTkNFQllURVMsXG4gIGNyeXB0b19ib3hfWkVST0JZVEVTOiBjcnlwdG9fYm94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX2JveF9CT1haRVJPQllURVM6IGNyeXB0b19ib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2lnbl9CWVRFUzogY3J5cHRvX3NpZ25fQllURVMsXG4gIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM6IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUVEQllURVM6IGNyeXB0b19zaWduX1NFRURCWVRFUyxcbiAgY3J5cHRvX2hhc2hfQllURVM6IGNyeXB0b19oYXNoX0JZVEVTXG59O1xuXG4vKiBIaWdoLWxldmVsIEFQSSAqL1xuXG5mdW5jdGlvbiBjaGVja0xlbmd0aHMoaywgbikge1xuICBpZiAoay5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIGtleSBzaXplJyk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBub25jZSBzaXplJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94TGVuZ3Rocyhwaywgc2spIHtcbiAgaWYgKHBrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIGlmIChzay5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0FycmF5VHlwZXMoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCEoYXJndW1lbnRzW2ldIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUsIHVzZSBVaW50OEFycmF5Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW51cChhcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycltpXSA9IDA7XG59XG5cbm5hY2wucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIHJhbmRvbWJ5dGVzKGIsIG4pO1xuICByZXR1cm4gYjtcbn07XG5cbm5hY2wuc2VjcmV0Ym94ID0gZnVuY3Rpb24obXNnLCBub25jZSwga2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIG5vbmNlLCBrZXkpO1xuICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBtW2krY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVNdID0gbXNnW2ldO1xuICBjcnlwdG9fc2VjcmV0Ym94KGMsIG0sIG0ubGVuZ3RoLCBub25jZSwga2V5KTtcbiAgcmV0dXJuIGMuc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gub3BlbiA9IGZ1bmN0aW9uKGJveCwgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMoYm94LCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTICsgYm94Lmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKykgY1tpK2NyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTXSA9IGJveFtpXTtcbiAgaWYgKGMubGVuZ3RoIDwgMzIpIHJldHVybiBudWxsO1xuICBpZiAoY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sIGMsIGMubGVuZ3RoLCBub25jZSwga2V5KSAhPT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94LmtleUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM7XG5uYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM7XG5cbm5hY2wuc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4sIHApO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgaWYgKHAubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcCBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuYmFzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4pO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbik7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LnNjYWxhckxlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTO1xubmFjbC5zY2FsYXJNdWx0Lmdyb3VwRWxlbWVudExlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTO1xuXG5uYWNsLmJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94KG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3guYmVmb3JlID0gZnVuY3Rpb24ocHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgY2hlY2tCb3hMZW5ndGhzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X0JFRk9SRU5NQllURVMpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIGs7XG59O1xuXG5uYWNsLmJveC5hZnRlciA9IG5hY2wuc2VjcmV0Ym94O1xuXG5uYWNsLmJveC5vcGVuID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gub3Blbihtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94Lm9wZW4uYWZ0ZXIgPSBuYWNsLnNlY3JldGJveC5vcGVuO1xuXG5uYWNsLmJveC5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX2JveF9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSl9O1xufTtcblxubmFjbC5ib3gucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUztcbm5hY2wuYm94LnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM7XG5uYWNsLmJveC5zaGFyZWRLZXlMZW5ndGggPSBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM7XG5uYWNsLmJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19ib3hfTk9OQ0VCWVRFUztcbm5hY2wuYm94Lm92ZXJoZWFkTGVuZ3RoID0gbmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGg7XG5cbm5hY2wuc2lnbiA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHNpZ25lZE1zZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTK21zZy5sZW5ndGgpO1xuICBjcnlwdG9fc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHNpZ25lZE1zZztcbn07XG5cbm5hY2wuc2lnbi5vcGVuID0gZnVuY3Rpb24oc2lnbmVkTXNnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNpZ25lZE1zZywgcHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmVkTXNnLmxlbmd0aCk7XG4gIHZhciBtbGVuID0gY3J5cHRvX3NpZ25fb3Blbih0bXAsIHNpZ25lZE1zZywgc2lnbmVkTXNnLmxlbmd0aCwgcHVibGljS2V5KTtcbiAgaWYgKG1sZW4gPCAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShtbGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBtW2ldID0gdG1wW2ldO1xuICByZXR1cm4gbTtcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZCA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIHZhciBzaWduZWRNc2cgPSBuYWNsLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICB2YXIgc2lnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykgc2lnW2ldID0gc2lnbmVkTXNnW2ldO1xuICByZXR1cm4gc2lnO1xufTtcblxubmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeSA9IGZ1bmN0aW9uKG1zZywgc2lnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2lnLCBwdWJsaWNLZXkpO1xuICBpZiAoc2lnLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2lnbmF0dXJlIHNpemUnKTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgc20gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgY3J5cHRvX3NpZ25fQllURVM7IGkrKykgc21baV0gPSBzaWdbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHNtW2krY3J5cHRvX3NpZ25fQllURVNdID0gbXNnW2ldO1xuICByZXR1cm4gKGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwKTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7IGkrKykgcGtbaV0gPSBzZWNyZXRLZXlbMzIraV07XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkID0gZnVuY3Rpb24oc2VlZCkge1xuICBjaGVja0FycmF5VHlwZXMoc2VlZCk7XG4gIGlmIChzZWVkLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VFREJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlZWQgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpXSA9IHNlZWRbaV07XG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCB0cnVlKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuc2lnbi5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWVkTGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VFREJZVEVTO1xubmFjbC5zaWduLnNpZ25hdHVyZUxlbmd0aCA9IGNyeXB0b19zaWduX0JZVEVTO1xuXG5uYWNsLmhhc2ggPSBmdW5jdGlvbihtc2cpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZyk7XG4gIHZhciBoID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2hhc2hfQllURVMpO1xuICBjcnlwdG9faGFzaChoLCBtc2csIG1zZy5sZW5ndGgpO1xuICByZXR1cm4gaDtcbn07XG5cbm5hY2wuaGFzaC5oYXNoTGVuZ3RoID0gY3J5cHRvX2hhc2hfQllURVM7XG5cbm5hY2wudmVyaWZ5ID0gZnVuY3Rpb24oeCwgeSkge1xuICBjaGVja0FycmF5VHlwZXMoeCwgeSk7XG4gIC8vIFplcm8gbGVuZ3RoIGFyZ3VtZW50cyBhcmUgY29uc2lkZXJlZCBub3QgZXF1YWwuXG4gIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodm4oeCwgMCwgeSwgMCwgeC5sZW5ndGgpID09PSAwKSA/IHRydWUgOiBmYWxzZTtcbn07XG5cbm5hY2wuc2V0UFJORyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJhbmRvbWJ5dGVzID0gZm47XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIEluaXRpYWxpemUgUFJORyBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBDU1BSTkcuXG4gIC8vIElmIG5vdCwgbWV0aG9kcyBjYWxsaW5nIHJhbmRvbWJ5dGVzIHdpbGwgdGhyb3cuXG4gIHZhciBjcnlwdG8gPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyAoc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0bykgOiBudWxsO1xuICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBCcm93c2Vycy5cbiAgICB2YXIgUVVPVEEgPSA2NTUzNjtcbiAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgdmFyIGksIHYgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IFFVT1RBKSB7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModi5zdWJhcnJheShpLCBpICsgTWF0aC5taW4obiAtIGksIFFVT1RBKSkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICBjbGVhbnVwKHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vZGUuanMuXG4gICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICAgIHZhciBpLCB2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gdltpXTtcbiAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcblxufSkodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA6IChzZWxmLm5hY2wgPSBzZWxmLm5hY2wgfHwge30pKTtcbiIsImNvbnN0IGFkZHJlc3MgPSByZXF1aXJlKFwiLi9lbmNvZGluZy9hZGRyZXNzXCIpO1xuY29uc3QgZW5jb2RpbmcgPSByZXF1aXJlKFwiLi9lbmNvZGluZy9lbmNvZGluZ1wiKTtcbmNvbnN0IG5hY2wgPSByZXF1aXJlKFwiLi9uYWNsL25hY2xXcmFwcGVyc1wiKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvdXRpbHNcIik7XG5cbi8qKlxuICogQmlkIGVuYWJsZXMgY29uc3RydWN0aW9uIG9mIEFsZ29yYW5kIEF1Y3Rpb25zIEJpZHNcbiAqICovXG5jbGFzcyBCaWQge1xuICAgIGNvbnN0cnVjdG9yKHtiaWRkZXJLZXksIGJpZEFtb3VudCwgbWF4UHJpY2UsIGJpZElELCBhdWN0aW9uS2V5LCBhdWN0aW9uSUR9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQmlkXCI7XG4gICAgICAgIHRoaXMudGFnID0gQnVmZmVyLmZyb20oWzk3LCA2Nl0pOyAvLyBcImFCXCJcblxuICAgICAgICBiaWRkZXJLZXkgPSBhZGRyZXNzLmRlY29kZShiaWRkZXJLZXkpO1xuICAgICAgICBhdWN0aW9uS2V5ID0gYWRkcmVzcy5kZWNvZGUoYXVjdGlvbktleSk7XG5cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihiaWRBbW91bnQpIHx8IGJpZEFtb3VudCA8IDApIHRocm93IEVycm9yKFwiQmlkIGFtb3VudCBtdXN0IGJlIHBvc2l0aXZlIGFuZCAyXjUzLTFcIik7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYmlkSUQpIHx8IGJpZElEIDwgMCkgdGhyb3cgRXJyb3IoXCJCaWRJRCBtdXN0IGJlIHBvc2l0aXZlIGFuZCAyXjUzLTFcIik7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXVjdGlvbklEKSB8fCBhdWN0aW9uSUQgPCAwKSB0aHJvdyBFcnJvcihcImF1Y3Rpb25JRCBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgYmlkZGVyS2V5LCBhdWN0aW9uS2V5LCBiaWRBbW91bnQsIG1heFByaWNlLCBiaWRJRCwgYXVjdGlvbklELFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRfb2JqX2Zvcl9lbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiYmlkZGVyXCI6IEJ1ZmZlci5mcm9tKHRoaXMuYmlkZGVyS2V5LnB1YmxpY0tleSksXG4gICAgICAgICAgICBcImN1clwiOiB0aGlzLmJpZEFtb3VudCxcbiAgICAgICAgICAgIFwicHJpY2VcIjogdGhpcy5tYXhQcmljZSxcbiAgICAgICAgICAgIFwiaWRcIjogdGhpcy5iaWRJRCxcbiAgICAgICAgICAgIFwiYXVjXCI6IEJ1ZmZlci5mcm9tKHRoaXMuYXVjdGlvbktleS5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgXCJhaWRcIjogdGhpcy5hdWN0aW9uSUQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbkJpZChzaykge1xuICAgICAgICBjb25zdCBlbmNvZGVkTXNnID0gZW5jb2RpbmcuZW5jb2RlKHRoaXMuZ2V0X29ial9mb3JfZW5jb2RpbmcoKSk7XG4gICAgICAgIGNvbnN0IHRvQmVTaWduZWQgPSBCdWZmZXIuZnJvbSh1dGlscy5jb25jYXRBcnJheXModGhpcy50YWcsIGVuY29kZWRNc2cpKTtcbiAgICAgICAgY29uc3Qgc2lnID0gbmFjbC5zaWduKHRvQmVTaWduZWQsIHNrKTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3Qgc2lnbmVkIG1lc3NhZ2VcbiAgICAgICAgbGV0IHNCaWQgPSB7XG4gICAgICAgICAgICBcInNpZ1wiOiBCdWZmZXIuZnJvbShzaWcpLFxuICAgICAgICAgICAgXCJiaWRcIjogdGhpcy5nZXRfb2JqX2Zvcl9lbmNvZGluZygpLFxuXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IG5vdGUgPSB7XG4gICAgICAgICAgICBcInRcIjogXCJiXCIsXG4gICAgICAgICAgICBcImJcIjogc0JpZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jb2RpbmcuZW5jb2RlKG5vdGUpKTtcbiAgICB9XG5cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtCaWR9OyIsImNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG5cbmZ1bmN0aW9uIEFsZ29kKHRva2VuID0gJycsIGJhc2VTZXJ2ZXIgPSBcImh0dHA6Ly9yMi5hbGdvcmFuZC5uZXR3b3JrXCIsIHBvcnQgPSA0MTgwLCBoZWFkZXJzID0ge30pIHtcbiAgICAvLyB3b3JrYXJvdW5kIHRvIGFsbG93IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtdWx0aXBsZSBoZWFkZXJzXG4gICAgbGV0IHRva2VuSGVhZGVyID0gdG9rZW47XG4gICAgaWYgKHR5cGVvZiAodG9rZW5IZWFkZXIpID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VuSGVhZGVyID0ge1wiWC1BbGdvLUFQSS1Ub2tlblwiOiB0b2tlbkhlYWRlcn07XG4gICAgfVxuXG4gICAgLy8gR2V0IGNsaWVudFxuICAgIGxldCBjID0gbmV3IGNsaWVudC5IVFRQQ2xpZW50KHRva2VuSGVhZGVyLCBiYXNlU2VydmVyLCBwb3J0LCBoZWFkZXJzKTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIG9iamVjdCBhbmQgY29udmVydCBpdHMgbm90ZSBmaWVsZCB0byBCdWZmZXIsIGlmIGV4aXN0LlxuICAgICAqIEBwYXJhbSBvXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm90ZWI2NFRvTm90ZShvKSB7XG4gICAgICAgIGlmICghKG8ubm90ZWI2NCA9PT0gdW5kZWZpbmVkIHx8IG8ubm90ZWI2NCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIG8ubm90ZSA9IEJ1ZmZlci5mcm9tKG8ubm90ZWI2NCwgXCJiYXNlNjRcIilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0YXR1cyByZXRyaWV2ZXMgdGhlIFN0YXR1c1Jlc3BvbnNlIGZyb20gdGhlIHJ1bm5pbmcgbm9kZVxuICAgICAqIEBwYXJhbSBoZWFkZXJzLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdHVzID0gYXN5bmMgZnVuY3Rpb24gKGhlYWRlcnM9e30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMuZ2V0KFwiL3YxL3N0YXR1c1wiLCB7fSwgaGVhZGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGhlYWx0aENoZWNrIHJldHVybnMgYW4gZW1wdHkgb2JqZWN0IGlmZiB0aGUgbm9kZSBpcyBydW5uaW5nXG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5oZWFsdGhDaGVjayA9IGFzeW5jIGZ1bmN0aW9uIChoZWFkZXJzPXt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBjLmdldChcIi9oZWFsdGhcIiwge30sIGhlYWRlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzdGF0dXNBZnRlckJsb2NrIHdhaXRzIGZvciByb3VuZCByb3VuZE51bWJlciB0byBvY2N1ciB0aGVuIHJldHVybnMgdGhlIFN0YXR1c1Jlc3BvbnNlIGZvciB0aGlzIHJvdW5kLlxuICAgICAqIFRoaXMgY2FsbCBibG9ja3NcbiAgICAgKiBAcGFyYW0gcm91bmROdW1iZXJcbiAgICAgKiBAcGFyYW0gaGVhZGVycywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXR1c0FmdGVyQmxvY2sgPSBhc3luYyBmdW5jdGlvbiAocm91bmROdW1iZXIsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJvdW5kTnVtYmVyKSkgdGhyb3cgRXJyb3IoXCJyb3VuZE51bWJlciBzaG91bGQgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMuZ2V0KFwiL3YxL3N0YXR1cy93YWl0LWZvci1ibG9jay1hZnRlci9cIiArIHJvdW5kTnVtYmVyLCB7fSwgaGVhZGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHBlbmRpbmdUcmFuc2FjdGlvbnMgYXNrcyBhbGdvZCBmb3IgYSBzbmFwc2hvdCBvZiBjdXJyZW50IHBlbmRpbmcgdHhucyBvbiB0aGUgbm9kZSwgYm91bmRlZCBieSBtYXhUeG5zLlxuICAgICAqIElmIG1heFR4bnMgPSAwLCBmZXRjaGVzIGFzIG1hbnkgdHJhbnNhY3Rpb25zIGFzIHBvc3NpYmxlLlxuICAgICAqIEBwYXJhbSBtYXhUeG5zIG51bWJlclxuICAgICAqIEBwYXJhbSBoZWFkZXJzLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyA9IGFzeW5jIGZ1bmN0aW9uIChtYXhUeG5zLCBoZWFkZXJzPXt9KSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUeG5zKSkgdGhyb3cgRXJyb3IoXCJtYXhUeG5zIHNob3VsZCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgYy5nZXQoXCIvdjEvdHJhbnNhY3Rpb25zL3BlbmRpbmdcIiwgeyAnbWF4JzogbWF4VHhucyB9LCBoZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDAgJiYgcmVzLmJvZHkudHJ1bmNhdGVkVHhucy50cmFuc2FjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMuYm9keS50cnVuY2F0ZWRUeG5zLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5ib2R5LnRydW5jYXRlZFR4bnMudHJhbnNhY3Rpb25zW2ldID0gbm90ZWI2NFRvTm90ZShyZXMuYm9keS50cnVuY2F0ZWRUeG5zLnRyYW5zYWN0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdmVyc2lvbnMgcmV0cmlldmVzIHRoZSBWZXJzaW9uUmVzcG9uc2UgZnJvbSB0aGUgcnVubmluZyBub2RlXG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9ucyA9IGFzeW5jIGZ1bmN0aW9uIChoZWFkZXJzPXt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBjLmdldChcIi92ZXJzaW9uc1wiLCB7fSwgaGVhZGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExlZGdlclN1cHBseSBnZXRzIHRoZSBzdXBwbHkgZGV0YWlscyBmb3IgdGhlIHNwZWNpZmllZCBub2RlJ3MgTGVkZ2VyXG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5sZWRnZXJTdXBwbHkgPSBhc3luYyBmdW5jdGlvbiAoaGVhZGVycz17fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYy5nZXQoXCIvdjEvbGVkZ2VyL3N1cHBseVwiLCB7fSwgaGVhZGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRyYW5zYWN0aW9uc0J5QWRkcmVzcyByZXR1cm5zIGFsbCB0cmFuc2FjdGlvbnMgZm9yIGEgUEsgW2FkZHJdIGluIHRoZSBbZmlyc3QsIGxhc3RdIHJvdW5kcyByYW5nZS5cbiAgICAgKiBAcGFyYW0gYWRkciBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZmlyc3QgbnVtYmVyLCBvcHRpb25hbFxuICAgICAqIEBwYXJhbSBsYXN0IG51bWJlciwgb3B0aW9uYWxcbiAgICAgKiBAcGFyYW0gbWF4VHhucyBudW1iZXIsIG9wdGlvbmFsXG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy50cmFuc2FjdGlvbkJ5QWRkcmVzcyA9IGFzeW5jIGZ1bmN0aW9uIChhZGRyLCBmaXJzdD1udWxsLCBsYXN0PW51bGwsIG1heFR4bnM9bnVsbCwgaGVhZGVycz17fSkge1xuXG4gICAgICAgIGlmICgoIGZpcnN0ICE9PSBudWxsICkgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGZpcnN0KSApKXtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZmlyc3Qgcm91bmQgc2hvdWxkIGJlIGFuIGludGVnZXJcIilcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCBsYXN0ICE9PSBudWxsICkgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxhc3QpICkpe1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJsYXN0IHJvdW5kIHNob3VsZCBiZSBhbiBpbnRlZ2VyXCIpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGMuZ2V0KFwiL3YxL2FjY291bnQvXCIgKyBhZGRyICsgXCIvdHJhbnNhY3Rpb25zXCIsIHsgJ2ZpcnN0Um91bmQnOiBmaXJzdCwgJ2xhc3RSb3VuZCc6IGxhc3QsICdtYXgnOiBtYXhUeG5zIH0sIGhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCAmJiByZXMuYm9keS50cmFuc2FjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMuYm9keS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuYm9keS50cmFuc2FjdGlvbnNbaV0gPSBub3RlYjY0VG9Ob3RlKHJlcy5ib2R5LnRyYW5zYWN0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHJhbnNhY3Rpb25zQnlBZGRyZXNzQW5kRGF0ZSByZXR1cm5zIGFsbCB0cmFuc2FjdGlvbnMgZm9yIGEgUEsgW2FkZHJdIGluIHRoZSBbZnJvbURhdGUsIHRvRGF0ZV0gZGF0ZSByYW5nZS4gXG4gICAgICogVGhlIGRhdGUgaXMgYSBzdHJpbmcgaW4gdGhlIFlZWVktTU0tREQgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBhZGRyIHN0cmluZ1xuICAgICAqIEBwYXJhbSBmcm9tRGF0ZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdG9EYXRlIHN0cmluZ1xuICAgICAqIEBwYXJhbSBtYXhUeG5zIG51bWJlciwgb3B0aW9uYWxcbiAgICAgKiBAcGFyYW0gaGVhZGVycywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zYWN0aW9uQnlBZGRyZXNzQW5kRGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIChhZGRyLCBmcm9tRGF0ZSwgdG9EYXRlLCBtYXhUeG5zPW51bGwsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGMuZ2V0KFwiL3YxL2FjY291bnQvXCIgKyBhZGRyICsgXCIvdHJhbnNhY3Rpb25zXCIsIHsgJ2Zyb21EYXRlJzogZnJvbURhdGUsICd0b0RhdGUnOiB0b0RhdGUsICdtYXgnOiBtYXhUeG5zIH0sIGhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCAmJiByZXMuYm9keS50cmFuc2FjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMuYm9keS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuYm9keS50cmFuc2FjdGlvbnNbaV0gPSBub3RlYjY0VG9Ob3RlKHJlcy5ib2R5LnRyYW5zYWN0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHJhbnNhY3Rpb25CeUlkIHJldHVybnMgdGhlIGEgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gb2YgYSBzcGVjaWZpYyB0eGlkIFt0eElkXVxuICAgICAqIE5vdGUgLSBUaGlzIG1ldGhvZCBpcyBhbGxvd2VkIG9ubHkgd2hlbiBJbmRleGVyIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIHR4aWRcbiAgICAgKiBAcGFyYW0gaGVhZGVycywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zYWN0aW9uQnlJZCA9IGFzeW5jIGZ1bmN0aW9uICh0eGlkLCBoZWFkZXJzPXt9KSB7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBjLmdldChcIi92MS90cmFuc2FjdGlvbi9cIiArIHR4aWQsIHt9LCBoZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlcy5ib2R5ID0gbm90ZWI2NFRvTm90ZShyZXMuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHJhbnNhY3Rpb25JbmZvcm1hdGlvbiByZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvbiBvZiBhIHNwZWNpZmljIHR4aWQgYW5kIGFuIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gYWRkclxuICAgICAqIEBwYXJhbSB0eGlkXG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy50cmFuc2FjdGlvbkluZm9ybWF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGFkZHIsIHR4aWQsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGMuZ2V0KFwiL3YxL2FjY291bnQvXCIgKyBhZGRyICsgXCIvdHJhbnNhY3Rpb24vXCIgKyB0eGlkLCB7fSwgaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXMuYm9keSA9IG5vdGViNjRUb05vdGUocmVzLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHBlbmRpbmdUcmFuc2FjdGlvbkluZm9ybWF0aW9uIHJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGluZm9ybWF0aW9uIGZvciBhIHNwZWNpZmljIHR4aWQgb2YgYSBwZW5kaW5nIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHR4aWRcbiAgICAgKiBAcGFyYW0gaGVhZGVycywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbkluZm9ybWF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKHR4aWQsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGMuZ2V0KFwiL3YxL3RyYW5zYWN0aW9ucy9wZW5kaW5nL1wiICsgdHhpZCwge30sIGhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzLmJvZHkgPSBub3RlYjY0VG9Ob3RlKHJlcy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhY2NvdW50SW5mb3JtYXRpb24gcmV0dXJucyB0aGUgcGFzc2VkIGFjY291bnQncyBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBhZGRyIHN0cmluZ1xuICAgICAqIEBwYXJhbSBoZWFkZXJzLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuYWNjb3VudEluZm9ybWF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGFkZHIsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMuZ2V0KFwiL3YxL2FjY291bnQvXCIgKyBhZGRyLCB7fSwgaGVhZGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFzc2V0SW5mb3JtYXRpb24gcmV0dXJucyB0aGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhc3NldCB3aXRoIHRoZSBwYXNzZWQgY3JlYXRvciBhbmQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggbnVtYmVyXG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5hc3NldEluZm9ybWF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGluZGV4LCBoZWFkZXJzPXt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBjLmdldChcIi92MS9hc3NldC9cIiArIGluZGV4LCB7fSwgaGVhZGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHN1Z2dlc3RlZEZlZSBnZXRzIHRoZSByZWNvbW1lbmRlZCB0cmFuc2FjdGlvbiBmZWUgZnJvbSB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSBoZWFkZXJzLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuc3VnZ2VzdGVkRmVlID0gYXN5bmMgZnVuY3Rpb24gKGhlYWRlcnM9e30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMuZ2V0KFwiL3YxL3RyYW5zYWN0aW9ucy9mZWVcIiwge30sIGhlYWRlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZW5kUmF3VHJhbnNhY3Rpb24gZ2V0cyBhbiBlbmNvZGVkIFNpZ25lZFR4biBhbmQgYnJvYWRjYXN0cyBpdCB0byB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSB0eG4gVWluOEFycmF5XG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAodHhuLCBoZWFkZXJzPXt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvdHJhbnNhY3Rpb25zXCIsIEJ1ZmZlci5mcm9tKHR4biksIGhlYWRlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZW5kUmF3VHJhbnNhY3Rpb25zIGdldHMgYSBsaXN0IG9mIGVuY29kZWQgU2lnbmVkVHhucyBhbmQgYnJvYWRjYXN0cyBpdCB0byB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSB0eG4gQXJyYXkgb2YgVWluOEFycmF5XG4gICAgICogQHBhcmFtIGhlYWRlcnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb25zID0gYXN5bmMgZnVuY3Rpb24gKHR4bnMsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50eG5zLm1hcChhcnIgPT4gQXJyYXkuZnJvbShhcnIpKSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvdHJhbnNhY3Rpb25zXCIsIEJ1ZmZlci5mcm9tKG1lcmdlZCksIGhlYWRlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXRUcmFuc2FjdGlvblBhcmFtcyByZXR1cm5zIHRvIGNvbW1vbiBuZWVkZWQgcGFyYW1ldGVycyBmb3IgYSBuZXcgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gaGVhZGVycywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmdldFRyYW5zYWN0aW9uUGFyYW1zID0gYXN5bmMgZnVuY3Rpb24gKGhlYWRlcnM9e30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMuZ2V0KFwiL3YxL3RyYW5zYWN0aW9ucy9wYXJhbXNcIiwge30sIGhlYWRlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBibG9jayBnZXRzIHRoZSBibG9jayBpbmZvIGZvciB0aGUgZ2l2ZW4gcm91bmQgVGhpcyBjYWxsIGJsb2Nrc1xuICAgICAqIEBwYXJhbSByb3VuZE51bWJlclxuICAgICAqIEBwYXJhbSBoZWFkZXJzLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuYmxvY2sgPSBhc3luYyBmdW5jdGlvbiAocm91bmROdW1iZXIsIGhlYWRlcnM9e30pIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJvdW5kTnVtYmVyKSkgdGhyb3cgRXJyb3IoXCJyb3VuZE51bWJlciBzaG91bGQgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGMuZ2V0KFwiL3YxL2Jsb2NrL1wiICsgcm91bmROdW1iZXIsIHt9LCBoZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDAgJiYgcmVzLmJvZHkudHhucy50cmFuc2FjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMuYm9keS50eG5zLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5ib2R5LnR4bnMudHJhbnNhY3Rpb25zW2ldID0gbm90ZWI2NFRvTm90ZShyZXMuYm9keS50eG5zLnRyYW5zYWN0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7IEFsZ29kIH07XG4iLCJ2YXIgcmVxdWVzdCA9IHJlcXVpcmUoXCJzdXBlcmFnZW50XCIpO1xuXG4vKipcbiAqIHJlbW92ZUVtcHR5IGdldHMgYSBkaWN0aW9uYXJ5IGFuZCByZW1vdmVzIGVtcHR5IHZhbHVlc1xuICogQHBhcmFtIG9ialxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5KG9iaikge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIW9ialtrZXldIHx8IG9ialtrZXldLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIEhUVFBDbGllbnQodG9rZW4sIGJhc2VTZXJ2ZXIsIHBvcnQsIGhlYWRlcnM9e30pIHtcbiAgICAvLyBEbyBub3QgbmVlZCBjb2xvbiBpZiBwb3J0IGlzIGVtcHR5XG4gICAgaWYgKHBvcnQgIT09ICcnKSB7XG4gICAgICAgIGJhc2VTZXJ2ZXIgKz0gXCI6XCIgKyBwb3J0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuYWRkcmVzcyA9IGJhc2VTZXJ2ZXI7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuZGVmYXVsdEhlYWRlcnMgPSBoZWFkZXJzO1xuXG4gICAgdGhpcy5nZXQgPSBhc3luYyBmdW5jdGlvbiAocGF0aCwgcXVlcnksIHJlcXVlc3RIZWFkZXJzPXt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIC5nZXQodGhpcy5hZGRyZXNzICsgcGF0aClcbiAgICAgICAgICAgICAgICAuc2V0KHRoaXMudG9rZW4pXG4gICAgICAgICAgICAgICAgLnNldCh0aGlzLmRlZmF1bHRIZWFkZXJzKVxuICAgICAgICAgICAgICAgIC5zZXQocmVxdWVzdEhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgICAgICAgICAgICAgIC5xdWVyeShyZW1vdmVFbXB0eShxdWVyeSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucG9zdCA9IGFzeW5jIGZ1bmN0aW9uIChwYXRoLCBkYXRhLCByZXF1ZXN0SGVhZGVycz17fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAucG9zdCh0aGlzLmFkZHJlc3MgKyBwYXRoKVxuICAgICAgICAgICAgICAgIC5zZXQodGhpcy50b2tlbilcbiAgICAgICAgICAgICAgICAuc2V0KHRoaXMuZGVmYXVsdEhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLnNldChyZXF1ZXN0SGVhZGVycylcbiAgICAgICAgICAgICAgICAuc2VuZChkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZS5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmRlbGV0ZSA9IGFzeW5jIGZ1bmN0aW9uIChwYXRoLCBkYXRhLCByZXF1ZXN0SGVhZGVycz17fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAuZGVsZXRlKHRoaXMuYWRkcmVzcyArIHBhdGgpXG4gICAgICAgICAgICAgICAgLnNldCh0aGlzLnRva2VuKVxuICAgICAgICAgICAgICAgIC5zZXQodGhpcy5kZWZhdWx0SGVhZGVycylcbiAgICAgICAgICAgICAgICAuc2V0KHJlcXVlc3RIZWFkZXJzKVxuICAgICAgICAgICAgICAgIC5zZW5kKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEhUVFBDbGllbnQgfTsiLCJjb25zdCBjbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpO1xuY29uc3QgdHhuID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uXCIpO1xuXG5mdW5jdGlvbiBLbWQodG9rZW4sIGJhc2VTZXJ2ZXIgPSBcImh0dHA6Ly8xMjcuMC4wLjFcIiwgcG9ydCA9IDc4MzMpIHtcbiAgICAvLyBHZXQgY2xpZW50XG4gICAgbGV0IGMgPSBuZXcgY2xpZW50LkhUVFBDbGllbnQoeydYLUtNRC1BUEktVG9rZW4nOnRva2VufSwgYmFzZVNlcnZlciwgcG9ydCk7XG5cbiAgICAvKipcbiAgICAgKiB2ZXJzaW9uIHJldHVybnMgYSBWZXJzaW9uUmVzcG9uc2UgY29udGFpbmluZyBhIGxpc3Qgb2Yga21kIEFQSSB2ZXJzaW9ucyBzdXBwb3J0ZWQgYnkgdGhpcyBydW5uaW5nIGttZCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb25zID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYy5nZXQoXCIvdmVyc2lvbnNcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGxpc3RXYWxsZXRzIHJldHVybnMgYSBMaXN0V2FsbGV0c1Jlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGxpc3Qgb2Ygd2FsbGV0cyBrbm93biB0byBrbWQuIFVzaW5nIGEgd2FsbGV0IElEXG4gICAgICogcmV0dXJuZWQgZnJvbSB0aGlzIGVuZHBvaW50LCB5b3UgY2FuIGluaXRpYWxpemUgYSB3YWxsZXQgaGFuZGxlIHdpdGggY2xpZW50LkluaXRXYWxsZXRIYW5kbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RXYWxsZXRzID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYy5nZXQoXCIvdjEvd2FsbGV0c1wiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlV2FsbGV0IGNyZWF0ZXMgYSB3YWxsZXQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUsIHBhc3N3b3JkLCBkcml2ZXIsXG4gICAgICogYW5kIG1hc3RlciBkZXJpdmF0aW9uIGtleS4gSWYgdGhlIG1hc3RlciBkZXJpdmF0aW9uIGtleSBpcyBibGFuaywgb25lIGlzXG4gICAgICogZ2VuZXJhdGVkIGludGVybmFsbHkgdG8ga21kLiBDcmVhdGVXYWxsZXQgcmV0dXJucyBhIENyZWF0ZVdhbGxldFJlc3BvbnNlXG4gICAgICogY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbmV3IHdhbGxldC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0TmFtZVxuICAgICAqIEBwYXJhbSB3YWxsZXRQYXNzd29yZFxuICAgICAqIEBwYXJhbSB3YWxsZXREcml2ZXJOYW1lXG4gICAgICogQHBhcmFtIHdhbGxldE1ES1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlV2FsbGV0ID0gYXN5bmMgZnVuY3Rpb24gKHdhbGxldE5hbWUsIHdhbGxldFBhc3N3b3JkLCB3YWxsZXRNREsgPSBcIlwiLCB3YWxsZXREcml2ZXJOYW1lID0gXCJzcWxpdGVcIikge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfbmFtZVwiOiB3YWxsZXROYW1lLFxuICAgICAgICAgICAgXCJ3YWxsZXRfZHJpdmVyX25hbWVcIjogd2FsbGV0RHJpdmVyTmFtZSxcbiAgICAgICAgICAgIFwid2FsbGV0X3Bhc3N3b3JkXCI6IHdhbGxldFBhc3N3b3JkLFxuICAgICAgICAgICAgXCJtYXN0ZXJfZGVyaXZhdGlvbl9rZXlcIjogQnVmZmVyLmZyb20od2FsbGV0TURLKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvd2FsbGV0XCIsIHJlcSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGluaXRXYWxsZXRIYW5kbGUgYWNjZXB0cyBhIHdhbGxldCBJRCBhbmQgYSB3YWxsZXQgcGFzc3dvcmQsIGFuZCByZXR1cm5zIGFuXG4gICAgICogaW5pdFdhbGxldEhhbmRsZVJlc3BvbnNlIGNvbnRhaW5pbmcgYSB3YWxsZXQgaGFuZGxlIHRva2VuLiBUaGlzIHdhbGxldFxuICAgICAqIGhhbmRsZSB0b2tlbiBjYW4gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBvcGVyYXRpb25zIG9uIHRoaXMgd2FsbGV0LCBsaWtlIGtleVxuICAgICAqIGdlbmVyYXRpb24sIHRyYW5zYWN0aW9uIHNpZ25pbmcsIGV0Yy4uIFdhbGxldEhhbmRsZVRva2VucyBleHBpcmUgYWZ0ZXIgYVxuICAgICAqIGNvbmZpZ3VyYWJsZSBudW1iZXIgb2Ygc2Vjb25kcywgYW5kIG11c3QgYmUgcmVuZXdlZCBwZXJpb2RpY2FsbHkgd2l0aFxuICAgICAqIFJlbmV3V2FsbGV0SGFuZGxlLiBJdCBpcyBnb29kIHByYWN0aWNlIHRvIGNhbGwgUmVsZWFzZVdhbGxldEhhbmRsZSB3aGVuXG4gICAgICogeW91J3JlIGRvbmUgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIHdhbGxldC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SURcbiAgICAgKiBAcGFyYW0gd2FsbGV0UGFzc3dvcmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmluaXRXYWxsZXRIYW5kbGUgPSBhc3luYyBmdW5jdGlvbiAod2FsbGV0SUQsIHdhbGxldFBhc3N3b3JkKSB7XG4gICAgICAgIGxldCByZXEgPSB7XG4gICAgICAgICAgICBcIndhbGxldF9pZFwiOiB3YWxsZXRJRCxcbiAgICAgICAgICAgIFwid2FsbGV0X3Bhc3N3b3JkXCI6IHdhbGxldFBhc3N3b3JkLFxuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvd2FsbGV0L2luaXRcIiwgcmVxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVsZWFzZVdhbGxldEhhbmRsZSBpbnZhbGlkYXRlcyB0aGUgcGFzc2VkIHdhbGxldCBoYW5kbGUgdG9rZW4sIG1ha2luZ1xuICAgICAqIGl0IHVudXN1YWJsZSBmb3Igc3Vic2VxdWVudCB3YWxsZXQgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SGFuZGxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5yZWxlYXNlV2FsbGV0SGFuZGxlID0gYXN5bmMgZnVuY3Rpb24gKHdhbGxldEhhbmRsZSkge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS93YWxsZXQvcmVsZWFzZVwiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW5ld1dhbGxldEhhbmRsZSBhY2NlcHRzIGEgd2FsbGV0IGhhbmRsZSBhbmQgYXR0ZW1wdHMgdG8gcmVuZXcgaXQsIG1vdmluZ1xuICAgICAqIHRoZSBleHBpcmF0aW9uIHRpbWUgdG8gc29tZSBudW1iZXIgb2Ygc2Vjb25kcyBpbiB0aGUgZnV0dXJlLiBJdCByZXR1cm5zIGFcbiAgICAgKiBSZW5ld1dhbGxldEhhbmRsZVJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIHdhbGxldEhhbmRsZSBhbmQgdGhlIG51bWJlciBvZlxuICAgICAqIHNlY29uZHMgdW50aWwgZXhwaXJhdGlvblxuICAgICAqIEBwYXJhbSB3YWxsZXRIYW5kbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmV3V2FsbGV0SGFuZGxlID0gYXN5bmMgZnVuY3Rpb24gKHdhbGxldEhhbmRsZSkge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS93YWxsZXQvcmVuZXdcIiwgcmVxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVuYW1lV2FsbGV0IGFjY2VwdHMgYSB3YWxsZXQgSUQsIHdhbGxldCBwYXNzd29yZCwgYW5kIGEgbmV3IHdhbGxldCBuYW1lLFxuICAgICAqIGFuZCByZW5hbWVzIHRoZSB1bmRlcmx5aW5nIHdhbGxldC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SURcbiAgICAgKiBAcGFyYW0gd2FsbGV0UGFzc3dvcmRcbiAgICAgKiBAcGFyYW0gbmV3V2FsbGV0TmFtZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMucmVuYW1lV2FsbGV0ID0gYXN5bmMgZnVuY3Rpb24gKHdhbGxldElELCB3YWxsZXRQYXNzd29yZCwgbmV3V2FsbGV0TmFtZSkge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaWRcIjogd2FsbGV0SUQsXG4gICAgICAgICAgICBcIndhbGxldF9wYXNzd29yZFwiOiB3YWxsZXRQYXNzd29yZCxcbiAgICAgICAgICAgIFwid2FsbGV0X25hbWVcIjogbmV3V2FsbGV0TmFtZVxuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvd2FsbGV0L3JlbmFtZVwiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXRXYWxsZXQgYWNjZXB0cyBhIHdhbGxldCBoYW5kbGUgYW5kIHJldHVybnMgaGlnaCBsZXZlbCBpbmZvcm1hdGlvbiBhYm91dFxuICAgICAqIHRoaXMgd2FsbGV0IGluIGEgR2V0V2FsbGV0UmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHdhbGxldEhhbmRsZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0V2FsbGV0ID0gYXN5bmMgZnVuY3Rpb24gKHdhbGxldEhhbmRsZSkge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS93YWxsZXQvaW5mb1wiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBleHBvcnRNYXN0ZXJEZXJpdmF0aW9uS2V5IGFjY2VwdHMgYSB3YWxsZXQgaGFuZGxlIGFuZCBhIHdhbGxldCBwYXNzd29yZCwgYW5kXG4gICAgICogcmV0dXJucyBhbiBFeHBvcnRNYXN0ZXJEZXJpdmF0aW9uS2V5UmVzcG9uc2UgY29udGFpbmluZyB0aGUgbWFzdGVyXG4gICAgICogZGVyaXZhdGlvbiBrZXkuIFRoaXMga2V5IGNhbiBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHRvIENyZWF0ZVdhbGxldCBpblxuICAgICAqIG9yZGVyIHRvIHJlY292ZXIgdGhlIGtleXMgZ2VuZXJhdGVkIGJ5IHRoaXMgd2FsbGV0LiBUaGUgbWFzdGVyIGRlcml2YXRpb25cbiAgICAgKiBrZXkgY2FuIGJlIGVuY29kZWQgYXMgYSBzZXF1ZW5jZSBvZiB3b3JkcyB1c2luZyB0aGUgbW5lbW9uaWMgbGlicmFyeSwgYW5kXG4gICAgICogQHBhcmFtIHdhbGxldEhhbmRsZVxuICAgICAqIEBwYXJhbSB3YWxsZXRQYXNzd29yZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuZXhwb3J0TWFzdGVyRGVyaXZhdGlvbktleSA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUsIHdhbGxldFBhc3N3b3JkKSB7XG4gICAgICAgIGxldCByZXEgPSB7XG4gICAgICAgICAgICBcIndhbGxldF9oYW5kbGVfdG9rZW5cIjogd2FsbGV0SGFuZGxlLFxuICAgICAgICAgICAgXCJ3YWxsZXRfcGFzc3dvcmRcIjogd2FsbGV0UGFzc3dvcmQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBjLnBvc3QoXCIvdjEvbWFzdGVyLWtleS9leHBvcnRcIiwgcmVxKTtcbiAgICAgICAgcmV0dXJuIHtcIm1hc3Rlcl9kZXJpdmF0aW9uX2tleVwiOiBCdWZmZXIuZnJvbShyZXMuYm9keS5tYXN0ZXJfZGVyaXZhdGlvbl9rZXksICdiYXNlNjQnKX07XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogaW1wb3J0S2V5IGFjY2VwdHMgYSB3YWxsZXQgaGFuZGxlIGFuZCBhbiBlZDI1NTE5IHByaXZhdGUga2V5LCBhbmQgaW1wb3J0c1xuICAgICAqIHRoZSBrZXkgaW50byB0aGUgd2FsbGV0LiBJdCByZXR1cm5zIGFuIEltcG9ydEtleVJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlXG4gICAgICogYWRkcmVzcyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHdhbGxldEhhbmRsZVxuICAgICAqIEBwYXJhbSBzZWNyZXRLZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmltcG9ydEtleSA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUsIHNlY3JldEtleSkge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgICAgIFwicHJpdmF0ZV9rZXlcIjogQnVmZmVyLmZyb20oc2VjcmV0S2V5KS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEva2V5L2ltcG9ydFwiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBleHBvcnRLZXkgYWNjZXB0cyBhIHdhbGxldCBoYW5kbGUsIHdhbGxldCBwYXNzd29yZCwgYW5kIGFkZHJlc3MsIGFuZCByZXR1cm5zXG4gICAgICogYW4gRXhwb3J0S2V5UmVzcG9uc2UgY29udGFpbmluZyB0aGUgZWQyNTUxOSBwcml2YXRlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqIGFkZHJlc3Mgc3RvcmVkIGluIHRoZSB3YWxsZXQuXG4gICAgICogQHBhcmFtIHdhbGxldEhhbmRsZVxuICAgICAqIEBwYXJhbSB3YWxsZXRQYXNzd29yZFxuICAgICAqIEBwYXJhbSBhZGRyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5leHBvcnRLZXkgPSBhc3luYyBmdW5jdGlvbiAod2FsbGV0SGFuZGxlLCB3YWxsZXRQYXNzd29yZCwgYWRkcikge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgICAgIFwiYWRkcmVzc1wiOiBhZGRyLFxuICAgICAgICAgICAgXCJ3YWxsZXRfcGFzc3dvcmRcIjogd2FsbGV0UGFzc3dvcmRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS9rZXkvZXhwb3J0XCIsIHJlcSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlS2V5IGFjY2VwdHMgYSB3YWxsZXQgaGFuZGxlLCBhbmQgdGhlbiBnZW5lcmF0ZXMgdGhlIG5leHQga2V5IGluIHRoZVxuICAgICAqIHdhbGxldCB1c2luZyBpdHMgaW50ZXJuYWwgbWFzdGVyIGRlcml2YXRpb24ga2V5LiBUd28gd2FsbGV0cyB3aXRoIHRoZSBzYW1lXG4gICAgICogbWFzdGVyIGRlcml2YXRpb24ga2V5IHdpbGwgZ2VuZXJhdGUgdGhlIHNhbWUgc2VxdWVuY2Ugb2Yga2V5cy5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SGFuZGxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5nZW5lcmF0ZUtleSA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUpIHtcbiAgICAgICAgbGV0IHJlcSA9IHtcbiAgICAgICAgICAgIFwid2FsbGV0X2hhbmRsZV90b2tlblwiOiB3YWxsZXRIYW5kbGUsXG4gICAgICAgICAgICBcImRpc3BsYXlfbW5lbW9uaWNcIjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS9rZXlcIiwgcmVxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVsZXRlS2V5IGFjY2VwdHMgYSB3YWxsZXQgaGFuZGxlLCB3YWxsZXQgcGFzc3dvcmQsIGFuZCBhZGRyZXNzLCBhbmQgZGVsZXRlc1xuICAgICAqIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGFkZHJlc3MgZnJvbSB0aGUgd2FsbGV0IChpbmNsdWRpbmcgYWRkcmVzcyBhbmRcbiAgICAgKiBzZWNyZXQga2V5KS4gSWYgRGVsZXRlS2V5IGlzIGNhbGxlZCBvbiBhIGtleSBnZW5lcmF0ZWQgdXNpbmcgR2VuZXJhdGVLZXksXG4gICAgICogdGhlIHNhbWUga2V5IHdpbGwgbm90IGJlIGdlbmVyYXRlZCBhZ2Fpbi4gSG93ZXZlciwgaWYgYSB3YWxsZXQgaXMgcmVjb3ZlcmVkXG4gICAgICogdXNpbmcgdGhlIG1hc3RlciBkZXJpdmF0aW9uIGtleSwgYSBrZXkgZ2VuZXJhdGVkIGluIHRoaXMgd2F5IGNhbiBiZVxuICAgICAqIHJlY292ZXJlZC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SGFuZGxlXG4gICAgICogQHBhcmFtIHdhbGxldFBhc3N3b3JkXG4gICAgICogQHBhcmFtIGFkZHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUtleSA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUsIHdhbGxldFBhc3N3b3JkLCBhZGRyKSB7XG4gICAgICAgIGxldCByZXEgPSB7XG4gICAgICAgICAgICBcIndhbGxldF9oYW5kbGVfdG9rZW5cIjogd2FsbGV0SGFuZGxlLFxuICAgICAgICAgICAgXCJhZGRyZXNzXCI6IGFkZHIsXG4gICAgICAgICAgICBcIndhbGxldF9wYXNzd29yZFwiOiB3YWxsZXRQYXNzd29yZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgYy5kZWxldGUoXCIvdjEva2V5XCIsIHJlcSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExpc3RLZXlzIGFjY2VwdHMgYSB3YWxsZXQgaGFuZGxlIGFuZCByZXR1cm5zIGEgTGlzdEtleXNSZXNwb25zZSBjb250YWluaW5nXG4gICAgICogYWxsIG9mIHRoZSBhZGRyZXNzZXMgZm9yIHdoaWNoIHRoaXMgd2FsbGV0IGNvbnRhaW5zIHNlY3JldCBrZXlzLlxuICAgICAqIEBwYXJhbSB3YWxsZXRIYW5kbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RLZXlzID0gYXN5bmMgZnVuY3Rpb24gKHdhbGxldEhhbmRsZSkge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS9rZXkvbGlzdFwiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaWduVHJhbnNhY3Rpb24gYWNjZXB0cyBhIHdhbGxldCBoYW5kbGUsIHdhbGxldCBwYXNzd29yZCwgYW5kIGEgdHJhbnNhY3Rpb24sXG4gICAgICogYW5kIHJldHVybnMgYW5kIFNpZ25UcmFuc2FjdGlvblJlc3BvbnNlIGNvbnRhaW5pbmcgYW4gZW5jb2RlZCwgc2lnbmVkXG4gICAgICogdHJhbnNhY3Rpb24uIFRoZSB0cmFuc2FjdGlvbiBpcyBzaWduZWQgdXNpbmcgdGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqIFNlbmRlciBmaWVsZC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SGFuZGxlXG4gICAgICogQHBhcmFtIHdhbGxldFBhc3N3b3JkXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5zaWduVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAod2FsbGV0SGFuZGxlLCB3YWxsZXRQYXNzd29yZCwgdHJhbnNhY3Rpb24pIHtcblxuICAgICAgICBsZXQgdHggPSBuZXcgdHhuLlRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcblxuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgICAgIFwid2FsbGV0X3Bhc3N3b3JkXCI6IHdhbGxldFBhc3N3b3JkLFxuICAgICAgICAgICAgXCJ0cmFuc2FjdGlvblwiOiBCdWZmZXIuZnJvbSh0eC50b0J5dGUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS90cmFuc2FjdGlvbi9zaWduXCIsIHJlcSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGxpc3RNdWx0aXNpZyBhY2NlcHRzIGEgd2FsbGV0IGhhbmRsZSBhbmQgcmV0dXJucyBhIExpc3RNdWx0aXNpZ1Jlc3BvbnNlXG4gICAgICogY29udGFpbmluZyB0aGUgbXVsdGlzaWcgYWRkcmVzc2VzIHdob3NlIHByZWltYWdlcyBhcmUgc3RvcmVkIGluIHRoaXMgd2FsbGV0LlxuICAgICAqIEEgcHJlaW1hZ2UgaXMgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCB0byByZWNvbnN0cnVjdCB0aGlzIG11bHRpc2lnIGFkZHJlc3MsXG4gICAgICogaW5jbHVkaW5nIG11bHRpc2lnIHZlcnNpb24gaW5mb3JtYXRpb24sIHRocmVzaG9sZCBpbmZvcm1hdGlvbiwgYW5kIGEgbGlzdFxuICAgICAqIG9mIHB1YmxpYyBrZXlzLlxuICAgICAqIEBwYXJhbSB3YWxsZXRIYW5kbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RNdWx0aXNpZyA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUpIHtcbiAgICAgICAgbGV0IHJlcSA9IHtcbiAgICAgICAgICAgIFwid2FsbGV0X2hhbmRsZV90b2tlblwiOiB3YWxsZXRIYW5kbGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvbXVsdGlzaWcvbGlzdFwiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpbXBvcnRNdWx0aXNpZyBhY2NlcHRzIGEgd2FsbGV0IGhhbmRsZSBhbmQgdGhlIGluZm9ybWF0aW9uIHJlcXVpcmVkIHRvXG4gICAgICogZ2VuZXJhdGUgYSBtdWx0aXNpZyBhZGRyZXNzLiBJdCBkZXJpdmVzIHRoaXMgYWRkcmVzcywgYW5kIHN0b3JlcyBhbGwgb2YgdGhlXG4gICAgICogaW5mb3JtYXRpb24gd2l0aGluIHRoZSB3YWxsZXQuIEl0IHJldHVybnMgYSBJbXBvcnRNdWx0aXNpZ1Jlc3BvbnNlIHdpdGggdGhlXG4gICAgICogZGVyaXZlZCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB3YWxsZXRIYW5kbGVcbiAgICAgKiBAcGFyYW0gdmVyc2lvblxuICAgICAqIEBwYXJhbSB0aHJlc2hvbGRcbiAgICAgKiBAcGFyYW0gcGtzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5pbXBvcnRNdWx0aXNpZyA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUsIHZlcnNpb24sIHRocmVzaG9sZCwgcGtzKSB7XG4gICAgICAgIGxldCByZXEgPSB7XG4gICAgICAgICAgICBcIndhbGxldF9oYW5kbGVfdG9rZW5cIjogd2FsbGV0SGFuZGxlLFxuICAgICAgICAgICAgXCJtdWx0aXNpZ192ZXJzaW9uXCI6IHZlcnNpb24sXG4gICAgICAgICAgICBcInRocmVzaG9sZFwiOiB0aHJlc2hvbGQsXG4gICAgICAgICAgICBcInBrc1wiOiBwa3NcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS9tdWx0aXNpZy9pbXBvcnRcIiwgcmVxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZXhwb3J0TXVsdGlzaWcgYWNjZXB0cyBhIHdhbGxldCBoYW5kbGUsIHdhbGxldCBwYXNzd29yZCwgYW5kIG11bHRpc2lnXG4gICAgICogYWRkcmVzcywgYW5kIHJldHVybnMgYW4gRXhwb3J0TXVsdGlzaWdSZXNwb25zZSBjb250YWluaW5nIHRoZSBzdG9yZWRcbiAgICAgKiBtdWx0aXNpZyBwcmVpbWFnZS4gVGhlIHByZWltYWdlIGNvbnRhaW5zIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5XG4gICAgICogdG8gZGVyaXZlIHRoZSBtdWx0aXNpZyBhZGRyZXNzLCBpbmNsdWRpbmcgdmVyc2lvbiwgdGhyZXNob2xkLCBhbmQgYSBsaXN0IG9mXG4gICAgICogcHVibGljIGtleXMuXG4gICAgICogQHBhcmFtIHdhbGxldEhhbmRsZVxuICAgICAqIEBwYXJhbSB3YWxsZXRQYXNzd29yZFxuICAgICAqIEBwYXJhbSBhZGRyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5leHBvcnRNdWx0aXNpZyA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUsIGFkZHIpIHtcbiAgICAgICAgbGV0IHJlcSA9IHtcbiAgICAgICAgICAgIFwid2FsbGV0X2hhbmRsZV90b2tlblwiOiB3YWxsZXRIYW5kbGUsXG4gICAgICAgICAgICBcImFkZHJlc3NcIjogYWRkcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMucG9zdChcIi92MS9tdWx0aXNpZy9leHBvcnRcIiwgcmVxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2lnbk11bHRpc2lnVHJhbnNhY3Rpb24gYWNjZXB0cyBhIHdhbGxldCBoYW5kbGUsIHdhbGxldCBwYXNzd29yZCxcbiAgICAgKiB0cmFuc2FjdGlvbiwgcHVibGljIGtleSAoKm5vdCogYW4gYWRkcmVzcyksIGFuZCBhbiBvcHRpb25hbCBwYXJ0aWFsXG4gICAgICogTXVsdGlzaWdTaWcuIEl0IGxvb2tzIHVwIHRoZSBzZWNyZXQga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpYyBrZXksIGFuZFxuICAgICAqIHJldHVybnMgYSBTaWduTXVsdGlzaWdUcmFuc2FjdGlvblJlc3BvbnNlIGNvbnRhaW5pbmcgYSBNdWx0aXNpZ1NpZyB3aXRoIGFcbiAgICAgKiBzaWduYXR1cmUgYnkgdGhlIHNlY3JldCBrZXkgaW5jbHVkZWQuXG4gICAgICogQHBhcmFtIHdhbGxldEhhbmRsZVxuICAgICAqIEBwYXJhbSBwd1xuICAgICAqIEBwYXJhbSB0eFxuICAgICAqIEBwYXJhbSBwa1xuICAgICAqIEBwYXJhbSBwYXJ0aWFsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgdGhpcy5zaWduTXVsdGlzaWdUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRIYW5kbGUsIHB3LCB0cmFuc2FjdGlvbiwgcGssIHBhcnRpYWwpIHtcbiAgICAgICAgbGV0IHR4ID0gbmV3IHR4bi5UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgIGxldCByZXEgPSB7XG4gICAgICAgICAgICBcIndhbGxldF9oYW5kbGVfdG9rZW5cIjogd2FsbGV0SGFuZGxlLFxuICAgICAgICAgICAgXCJ0cmFuc2FjdGlvblwiOiBCdWZmZXIuZnJvbSh0eC50b0J5dGUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgXCJwdWJsaWNfa2V5XCI6IEJ1ZmZlci5mcm9tKHBrKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICBcInBhcnRpYWxfbXVsdGlzaWdcIjogcGFydGlhbCxcbiAgICAgICAgICAgIFwid2FsbGV0X3Bhc3N3b3JkXCI6IHB3XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjLnBvc3QoXCIvdjEvbXVsdGlzaWcvc2lnblwiLCByZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGVNdWx0aXNpZyBhY2NlcHRzIGEgd2FsbGV0IGhhbmRsZSwgd2FsbGV0IHBhc3N3b3JkLCBhbmQgbXVsdGlzaWdcbiAgICAgKiBhZGRyZXNzLCBhbmQgZGVsZXRlcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBtdWx0aXNpZyBhZGRyZXNzIGZyb20gdGhlIFxuICAgICAqIHdhbGxldCAoaW5jbHVkaW5nIGFkZHJlc3MgYW5kIHNlY3JldCBrZXkpLlxuICAgICAqIEBwYXJhbSB3YWxsZXRIYW5kbGVcbiAgICAgKiBAcGFyYW0gd2FsbGV0UGFzc3dvcmRcbiAgICAgKiBAcGFyYW0gYWRkclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlTXVsdGlzaWcgPSBhc3luYyBmdW5jdGlvbiAod2FsbGV0SGFuZGxlLCB3YWxsZXRQYXNzd29yZCwgYWRkcikge1xuICAgICAgICBsZXQgcmVxID0ge1xuICAgICAgICAgICAgXCJ3YWxsZXRfaGFuZGxlX3Rva2VuXCI6IHdhbGxldEhhbmRsZSxcbiAgICAgICAgICAgIFwiYWRkcmVzc1wiOiBhZGRyLFxuICAgICAgICAgICAgXCJ3YWxsZXRfcGFzc3dvcmRcIjogd2FsbGV0UGFzc3dvcmRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGMuZGVsZXRlKFwiL3YxL211bHRpc2lnXCIsIHJlcSk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge0ttZH07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7S21kfTtcbiIsImNvbnN0IGJhc2UzMiA9IHJlcXVpcmUoJ2hpLWJhc2UzMicpO1xuY29uc3QgbmFjbCA9IHJlcXVpcmUoJy4uL25hY2wvbmFjbFdyYXBwZXJzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbmNvbnN0IEFMR09SQU5EX0FERFJFU1NfQllURV9MRU5HVEggPSAzNjtcbmNvbnN0IEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RIID0gNDtcbmNvbnN0IEFMR09SQU5EX0FERFJFU1NfTEVOR1RIID0gNTg7XG5cbi8vIENvbnZlcnQgXCJNdWx0aXNpZ0FkZHJcIiBVVEYtOCB0byBieXRlIGFycmF5XG5jb25zdCBNVUxUSVNJR19QUkVJTUcyQUREUl9QUkVGSVggPSBuZXcgVWludDhBcnJheShbNzcsIDExNywgMTA4LCAxMTYsIDEwNSwgMTE1LCAxMDUsIDEwMywgNjUsIDEwMCwgMTAwLCAxMTRdKTtcblxuY29uc3QgTUFMRk9STUVEX0FERFJFU1NfRVJST1IgPSBuZXcgRXJyb3IoXCJhZGRyZXNzIHNlZW1zIHRvIGJlIG1hbGZvcm1lZFwiKTtcbmNvbnN0IElOVkFMSURfTVNJR19WRVJTSU9OID0gbmV3IEVycm9yKFwiaW52YWxpZCBtdWx0aXNpZyB2ZXJzaW9uXCIpO1xuY29uc3QgSU5WQUxJRF9NU0lHX1RIUkVTSE9MRCA9IG5ldyBFcnJvcihcImJhZCBtdWx0aXNpZyB0aHJlc2hvbGRcIik7XG5jb25zdCBJTlZBTElEX01TSUdfUEsgPSBuZXcgRXJyb3IoXCJiYWQgbXVsdGlzaWcgcHVibGljIGtleSAtIHdyb25nIGxlbmd0aFwiKTtcbmNvbnN0IFVORVhQRUNURURfUEtfTEVOID0gbmV3IEVycm9yKFwibmFjbCBwdWJsaWMga2V5IGxlbmd0aCBpcyBub3QgMzIgYnl0ZXNcIik7XG5cbi8qKlxuICogaXNWYWxpZEFkZHJlc3MgdGFrZXMgYW4gQWxnb3JhbmQgYWRkcmVzcyBhbmQgY2hlY2tzIGlmIHZhbGlkLlxuICogQHBhcmFtIGFkZHJlc3MgQWxnb3JhbmQgYWRkcmVzc1xuICogQHJldHVybnMge2Jvb2xlYW59biB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGFkZHJlc3MubGVuZ3RoICE9PSBBTEdPUkFORF9BRERSRVNTX0xFTkdUSCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVHJ5IHRvIGRlY29kZVxuICAgIGxldCBkZWNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGUoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBjaGVja3N1bVxuICAgIGxldCBjaGVja3N1bSA9IG5hY2wuZ2VuZXJpY0hhc2goZGVjb2RlZC5wdWJsaWNLZXkpLnNsaWNlKG5hY2wuSEFTSF9CWVRFU19MRU5HVEggLSBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCxuYWNsLkhBU0hfQllURVNfTEVOR1RIKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjaGVja3N1bSBhbmQgdGhlIGFkZHJlc3MgYXJlIGVxdWFsXG4gICAgcmV0dXJuIHV0aWxzLmFycmF5RXF1YWwoY2hlY2tzdW0sIGRlY29kZWQuY2hlY2tzdW0pO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoYWRkcmVzcykge1xuICAgIGlmICghKHR5cGVvZiBhZGRyZXNzID09PSBcInN0cmluZ1wiIHx8IGFkZHJlc3MgaW5zdGFuY2VvZiBTdHJpbmcpKSB0aHJvdyBNQUxGT1JNRURfQUREUkVTU19FUlJPUjtcblxuICAgIC8vdHJ5IHRvIGRlY29kZVxuICAgIGxldCBkZWNvZGVkID0gYmFzZTMyLmRlY29kZS5hc0J5dGVzKGFkZHJlc3MpO1xuXG4gICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgaWYgKGRlY29kZWQubGVuZ3RoICE9PSBBTEdPUkFORF9BRERSRVNTX0JZVEVfTEVOR1RIKSB0aHJvdyBNQUxGT1JNRURfQUREUkVTU19FUlJPUjtcblxuICAgIGxldCBwayA9IG5ldyBVaW50OEFycmF5KGRlY29kZWQuc2xpY2UoMCwgQUxHT1JBTkRfQUREUkVTU19CWVRFX0xFTkdUSCAtIEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RIKSk7XG4gICAgbGV0IGNzID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5zbGljZShuYWNsLlBVQkxJQ19LRVlfTEVOR1RILCBBTEdPUkFORF9BRERSRVNTX0JZVEVfTEVOR1RIKSk7XG5cbiAgICByZXR1cm4ge1wicHVibGljS2V5XCI6IHBrLCBcImNoZWNrc3VtXCI6IGNzfVxufVxuXG5mdW5jdGlvbiBlbmNvZGUoYWRkcmVzcykge1xuICAgIC8vY29tcHV0ZSBjaGVja3N1bVxuICAgIGxldCBjaGVja3N1bSA9IG5hY2wuZ2VuZXJpY0hhc2goYWRkcmVzcykuc2xpY2UobmFjbC5QVUJMSUNfS0VZX0xFTkdUSCAtIEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RILCBuYWNsLlBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICBsZXQgYWRkciA9IGJhc2UzMi5lbmNvZGUodXRpbHMuY29uY2F0QXJyYXlzKGFkZHJlc3MsIGNoZWNrc3VtKSk7XG5cbiAgICByZXR1cm4gYWRkci50b1N0cmluZygpLnNsaWNlKDAsIEFMR09SQU5EX0FERFJFU1NfTEVOR1RIKTsgLy8gcmVtb3ZpbmcgdGhlIGV4dHJhICc9PT09J1xufVxuXG4vKipcbiAqIGZyb21NdWx0aXNpZ1ByZUltZyB0YWtlcyBtdWx0aXNpZyBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgMzIgYnl0ZSB0eXBlZCBhcnJheSBwdWJsaWMga2V5LFxuICogcmVwcmVzZW50aW5nIGFuIGFkZHJlc3MgdGhhdCBpZGVudGlmaWVzIHRoZSBcImV4YWN0IGdyb3VwLCB2ZXJzaW9uLCBhbmQgcHVibGljIGtleXNcIiB0aGF0IGFyZSByZXF1aXJlZCBmb3Igc2lnbmluZy5cbiAqIEhhc2goXCJNdWx0aXNpZ0FkZHJcIiB8fCB2ZXJzaW9uIHVpbnQ4IHx8IHRocmVzaG9sZCB1aW50OCB8fCBQSzEgfHwgUEsyIHx8IC4uLilcbiAqIEVuY29kaW5nIHRoaXMgb3V0cHV0IHlpZWxkcyBhIGh1bWFuIHJlYWRhYmxlIGFkZHJlc3MuXG4gKiBAcGFyYW0gdmVyc2lvbiBtdWx0aXNpZyB2ZXJzaW9uXG4gKiBAcGFyYW0gdGhyZXNob2xkIG11bHRpc2lnIHRocmVzaG9sZFxuICogQHBhcmFtIHBrcyBhcnJheSBvZiB0eXBlZCBhcnJheSBwdWJsaWMga2V5c1xuICovXG5mdW5jdGlvbiBmcm9tTXVsdGlzaWdQcmVJbWcoe3ZlcnNpb24sIHRocmVzaG9sZCwgcGtzfSkge1xuICAgIGlmICh2ZXJzaW9uICE9PSAxIHx8IHZlcnNpb24gPiAyNTUgfHwgdmVyc2lvbiA8IDApIHtcbiAgICAgICAgLy8gXiBhIHRhZCByZWR1bmRhbnQsIGJ1dCBpbiBjYXNlIGluIHRoZSBmdXR1cmUgdmVyc2lvbiAhPSAxLCBzdGlsbCBjaGVjayBmb3IgdWludDhcbiAgICAgICAgdGhyb3cgSU5WQUxJRF9NU0lHX1ZFUlNJT047XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IDAgfHwgcGtzLmxlbmd0aCA9PT0gMCB8fCB0aHJlc2hvbGQgPiBwa3MubGVuZ3RoIHx8IHRocmVzaG9sZCA+IDI1NSkge1xuICAgICAgICB0aHJvdyBJTlZBTElEX01TSUdfVEhSRVNIT0xEO1xuICAgIH1cbiAgICBsZXQgcGtMZW4gPSBBTEdPUkFORF9BRERSRVNTX0JZVEVfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEg7XG4gICAgaWYgKHBrTGVuICE9PSBuYWNsLlBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IFVORVhQRUNURURfUEtfTEVOO1xuICAgIH1cbiAgICBsZXQgbWVyZ2VkID0gbmV3IFVpbnQ4QXJyYXkoTVVMVElTSUdfUFJFSU1HMkFERFJfUFJFRklYLmxlbmd0aCArIDIgKyBwa0xlbipwa3MubGVuZ3RoKTtcbiAgICBtZXJnZWQuc2V0KE1VTFRJU0lHX1BSRUlNRzJBRERSX1BSRUZJWCwgMCk7XG4gICAgbWVyZ2VkLnNldChbdmVyc2lvbl0sIE1VTFRJU0lHX1BSRUlNRzJBRERSX1BSRUZJWC5sZW5ndGgpO1xuICAgIG1lcmdlZC5zZXQoW3RocmVzaG9sZF0sIE1VTFRJU0lHX1BSRUlNRzJBRERSX1BSRUZJWC5sZW5ndGggKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGtzW2ldLmxlbmd0aCAhPT0gcGtMZW4pIHtcbiAgICAgICAgICAgIHRocm93IElOVkFMSURfTVNJR19QSztcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQuc2V0KHBrc1tpXSwgTVVMVElTSUdfUFJFSU1HMkFERFJfUFJFRklYLmxlbmd0aCArIDIgKyBpKnBrTGVuKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hY2wuZ2VuZXJpY0hhc2gobWVyZ2VkKTtcbn1cblxuLyoqXG4gKiBmcm9tTXVsdGlzaWdQcmVJbWdBZGRycyB0YWtlcyBtdWx0aXNpZyBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgaHVtYW4gcmVhZGFibGUgQWxnb3JhbmQgYWRkcmVzcy5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBmcm9tTXVsdGlzaWdQcmVJbWcsIGJ1dCBpbnRlcmZhY2VzIHdpdGggZW5jb2RlZCBhZGRyZXNzZXMuXG4gKiBAcGFyYW0gdmVyc2lvbiBtdWx0aXNpZyB2ZXJzaW9uXG4gKiBAcGFyYW0gdGhyZXNob2xkIG11bHRpc2lnIHRocmVzaG9sZFxuICogQHBhcmFtIGFkZHJzIGFycmF5IG9mIGVuY29kZWQgYWRkcmVzc2VzXG4gKi9cbmZ1bmN0aW9uIGZyb21NdWx0aXNpZ1ByZUltZ0FkZHJzKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIGFkZHJzfSkge1xuICAgIGNvbnN0IHBrcyA9IGFkZHJzLm1hcChhZGRyID0+IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZShhZGRyKS5wdWJsaWNLZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kZShmcm9tTXVsdGlzaWdQcmVJbWcoe3ZlcnNpb24sIHRocmVzaG9sZCwgcGtzfSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtpc1ZhbGlkQWRkcmVzcywgZGVjb2RlLCBlbmNvZGUsIGZyb21NdWx0aXNpZ1ByZUltZywgZnJvbU11bHRpc2lnUHJlSW1nQWRkcnMsIE1BTEZPUk1FRF9BRERSRVNTX0VSUk9SLFxuICAgIElOVkFMSURfTVNJR19WRVJTSU9OLCBJTlZBTElEX01TSUdfVEhSRVNIT0xELCBJTlZBTElEX01TSUdfUEssIFVORVhQRUNURURfUEtfTEVOfTsiLCIvKipcbiAqIFRoaXMgZmlsZSBpcyBhIHdyYXBwZXIgb2YgbXNncGFjay5qcy5cbiAqIFRoZSB3cmFwcGVyIHdhcyB3cml0dGVuIGluIG9yZGVyIHRvIGVuc3VyZSBjb3JyZWN0IGVuY29kaW5nIG9mIEFsZ29yYW5kIFRyYW5zYWN0aW9uIGFuZCBvdGhlciBmb3JtYXRzLlxuICogSW4gcGFydGljdWxhciwgaXQgbWF0Y2hlcyBnby1hbGdvcmFuZCBibG9ja2NoYWluIGNsaWVudCwgd3JpdHRlbiBpbiBnbyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9hbGdvcmFuZC9nby1hbGdvcmFuZC5cbiAqIEFsZ29yYW5kJ3MgbXNncGFjayBlbmNvZGluZyBmb2xsb3dzIHRvIGZvbGxvd2luZyBydWxlcyAtXG4gKiAgMS4gRXZlcnkgaW50ZWdlciBtdXN0IGJlIGVuY29kZWQgdG8gdGhlIHNtYWxsZXN0IHR5cGUgcG9zc2libGUgKDAtMjU1LT44Yml0LCAyNTYtNjU1MzUtPjE2Yml0LCBldHgpXG4gKiAgMi4gQWxsIGZpZWxkcyBuYW1lcyBtdXN0IGJlIHNvcnRlZFxuICogIDMuIEFsbCBlbXB0eSBhbmQgMCBmaWVsZHMgc2hvdWxkIGJlIG9taXR0ZWRcbiAqICA0LiBFdmVyeSBwb3NpdGl2ZSBudW1iZXIgbXVzdCBiZSBlbmNvZGVkIGFzIHVpbnRcbiAqICA1LiBCaW5hcnkgYmxvYiBzaG91bGQgYmUgdXNlZCBmb3IgYmluYXJ5IGRhdGEgYW5kIHN0cmluZyBmb3Igc3RyaW5nc1xuICogICovXG5cbmNvbnN0IG1zZ3BhY2sgPSByZXF1aXJlKFwiQG1zZ3BhY2svbXNncGFja1wiKTtcblxuLy8gRXJyb3JzXG5jb25zdCBFUlJPUl9DT05UQUlOU19FTVBUWSA9IG5ldyBFcnJvcihcIlRoZSBvYmplY3QgY29udGFpbnMgZW1wdHkgb3IgMCB2YWx1ZXNcIik7XG5cbi8qKlxuICogY29udGFpbnNFbXB0eSByZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBvYmplY3QncyB2YWx1ZXMgYXJlIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBFbXB0eSBhcnJheXMgY29uc2lkZXJlZCBlbXB0eVxuICogQHBhcmFtIG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgY29udGFpbnMgZW1wdHksIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjb250YWluc0VtcHR5KG9iaikge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIW9ialtrZXldIHx8IG9ialtrZXldLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIGVuY29kZSBlbmNvZGVzIG9iamVjdHMgdXNpbmcgbXNncGFja1xuICogQHBhcmFtIG9iaiBhIGRpY3Rpb25hcnkgdG8gYmUgZW5jb2RlZC4gTXVzdCBub3QgY29udGFpbiBlbXB0eSBvciAwIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBtc2dwYWNrIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqIEB0aHJvd3MgRVJST1JfQ09OVEFJTlNfRU1QVFkgaWYgdGhlIG9iamVjdCBjb250YWlucyBlbXB0eSBvciB6ZXJvIHZhbHVlc1xuICovXG5mdW5jdGlvbiBlbmNvZGUob2JqKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGVtcHR5IHZhbHVlc1xuICAgIGlmIChjb250YWluc0VtcHR5KG9iaikpIHt0aHJvdyBFUlJPUl9DT05UQUlOU19FTVBUWTt9XG5cbiAgICAvLyBlbmFibGUgdGhlIGNhbm9uaWNhbCBvcHRpb25cbiAgICBsZXQgb3B0aW9ucyA9IHtzb3J0S2V5czogdHJ1ZX07XG4gICAgcmV0dXJuIG1zZ3BhY2suZW5jb2RlKG9iaiwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZShvYmopIHtcbiAgICByZXR1cm4gbXNncGFjay5kZWNvZGUob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7ZW5jb2RlLCBkZWNvZGUsIEVSUk9SX0NPTlRBSU5TX0VNUFRZfTsiLCJtb2R1bGUuZXhwb3J0cz17XCJFdmFsTWF4VmVyc2lvblwiOjEsXCJMb2dpY1NpZ1ZlcnNpb25cIjoxLFwiT3BzXCI6W3tcIk9wY29kZVwiOjAsXCJOYW1lXCI6XCJlcnJcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIkVycm9yLiBQYW5pYyBpbW1lZGlhdGVseS4gVGhpcyBpcyBwcmltYXJpbHkgYSBmZW5jZXBvc3QgYWdhaW5zdCBhY2NpZGVudGFsIHplcm8gYnl0ZXMgZ2V0dGluZyBjb21waWxlZCBpbnRvIHByb2dyYW1zLlwiLFwiR3JvdXBzXCI6W1wiRmxvdyBDb250cm9sXCJdfSx7XCJPcGNvZGVcIjoxLFwiTmFtZVwiOlwic2hhMjU2XCIsXCJBcmdzXCI6XCJCXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6NyxcIlNpemVcIjoxLFwiRG9jXCI6XCJTSEEyNTYgaGFzaCBvZiB2YWx1ZSBYLCB5aWVsZHMgWzMyXWJ5dGVcIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjIsXCJOYW1lXCI6XCJrZWNjYWsyNTZcIixcIkFyZ3NcIjpcIkJcIixcIlJldHVybnNcIjpcIkJcIixcIkNvc3RcIjoyNixcIlNpemVcIjoxLFwiRG9jXCI6XCJLZWNjYWsyNTYgaGFzaCBvZiB2YWx1ZSBYLCB5aWVsZHMgWzMyXWJ5dGVcIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjMsXCJOYW1lXCI6XCJzaGE1MTJfMjU2XCIsXCJBcmdzXCI6XCJCXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6OSxcIlNpemVcIjoxLFwiRG9jXCI6XCJTSEE1MTJfMjU2IGhhc2ggb2YgdmFsdWUgWCwgeWllbGRzIFszMl1ieXRlXCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjo0LFwiTmFtZVwiOlwiZWQyNTUxOXZlcmlmeVwiLFwiQXJnc1wiOlwiQkJCXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MTkwMCxcIlNpemVcIjoxLFwiRG9jXCI6XCJmb3IgKGRhdGEgQSwgc2lnbmF0dXJlIEIsIHB1YmtleSBDKSB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvZiAoXFxcIlByb2dEYXRhXFxcIiB8fCBwcm9ncmFtX2hhc2ggfHwgZGF0YSkgYWdhaW5zdCB0aGUgcHVia2V5ID1cXHUwMDNlIHswIG9yIDF9XCIsXCJEb2NFeHRyYVwiOlwiVGhlIDMyIGJ5dGUgcHVibGljIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IG9uIHRoZSBzdGFjaywgcHJlY2VlZGVkIGJ5IHRoZSA2NCBieXRlIHNpZ25hdHVyZSBhdCB0aGUgc2Vjb25kLXRvLWxhc3QgZWxlbWVudCBvbiB0aGUgc3RhY2ssIHByZWNlZWRlZCBieSB0aGUgZGF0YSB3aGljaCB3YXMgc2lnbmVkIGF0IHRoZSB0aGlyZC10by1sYXN0IGVsZW1lbnQgb24gdGhlIHN0YWNrLlwiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6OCxcIk5hbWVcIjpcIitcIixcIkFyZ3NcIjpcIlVVXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIHBsdXMgQi4gUGFuaWMgb24gb3ZlcmZsb3cuXCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjo5LFwiTmFtZVwiOlwiLVwiLFwiQXJnc1wiOlwiVVVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIkEgbWludXMgQi4gUGFuaWMgaWYgQiBcXHUwMDNlIEEuXCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjoxMCxcIk5hbWVcIjpcIi9cIixcIkFyZ3NcIjpcIlVVXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIGRpdmlkZWQgYnkgQi4gUGFuaWMgaWYgQiA9PSAwLlwiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6MTEsXCJOYW1lXCI6XCIqXCIsXCJBcmdzXCI6XCJVVVwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwiQSB0aW1lcyBCLiBQYW5pYyBvbiBvdmVyZmxvdy5cIixcIkRvY0V4dHJhXCI6XCJPdmVyZmxvdyBpcyBhbiBlcnJvciBjb25kaXRpb24gd2hpY2ggaGFsdHMgZXhlY3V0aW9uIGFuZCBmYWlscyB0aGUgdHJhbnNhY3Rpb24uIEZ1bGwgcHJlY2lzaW9uIGlzIGF2YWlsYWJsZSBmcm9tIGBtdWx3YC5cIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjEyLFwiTmFtZVwiOlwiXFx1MDAzY1wiLFwiQXJnc1wiOlwiVVVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIkEgbGVzcyB0aGFuIEIgPVxcdTAwM2UgezAgb3IgMX1cIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjEzLFwiTmFtZVwiOlwiXFx1MDAzZVwiLFwiQXJnc1wiOlwiVVVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIkEgZ3JlYXRlciB0aGFuIEIgPVxcdTAwM2UgezAgb3IgMX1cIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjE0LFwiTmFtZVwiOlwiXFx1MDAzYz1cIixcIkFyZ3NcIjpcIlVVXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIGxlc3MgdGhhbiBvciBlcXVhbCB0byBCID1cXHUwMDNlIHswIG9yIDF9XCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjoxNSxcIk5hbWVcIjpcIlxcdTAwM2U9XCIsXCJBcmdzXCI6XCJVVVwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwiQSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gQiA9XFx1MDAzZSB7MCBvciAxfVwiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6MTYsXCJOYW1lXCI6XCJcXHUwMDI2XFx1MDAyNlwiLFwiQXJnc1wiOlwiVVVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIkEgaXMgbm90IHplcm8gYW5kIEIgaXMgbm90IHplcm8gPVxcdTAwM2UgezAgb3IgMX1cIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjE3LFwiTmFtZVwiOlwifHxcIixcIkFyZ3NcIjpcIlVVXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIGlzIG5vdCB6ZXJvIG9yIEIgaXMgbm90IHplcm8gPVxcdTAwM2UgezAgb3IgMX1cIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjE4LFwiTmFtZVwiOlwiPT1cIixcIkFyZ3NcIjpcIi4uXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIGlzIGVxdWFsIHRvIEIgPVxcdTAwM2UgezAgb3IgMX1cIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjE5LFwiTmFtZVwiOlwiIT1cIixcIkFyZ3NcIjpcIi4uXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIGlzIG5vdCBlcXVhbCB0byBCID1cXHUwMDNlIHswIG9yIDF9XCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjoyMCxcIk5hbWVcIjpcIiFcIixcIkFyZ3NcIjpcIlVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIlggPT0gMCB5aWVsZHMgMTsgZWxzZSAwXCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjoyMSxcIk5hbWVcIjpcImxlblwiLFwiQXJnc1wiOlwiQlwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwieWllbGRzIGxlbmd0aCBvZiBieXRlIHZhbHVlIFhcIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjIyLFwiTmFtZVwiOlwiaXRvYlwiLFwiQXJnc1wiOlwiVVwiLFwiUmV0dXJuc1wiOlwiQlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwiY29udmVydHMgdWludDY0IFggdG8gYmlnIGVuZGlhbiBieXRlc1wiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6MjMsXCJOYW1lXCI6XCJidG9pXCIsXCJBcmdzXCI6XCJCXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJjb252ZXJ0cyBieXRlcyBYIGFzIGJpZyBlbmRpYW4gdG8gdWludDY0XCIsXCJEb2NFeHRyYVwiOlwiYGJ0b2lgIHBhbmljcyBpZiB0aGUgaW5wdXQgaXMgbG9uZ2VyIHRoYW4gOCBieXRlc1wiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6MjQsXCJOYW1lXCI6XCIlXCIsXCJBcmdzXCI6XCJVVVwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwiQSBtb2R1bG8gQi4gUGFuaWMgaWYgQiA9PSAwLlwiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6MjUsXCJOYW1lXCI6XCJ8XCIsXCJBcmdzXCI6XCJVVVwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwiQSBiaXR3aXNlLW9yIEJcIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjI2LFwiTmFtZVwiOlwiXFx1MDAyNlwiLFwiQXJnc1wiOlwiVVVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcIkEgYml0d2lzZS1hbmQgQlwiLFwiR3JvdXBzXCI6W1wiQXJpdGhtZXRpY1wiXX0se1wiT3Bjb2RlXCI6MjcsXCJOYW1lXCI6XCJeXCIsXCJBcmdzXCI6XCJVVVwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwiQSBiaXR3aXNlLXhvciBCXCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjoyOCxcIk5hbWVcIjpcIn5cIixcIkFyZ3NcIjpcIlVcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcImJpdHdpc2UgaW52ZXJ0IHZhbHVlIFhcIixcIkdyb3Vwc1wiOltcIkFyaXRobWV0aWNcIl19LHtcIk9wY29kZVwiOjI5LFwiTmFtZVwiOlwibXVsd1wiLFwiQXJnc1wiOlwiVVVcIixcIlJldHVybnNcIjpcIlVVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJBIHRpbWVzIEIgb3V0IHRvIDEyOC1iaXQgbG9uZyByZXN1bHQgYXMgbG93ICh0b3ApIGFuZCBoaWdoIHVpbnQ2NCB2YWx1ZXMgb24gdGhlIHN0YWNrXCIsXCJHcm91cHNcIjpbXCJBcml0aG1ldGljXCJdfSx7XCJPcGNvZGVcIjozMixcIk5hbWVcIjpcImludGNibG9ja1wiLFwiQ29zdFwiOjEsXCJTaXplXCI6MCxcIkRvY1wiOlwibG9hZCBibG9jayBvZiB1aW50NjQgY29uc3RhbnRzXCIsXCJEb2NFeHRyYVwiOlwiYGludGNibG9ja2AgbG9hZHMgZm9sbG93aW5nIHByb2dyYW0gYnl0ZXMgaW50byBhbiBhcnJheSBvZiBpbnRlZ2VyIGNvbnN0YW50cyBpbiB0aGUgZXZhbHVhdG9yLiBUaGVzZSBpbnRlZ2VyIGNvbnN0YW50cyBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgYGludGNgIGFuZCBgaW50Y18qYCB3aGljaCB3aWxsIHB1c2ggdGhlIHZhbHVlIG9udG8gdGhlIHN0YWNrLiBTdWJzZXF1ZW50IGNhbGxzIHRvIGBpbnRjYmxvY2tgIHJlc2V0IGFuZCByZXBsYWNlIHRoZSBpbnRlZ2VyIGNvbnN0YW50cyBhdmFpbGFibGUgdG8gdGhlIHNjcmlwdC5cIixcIkltbWVkaWF0ZU5vdGVcIjpcInt2YXJ1aW50IGxlbmd0aH0gW3t2YXJ1aW50IHZhbHVlfSwgLi4uXVwiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjMzLFwiTmFtZVwiOlwiaW50Y1wiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MixcIkRvY1wiOlwicHVzaCB2YWx1ZSBmcm9tIHVpbnQ2NCBjb25zdGFudHMgdG8gc3RhY2sgYnkgaW5kZXggaW50byBjb25zdGFudHNcIixcIkltbWVkaWF0ZU5vdGVcIjpcInt1aW50OCBpbnQgY29uc3RhbnQgaW5kZXh9XCIsXCJHcm91cHNcIjpbXCJMb2FkaW5nIFZhbHVlc1wiXX0se1wiT3Bjb2RlXCI6MzQsXCJOYW1lXCI6XCJpbnRjXzBcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcInB1c2ggY29uc3RhbnQgMCBmcm9tIGludGNibG9jayB0byBzdGFja1wiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjM1LFwiTmFtZVwiOlwiaW50Y18xXCIsXCJSZXR1cm5zXCI6XCJVXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJwdXNoIGNvbnN0YW50IDEgZnJvbSBpbnRjYmxvY2sgdG8gc3RhY2tcIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjozNixcIk5hbWVcIjpcImludGNfMlwiLFwiUmV0dXJuc1wiOlwiVVwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwicHVzaCBjb25zdGFudCAyIGZyb20gaW50Y2Jsb2NrIHRvIHN0YWNrXCIsXCJHcm91cHNcIjpbXCJMb2FkaW5nIFZhbHVlc1wiXX0se1wiT3Bjb2RlXCI6MzcsXCJOYW1lXCI6XCJpbnRjXzNcIixcIlJldHVybnNcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcInB1c2ggY29uc3RhbnQgMyBmcm9tIGludGNibG9jayB0byBzdGFja1wiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjM4LFwiTmFtZVwiOlwiYnl0ZWNibG9ja1wiLFwiQ29zdFwiOjEsXCJTaXplXCI6MCxcIkRvY1wiOlwibG9hZCBibG9jayBvZiBieXRlLWFycmF5IGNvbnN0YW50c1wiLFwiRG9jRXh0cmFcIjpcImBieXRlY2Jsb2NrYCBsb2FkcyB0aGUgZm9sbG93aW5nIHByb2dyYW0gYnl0ZXMgaW50byBhbiBhcnJheSBvZiBieXRlIHN0cmluZyBjb25zdGFudHMgaW4gdGhlIGV2YWx1YXRvci4gVGhlc2UgY29uc3RhbnRzIGNhbiBiZSByZWZlcnJlZCB0byBieSBgYnl0ZWNgIGFuZCBgYnl0ZWNfKmAgd2hpY2ggd2lsbCBwdXNoIHRoZSB2YWx1ZSBvbnRvIHRoZSBzdGFjay4gU3Vic2VxdWVudCBjYWxscyB0byBgYnl0ZWNibG9ja2AgcmVzZXQgYW5kIHJlcGxhY2UgdGhlIGJ5dGVzIGNvbnN0YW50cyBhdmFpbGFibGUgdG8gdGhlIHNjcmlwdC5cIixcIkltbWVkaWF0ZU5vdGVcIjpcInt2YXJ1aW50IGxlbmd0aH0gWyh7dmFydWludCB2YWx1ZSBsZW5ndGh9IGJ5dGVzKSwgLi4uXVwiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjM5LFwiTmFtZVwiOlwiYnl0ZWNcIixcIlJldHVybnNcIjpcIkJcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjIsXCJEb2NcIjpcInB1c2ggYnl0ZXMgY29uc3RhbnQgdG8gc3RhY2sgYnkgaW5kZXggaW50byBjb25zdGFudHNcIixcIkltbWVkaWF0ZU5vdGVcIjpcInt1aW50OCBieXRlIGNvbnN0YW50IGluZGV4fVwiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjQwLFwiTmFtZVwiOlwiYnl0ZWNfMFwiLFwiUmV0dXJuc1wiOlwiQlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwicHVzaCBjb25zdGFudCAwIGZyb20gYnl0ZWNibG9jayB0byBzdGFja1wiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjQxLFwiTmFtZVwiOlwiYnl0ZWNfMVwiLFwiUmV0dXJuc1wiOlwiQlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwicHVzaCBjb25zdGFudCAxIGZyb20gYnl0ZWNibG9jayB0byBzdGFja1wiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjQyLFwiTmFtZVwiOlwiYnl0ZWNfMlwiLFwiUmV0dXJuc1wiOlwiQlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwicHVzaCBjb25zdGFudCAyIGZyb20gYnl0ZWNibG9jayB0byBzdGFja1wiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjQzLFwiTmFtZVwiOlwiYnl0ZWNfM1wiLFwiUmV0dXJuc1wiOlwiQlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MSxcIkRvY1wiOlwicHVzaCBjb25zdGFudCAzIGZyb20gYnl0ZWNibG9jayB0byBzdGFja1wiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjQ0LFwiTmFtZVwiOlwiYXJnXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoyLFwiRG9jXCI6XCJwdXNoIEFyZ3NbTl0gdmFsdWUgdG8gc3RhY2sgYnkgaW5kZXhcIixcIkltbWVkaWF0ZU5vdGVcIjpcInt1aW50OCBhcmcgaW5kZXggTn1cIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo0NSxcIk5hbWVcIjpcImFyZ18wXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJwdXNoIEFyZ3NbMF0gdG8gc3RhY2tcIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo0NixcIk5hbWVcIjpcImFyZ18xXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJwdXNoIEFyZ3NbMV0gdG8gc3RhY2tcIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo0NyxcIk5hbWVcIjpcImFyZ18yXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJwdXNoIEFyZ3NbMl0gdG8gc3RhY2tcIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo0OCxcIk5hbWVcIjpcImFyZ18zXCIsXCJSZXR1cm5zXCI6XCJCXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJwdXNoIEFyZ3NbM10gdG8gc3RhY2tcIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo0OSxcIk5hbWVcIjpcInR4blwiLFwiUmV0dXJuc1wiOlwiLlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MixcIkFyZ0VudW1cIjpbXCJTZW5kZXJcIixcIkZlZVwiLFwiRmlyc3RWYWxpZFwiLFwiRmlyc3RWYWxpZFRpbWVcIixcIkxhc3RWYWxpZFwiLFwiTm90ZVwiLFwiTGVhc2VcIixcIlJlY2VpdmVyXCIsXCJBbW91bnRcIixcIkNsb3NlUmVtYWluZGVyVG9cIixcIlZvdGVQS1wiLFwiU2VsZWN0aW9uUEtcIixcIlZvdGVGaXJzdFwiLFwiVm90ZUxhc3RcIixcIlZvdGVLZXlEaWx1dGlvblwiLFwiVHlwZVwiLFwiVHlwZUVudW1cIixcIlhmZXJBc3NldFwiLFwiQXNzZXRBbW91bnRcIixcIkFzc2V0U2VuZGVyXCIsXCJBc3NldFJlY2VpdmVyXCIsXCJBc3NldENsb3NlVG9cIixcIkdyb3VwSW5kZXhcIixcIlR4SURcIl0sXCJBcmdFbnVtVHlwZXNcIjpcIkJVVVVVQkJCVUJCQlVVVUJVVVVCQkJVQlwiLFwiRG9jXCI6XCJwdXNoIGZpZWxkIGZyb20gY3VycmVudCB0cmFuc2FjdGlvbiB0byBzdGFja1wiLFwiRG9jRXh0cmFcIjpcIkZpcnN0VmFsaWRUaW1lIGNhdXNlcyB0aGUgcHJvZ3JhbSB0byBmYWlsLiBUaGUgZmllbGQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UuXCIsXCJJbW1lZGlhdGVOb3RlXCI6XCJ7dWludDggdHJhbnNhY3Rpb24gZmllbGQgaW5kZXh9XCIsXCJHcm91cHNcIjpbXCJMb2FkaW5nIFZhbHVlc1wiXX0se1wiT3Bjb2RlXCI6NTAsXCJOYW1lXCI6XCJnbG9iYWxcIixcIlJldHVybnNcIjpcIi5cIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjIsXCJBcmdFbnVtXCI6W1wiTWluVHhuRmVlXCIsXCJNaW5CYWxhbmNlXCIsXCJNYXhUeG5MaWZlXCIsXCJaZXJvQWRkcmVzc1wiLFwiR3JvdXBTaXplXCJdLFwiQXJnRW51bVR5cGVzXCI6XCJVVVVCVVwiLFwiRG9jXCI6XCJwdXNoIHZhbHVlIGZyb20gZ2xvYmFscyB0byBzdGFja1wiLFwiSW1tZWRpYXRlTm90ZVwiOlwie3VpbnQ4IGdsb2JhbCBmaWVsZCBpbmRleH1cIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo1MSxcIk5hbWVcIjpcImd0eG5cIixcIlJldHVybnNcIjpcIi5cIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjMsXCJBcmdFbnVtXCI6W1wiU2VuZGVyXCIsXCJGZWVcIixcIkZpcnN0VmFsaWRcIixcIkZpcnN0VmFsaWRUaW1lXCIsXCJMYXN0VmFsaWRcIixcIk5vdGVcIixcIkxlYXNlXCIsXCJSZWNlaXZlclwiLFwiQW1vdW50XCIsXCJDbG9zZVJlbWFpbmRlclRvXCIsXCJWb3RlUEtcIixcIlNlbGVjdGlvblBLXCIsXCJWb3RlRmlyc3RcIixcIlZvdGVMYXN0XCIsXCJWb3RlS2V5RGlsdXRpb25cIixcIlR5cGVcIixcIlR5cGVFbnVtXCIsXCJYZmVyQXNzZXRcIixcIkFzc2V0QW1vdW50XCIsXCJBc3NldFNlbmRlclwiLFwiQXNzZXRSZWNlaXZlclwiLFwiQXNzZXRDbG9zZVRvXCIsXCJHcm91cEluZGV4XCIsXCJUeElEXCJdLFwiQXJnRW51bVR5cGVzXCI6XCJCVVVVVUJCQlVCQkJVVVVCVVVVQkJCVUJcIixcIkRvY1wiOlwicHVzaCBmaWVsZCB0byB0aGUgc3RhY2sgZnJvbSBhIHRyYW5zYWN0aW9uIGluIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGdyb3VwXCIsXCJEb2NFeHRyYVwiOlwiZm9yIG5vdGVzIG9uIHRyYW5zYWN0aW9uIGZpZWxkcyBhdmFpbGFibGUsIHNlZSBgdHhuYC4gSWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBfaV8gaW4gdGhlIGdyb3VwLCBgZ3R4biBpIGZpZWxkYCBpcyBlcXVpdmFsZW50IHRvIGB0eG4gZmllbGRgXCIsXCJJbW1lZGlhdGVOb3RlXCI6XCJ7dWludDggdHJhbnNhY3Rpb24gZ3JvdXAgaW5kZXh9e3VpbnQ4IHRyYW5zYWN0aW9uIGZpZWxkIGluZGV4fVwiLFwiR3JvdXBzXCI6W1wiTG9hZGluZyBWYWx1ZXNcIl19LHtcIk9wY29kZVwiOjUyLFwiTmFtZVwiOlwibG9hZFwiLFwiUmV0dXJuc1wiOlwiLlwiLFwiQ29zdFwiOjEsXCJTaXplXCI6MixcIkRvY1wiOlwiY29weSBhIHZhbHVlIGZyb20gc2NyYXRjaCBzcGFjZSB0byB0aGUgc3RhY2tcIixcIkltbWVkaWF0ZU5vdGVcIjpcInt1aW50OCBwb3NpdGlvbiBpbiBzY3JhdGNoIHNwYWNlIHRvIGxvYWQgZnJvbX1cIixcIkdyb3Vwc1wiOltcIkxvYWRpbmcgVmFsdWVzXCJdfSx7XCJPcGNvZGVcIjo1MyxcIk5hbWVcIjpcInN0b3JlXCIsXCJBcmdzXCI6XCIuXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoyLFwiRG9jXCI6XCJwb3AgYSB2YWx1ZSBmcm9tIHRoZSBzdGFjayBhbmQgc3RvcmUgdG8gc2NyYXRjaCBzcGFjZVwiLFwiSW1tZWRpYXRlTm90ZVwiOlwie3VpbnQ4IHBvc2l0aW9uIGluIHNjcmF0Y2ggc3BhY2UgdG8gc3RvcmUgdG99XCIsXCJHcm91cHNcIjpbXCJMb2FkaW5nIFZhbHVlc1wiXX0se1wiT3Bjb2RlXCI6NjQsXCJOYW1lXCI6XCJibnpcIixcIkFyZ3NcIjpcIlVcIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjMsXCJEb2NcIjpcImJyYW5jaCBpZiB2YWx1ZSBYIGlzIG5vdCB6ZXJvXCIsXCJEb2NFeHRyYVwiOlwiVGhlIGBibnpgIGluc3RydWN0aW9uIG9wY29kZSAweDQwIGlzIGZvbGxvd2VkIGJ5IHR3byBpbW1lZGlhdGUgZGF0YSBieXRlcyB3aGljaCBhcmUgYSBoaWdoIGJ5dGUgZmlyc3QgYW5kIGxvdyBieXRlIHNlY29uZCB3aGljaCB0b2dldGhlciBmb3JtIGEgMTYgYml0IG9mZnNldCB3aGljaCB0aGUgaW5zdHJ1Y3Rpb24gbWF5IGJyYW5jaCB0by4gRm9yIGEgYm56IGluc3RydWN0aW9uIGF0IGBwY2AsIGlmIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHN0YWNrIGlzIG5vdCB6ZXJvIHRoZW4gYnJhbmNoIHRvIGluc3RydWN0aW9uIGF0IGBwYyArIDMgKyBOYCwgZWxzZSBwcm9jZWVkIHRvIG5leHQgaW5zdHJ1Y3Rpb24gYXQgYHBjICsgM2AuIEJyYW5jaCB0YXJnZXRzIG11c3QgYmUgd2VsbCBhbGlnbmVkIGluc3RydWN0aW9ucy4gKGUuZy4gQnJhbmNoaW5nIHRvIHRoZSBzZWNvbmQgYnl0ZSBvZiBhIDIgYnl0ZSBvcCB3aWxsIGJlIHJlamVjdGVkLikgQnJhbmNoIG9mZnNldHMgYXJlIGN1cnJlbnRseSBsaW1pdGVkIHRvIGZvcndhcmQgYnJhbmNoZXMgb25seSwgMC0weDdmZmYuIEEgZnV0dXJlIGV4cGFuc2lvbiBtaWdodCBtYWtlIHRoaXMgYSBzaWduZWQgMTYgYml0IGludGVnZXIgYWxsb3dpbmcgZm9yIGJhY2t3YXJkIGJyYW5jaGVzIGFuZCBsb29waW5nLlwiLFwiSW1tZWRpYXRlTm90ZVwiOlwiezAuLjB4N2ZmZiBmb3J3YXJkIGJyYW5jaCBvZmZzZXQsIGJpZyBlbmRpYW59XCIsXCJHcm91cHNcIjpbXCJGbG93IENvbnRyb2xcIl19LHtcIk9wY29kZVwiOjcyLFwiTmFtZVwiOlwicG9wXCIsXCJBcmdzXCI6XCIuXCIsXCJDb3N0XCI6MSxcIlNpemVcIjoxLFwiRG9jXCI6XCJkaXNjYXJkIHZhbHVlIFggZnJvbSBzdGFja1wiLFwiR3JvdXBzXCI6W1wiRmxvdyBDb250cm9sXCJdfSx7XCJPcGNvZGVcIjo3MyxcIk5hbWVcIjpcImR1cFwiLFwiQXJnc1wiOlwiLlwiLFwiUmV0dXJuc1wiOlwiLi5cIixcIkNvc3RcIjoxLFwiU2l6ZVwiOjEsXCJEb2NcIjpcImR1cGxpY2F0ZSBsYXN0IHZhbHVlIG9uIHN0YWNrXCIsXCJHcm91cHNcIjpbXCJGbG93IENvbnRyb2xcIl19XX1cbiIsIi8qKlxuIFV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIHByb2dyYW0gYnl0ZXMuXG4gKi9cblxuY29uc3QgbGFuZ3NwZWMgPSByZXF1aXJlKFwiLi9sYW5nc3BlYy5qc29uXCIpXG5cbmxldCBvcGNvZGVzO1xuXG5jb25zdCBtYXhDb3N0ID0gMjAwMDA7XG5jb25zdCBtYXhMZW5ndGggPSAxMDAwO1xuXG4vKipcbiAqIGNoZWNrUHJvZ3JhbSB2YWxpZGF0ZXMgcHJvZ3JhbSBmb3IgbGVuZ3RoIGFuZCBydW5uaW5nIGNvc3RcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJvZ3JhbSBQcm9ncmFtIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1tVaW50OEFycmF5XX0gYXJncyBQcm9ncmFtIGFyZ3VtZW50cyBhcyBhcnJheSBvZiBVaW50OEFycmF5IGFycmF5c1xuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBzdWNjZXNzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvZ3JhbShwcm9ncmFtLCBhcmdzKSB7XG4gICAgY29uc3QgaW50Y2Jsb2NrT3Bjb2RlID0gMzI7XG4gICAgY29uc3QgYnl0ZWNibG9ja09wY29kZSA9IDM4O1xuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBwcm9ncmFtXCIpO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmdzID0gW11cbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJndW1lbnRzXCIpO1xuICAgIH1cblxuICAgIGxldCBbdmVyc2lvbiwgdmxlbl0gPSBwYXJzZVV2YXJpbnQocHJvZ3JhbSk7XG4gICAgaWYgKHZsZW4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2ZXJzaW9uIHBhcnNpbmcgZXJyb3JcIik7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID4gbGFuZ3NwZWMuRXZhbE1heFZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdmVyc2lvblwiKTtcbiAgICB9XG5cbiAgICBsZXQgY29zdCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9cHJvZ3JhbS5sZW5ndGg7XG4gICAgZm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgbGVuZ3RoICs9IGFyZy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvZ3JhbSB0b28gbG9uZ1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wY29kZXMpIHtcbiAgICAgICAgb3Bjb2RlcyA9IHt9XG4gICAgICAgIGZvciAobGV0IG9wIG9mIGxhbmdzcGVjLk9wcykge1xuICAgICAgICAgICAgb3Bjb2Rlc1tvcC5PcGNvZGVdID0gb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcGMgPSB2bGVuO1xuICAgIHdoaWxlIChwYyA8IHByb2dyYW0ubGVuZ3RoKSB7XG4gICAgICAgIGxldCBvcCA9IG9wY29kZXNbcHJvZ3JhbVtwY11dO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnN0cnVjdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvc3QgKz0gb3AuQ29zdDtcbiAgICAgICAgbGV0IHNpemUgPSBvcC5TaXplO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wLk9wY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgaW50Y2Jsb2NrT3Bjb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBjaGVja0ludENvbnN0QmxvY2socHJvZ3JhbSwgcGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBieXRlY2Jsb2NrT3Bjb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBjaGVja0J5dGVDb25zdEJsb2NrKHByb2dyYW0sIHBjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnN0cnVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGMgKz0gc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoY29zdCA+IG1heENvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvZ3JhbSB0b28gY29zdGx5IHRvIHJ1blwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRDb25zdEJsb2NrKHByb2dyYW0sIHBjKSB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGxldCBbbnVtSW50cywgYnl0ZXNVc2VkXSA9IHBhcnNlVXZhcmludChwcm9ncmFtLnNsaWNlKHBjICsgc2l6ZSkpO1xuICAgIGlmIChieXRlc1VzZWQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvdWxkIG5vdCBkZWNvZGUgaW50IGNvbnN0IGJsb2NrIHNpemUgYXQgcGM9JHtwYyArIHNpemV9YCk7XG4gICAgfVxuXG4gICAgc2l6ZSArPSBieXRlc1VzZWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbnRzOyBpKyspIHtcbiAgICAgICAgaWYgKHBjICsgc2l6ZSA+PSBwcm9ncmFtLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50Y2Jsb2NrIHJhbiBwYXN0IGVuZCBvZiBwcm9ncmFtXCIpO1xuICAgICAgICB9XG4gICAgICAgIFtfLCBieXRlc1VzZWRdID0gcGFyc2VVdmFyaW50KHByb2dyYW0uc2xpY2UocGMgKyBzaXplKSk7XG4gICAgICAgIGlmIChieXRlc1VzZWQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgZGVjb2RlIGludCBjb25zdFske2l9XSBibG9jayBzaXplIGF0IHBjPSR7cGMgKyBzaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgKz0gYnl0ZXNVc2VkO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCeXRlQ29uc3RCbG9jayhwcm9ncmFtLCBwYykge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBsZXQgW251bUludHMsIGJ5dGVzVXNlZF0gPSBwYXJzZVV2YXJpbnQocHJvZ3JhbS5zbGljZShwYyArIHNpemUpKTtcbiAgICBpZiAoYnl0ZXNVc2VkIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgZGVjb2RlIFtdYnl0ZSBjb25zdCBibG9jayBzaXplIGF0IHBjPSR7cGMgKyBzaXplfWApO1xuICAgIH1cblxuICAgIHNpemUgKz0gYnl0ZXNVc2VkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW50czsgaSsrKSB7XG4gICAgICAgIGlmIChwYyArIHNpemUgPj0gcHJvZ3JhbS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ5dGVjYmxvY2sgcmFuIHBhc3QgZW5kIG9mIHByb2dyYW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtpdGVtTGVuLCBieXRlc1VzZWRdID0gcGFyc2VVdmFyaW50KHByb2dyYW0uc2xpY2UocGMgKyBzaXplKSk7XG4gICAgICAgIGlmIChieXRlc1VzZWQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgZGVjb2RlIFtdYnl0ZV0gY29uc3RbJHtpfV0gYmxvY2sgc2l6ZSBhdCBwYz0ke3BjICsgc2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplICs9IGJ5dGVzVXNlZDtcbiAgICAgICAgaWYgKHBjICsgc2l6ZSA+PSBwcm9ncmFtLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnl0ZWNibG9jayByYW4gcGFzdCBlbmQgb2YgcHJvZ3JhbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplICs9IGl0ZW1MZW47XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBwYXJzZVV2YXJpbnQoYXJyYXkpIHtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYiA9IGFycmF5W2ldO1xuICAgICAgICBpZiAoYiA8IDB4ODApIHtcbiAgICAgICAgICAgIGlmIChpID4gOSB8fCBpID09IDkgJiYgYiA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIC0oaSArIDEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeCB8IGIgPDwgcywgaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHggKz0gKGIgJiAweDdmKSA8PCBzO1xuICAgICAgICBzICs9IDc7XG4gICAgfVxuICAgIHJldHVybiBbMCwgMF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNoZWNrUHJvZ3JhbSxcbiAgICBwYXJzZVV2YXJpbnQsXG4gICAgY2hlY2tJbnRDb25zdEJsb2NrLFxuICAgIGNoZWNrQnl0ZUNvbnN0QmxvY2tcbn07XG4iLCJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IG5hY2wgPSByZXF1aXJlKCcuL25hY2wvbmFjbFdyYXBwZXJzJyk7XG5jb25zdCBhZGRyZXNzID0gcmVxdWlyZSgnLi9lbmNvZGluZy9hZGRyZXNzJyk7XG5jb25zdCBlbmNvZGluZyA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvZW5jb2RpbmcnKTtcbmNvbnN0IGxvZ2ljID0gcmVxdWlyZSgnLi9sb2dpYy9sb2dpYycpO1xuY29uc3QgbXVsdGlzaWcgPSByZXF1aXJlKCcuL211bHRpc2lnJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4gTG9naWNTaWcgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5jbGFzcyBMb2dpY1NpZyB7XG4gICAgY29uc3RydWN0b3IocHJvZ3JhbSwgYXJncykge1xuICAgICAgICB0aGlzLnRhZyA9IEJ1ZmZlci5mcm9tKFwiUHJvZ3JhbVwiKTtcblxuICAgICAgICBhc3NlcnQobG9naWMuY2hlY2tQcm9ncmFtKHByb2dyYW0sIGFyZ3MpKTtcblxuICAgICAgICB0aGlzLmxvZ2ljID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubXNpZyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRfb2JqX2Zvcl9lbmNvZGluZygpIHtcbiAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgIGw6IHRoaXMubG9naWMsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgICAgICAgb2JqW1wiYXJnXCJdID0gdGhpcy5hcmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZykge1xuICAgICAgICAgICAgb2JqW1wic2lnXCJdID0gdGhpcy5zaWc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tc2lnKSB7XG4gICAgICAgICAgICBvYmpbXCJtc2lnXCJdID0gdGhpcy5tc2lnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21fb2JqX2Zvcl9lbmNvZGluZyhlbmNvZGVkKSB7XG4gICAgICAgIGxldCBsc2lnID0gbmV3IExvZ2ljU2lnKGVuY29kZWQubCwgZW5jb2RlZC5hcmcpO1xuICAgICAgICBsc2lnLnNpZyA9IGVuY29kZWQuc2lnO1xuICAgICAgICBsc2lnLm1zaWcgPSBlbmNvZGVkLm1zaWc7XG4gICAgICAgIHJldHVybiBsc2lnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHB1YmxpY0tleSBWZXJpZmljYXRpb24ga2V5IChkZXJpdmVkIGZyb20gc2VuZGVyIGFkZHJlc3Mgb3IgZXNjcm93IGFkZHJlc3MpXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmVyaWZ5KHB1YmxpY0tleSkge1xuICAgICAgICBpZiAodGhpcy5zaWcgJiYgdGhpcy5tc2lnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9naWMuY2hlY2tQcm9ncmFtKHRoaXMubG9naWMsIHRoaXMuYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b0JlU2lnbmVkID0gdXRpbHMuY29uY2F0QXJyYXlzKHRoaXMudGFnLCB0aGlzLmxvZ2ljKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2lnICYmICF0aGlzLm1zaWcpIHtcbiAgICAgICAgICAgIGxldCBoYXNoID0gbmFjbC5nZW5lcmljSGFzaCh0b0JlU2lnbmVkKTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5hcnJheUVxdWFsKGhhc2gsIHB1YmxpY0tleSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNpZykge1xuICAgICAgICAgICAgcmV0dXJuIG5hY2wudmVyaWZ5KHRvQmVTaWduZWQsIHRoaXMuc2lnLCBwdWJsaWNLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG11bHRpc2lnLnZlcmlmeU11bHRpc2lnKHRvQmVTaWduZWQsIHRoaXMubXNpZywgcHVibGljS2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGhhc2ggb2YgdGhlIGxvZ2ljIHNpZyBwcm9ncmFtICh0aGF0IGlzIHRoZSBzYW1lIGFzIGVzY3JvdyBhY2NvdW50IGFkZHJlc3MpIGFzIHN0cmluZyBhZGRyZXNzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAgICovXG4gICAgYWRkcmVzcygpIHtcbiAgICAgICAgbGV0IHRvQmVTaWduZWQgPSB1dGlscy5jb25jYXRBcnJheXModGhpcy50YWcsIHRoaXMubG9naWMpO1xuICAgICAgICBsZXQgaGFzaCA9IG5hY2wuZ2VuZXJpY0hhc2godG9CZVNpZ25lZCk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLmVuY29kZShoYXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHNpZ25hdHVyZSAoaWYgbm8gbXNpZyBwcm92aWRlZCkgb3IgbXVsdGkgc2lnbmF0dXJlIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VjcmV0S2V5IFNlY3JldCBrZXkgdG8gc2lnbiB3aXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zaWcgTXVsdGlzaWcgYWNjb3VudCBhcyB7dmVyc2lvbiwgdGhyZXNob2xkLCBhZGRyc31cbiAgICAgKi9cbiAgICBzaWduKHNlY3JldEtleSwgbXNpZykge1xuICAgICAgICBpZiAobXNpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNpZyA9IHRoaXMuc2lnblByb2dyYW0oc2VjcmV0S2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdWJzaWdzID0gbXNpZy5hZGRycy5tYXAoYWRkciA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcInBrXCI6IGFkZHJlc3MuZGVjb2RlKGFkZHIpLnB1YmxpY0tleX07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tc2lnID0ge1xuICAgICAgICAgICAgICAgIFwidlwiOiBtc2lnLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgXCJ0aHJcIjogbXNpZy50aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgXCJzdWJzaWdcIjogc3Vic2lnc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGV0IFtzaWcsIGluZGV4XSA9IHRoaXMuc2luZ2xlU2lnbk11bHRpc2lnKHNlY3JldEtleSwgdGhpcy5tc2lnKTtcbiAgICAgICAgICAgIHRoaXMubXNpZy5zdWJzaWdbaW5kZXhdLnMgPSBzaWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgc2lnbmF0dXJlIHRvIG11bHRpIHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VjcmV0S2V5IFNlY3JldCBrZXkgdG8gc2lnbiB3aXRoXG4gICAgICovXG4gICAgYXBwZW5kVG9NdWx0aXNpZyhzZWNyZXRLZXkpIHtcbiAgICAgICAgaWYgKHRoaXMubXNpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBtdWx0aXNpZyBwcmVzZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbc2lnLCBpbmRleF0gPSB0aGlzLnNpbmdsZVNpZ25NdWx0aXNpZyhzZWNyZXRLZXksIHRoaXMubXNpZyk7XG4gICAgICAgIHRoaXMubXNpZy5zdWJzaWdbaW5kZXhdLnMgPSBzaWc7XG4gICAgfVxuXG4gICAgc2lnblByb2dyYW0oc2VjcmV0S2V5KSB7XG4gICAgICAgIGxldCB0b0JlU2lnbmVkID0gdXRpbHMuY29uY2F0QXJyYXlzKHRoaXMudGFnLCB0aGlzLmxvZ2ljKTtcbiAgICAgICAgY29uc3Qgc2lnID0gbmFjbC5zaWduKHRvQmVTaWduZWQsIHNlY3JldEtleSk7XG4gICAgICAgIHJldHVybiBzaWc7XG4gICAgfVxuXG4gICAgc2luZ2xlU2lnbk11bHRpc2lnKHNlY3JldEtleSwgbXNpZykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IG15UGsgPSBuYWNsLmtleVBhaXJGcm9tU2VjcmV0S2V5KHNlY3JldEtleSkucHVibGljS2V5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zaWcuc3Vic2lnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGsgPSBtc2lnLnN1YnNpZ1tpXS5waztcbiAgICAgICAgICAgIGlmICh1dGlscy5hcnJheUVxdWFsKHBrLCBteVBrKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2VjcmV0IGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnID0gdGhpcy5zaWduUHJvZ3JhbShzZWNyZXRLZXkpO1xuICAgICAgICByZXR1cm4gW3NpZywgaW5kZXhdO1xuICAgIH1cblxuICAgIHRvQnl0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nLmVuY29kZSh0aGlzLmdldF9vYmpfZm9yX2VuY29kaW5nKCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tQnl0ZShlbmNvZGVkKSB7XG4gICAgICAgIGxldCBkZWNvZGVkX29iaiA9IGVuY29kaW5nLmRlY29kZShlbmNvZGVkKTtcbiAgICAgICAgcmV0dXJuIExvZ2ljU2lnLmZyb21fb2JqX2Zvcl9lbmNvZGluZyhkZWNvZGVkX29iaik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBMb2dpY1NpZ1xufTtcbiIsImNvbnN0IG5hY2wgPSByZXF1aXJlKCcuL25hY2wvbmFjbFdyYXBwZXJzJyk7XG5jb25zdCBhZGRyZXNzID0gcmVxdWlyZSgnLi9lbmNvZGluZy9hZGRyZXNzJyk7XG5jb25zdCBtbmVtb25pYyA9IHJlcXVpcmUoJy4vbW5lbW9uaWMvbW5lbW9uaWMnKTtcbmNvbnN0IGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZy9lbmNvZGluZycpO1xuY29uc3QgdHhuQnVpbGRlciA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IG11bHRpc2lnID0gcmVxdWlyZSgnLi9tdWx0aXNpZycpO1xuY29uc3QgYmlkQnVpbGRlciA9IHJlcXVpcmUoJy4vYmlkJyk7XG5jb25zdCBhbGdvZCA9IHJlcXVpcmUoJy4vY2xpZW50L2FsZ29kJyk7XG5jb25zdCBrbWQgPSByZXF1aXJlKCcuL2NsaWVudC9rbWQnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91dGlscycpO1xuY29uc3QgbG9naWNzaWcgPSByZXF1aXJlKCcuL2xvZ2ljc2lnJyk7XG5cbmxldCBBbGdvZCA9IGFsZ29kLkFsZ29kO1xubGV0IEttZCA9IGttZC5LbWQ7XG5cbmNvbnN0IFNJR05fQllURVNfUFJFRklYID0gQnVmZmVyLmZyb20oWzc3LCA4OF0pOyAvLyBcIk1YXCJcbmNvbnN0IE1JQ1JPQUxHT1NfVE9fQUxHT1NfUkFUSU8gPSAxZTY7XG4vLyBFcnJvcnNcbmNvbnN0IEVSUk9SX01VTFRJU0lHX0JBRF9TRU5ERVIgPSBuZXcgRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb24gc2VuZGVyIGFkZHJlc3MgYW5kIG11bHRpc2lnIHByZWltYWdlIGRvIG5vdCBtYXRjaC5cIik7XG5jb25zdCBFUlJPUl9JTlZBTElEX01JQ1JPQUxHT1MgPSBuZXcgRXJyb3IoXCJNaWNyb2FsZ29zIHNob3VsZCBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIDJeNTMgLSAxLlwiKVxuLyoqXG4gKiBnZW5lcmF0ZUFjY291bnQgcmV0dXJucyBhIG5ldyBBbGdvcmFuZCBhZGRyZXNzIGFuZCBpdHMgY29ycmVzcG9uZGluZyBzZWNyZXQga2V5XG4gKiBAcmV0dXJucyB7e3NrOiBVaW50OEFycmF5LCBhZGRyOiBzdHJpbmd9fVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUFjY291bnQoKSB7XG4gICAgbGV0IGtleXMgPSBuYWNsLmtleVBhaXIoKTtcbiAgICBsZXQgZW5jb2RlZFBrID0gYWRkcmVzcy5lbmNvZGUoa2V5cy5wdWJsaWNLZXkpO1xuICAgIHJldHVybiB7YWRkcjogZW5jb2RlZFBrLCBzazoga2V5cy5zZWNyZXRLZXl9O1xufVxuXG4vKipcbiAqIGlzVmFsaWRBZGRyZXNzIHRha2VzIGFuIEFsZ29yYW5kIGFkZHJlc3MgYW5kIGNoZWNrcyBpZiB2YWxpZC5cbiAqIEBwYXJhbSBhZGRyIEFsZ29yYW5kIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFkZHJlc3MoYWRkcikge1xuICAgIHJldHVybiBhZGRyZXNzLmlzVmFsaWRBZGRyZXNzKGFkZHIpO1xufVxuXG4vKipcbiAqIG1uZW1vbmljVG9TZWNyZXRLZXkgdGFrZXMgYSBtbmVtb25pYyBzdHJpbmcgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgQWxnb3JhbmQgYWRkcmVzcyBhbmQgaXRzIHNlY3JldCBrZXkuXG4gKiBAcGFyYW0gbW4gMjUgd29yZHMgQWxnb3JhbmQgbW5lbW9uaWNcbiAqIEByZXR1cm5zIHt7c2s6IFVpbnQ4QXJyYXksIGFkZHI6IHN0cmluZ319XG4gKiBAdGhyb3dzIGVycm9yIGlmIGZhaWxzIHRvIGRlY29kZSB0aGUgbW5lbW9uaWNcbiAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb1NlY3JldEtleShtbikge1xuICAgIGxldCBzZWVkID0gbW5lbW9uaWMuc2VlZEZyb21NbmVtb25pYyhtbik7XG4gICAgbGV0IGtleXMgPSBuYWNsLmtleVBhaXJGcm9tU2VlZChzZWVkKTtcbiAgICBsZXQgZW5jb2RlZFBrID0gYWRkcmVzcy5lbmNvZGUoa2V5cy5wdWJsaWNLZXkpO1xuICAgIHJldHVybiB7YWRkcjogZW5jb2RlZFBrLCBzazoga2V5cy5zZWNyZXRLZXl9O1xufVxuXG4vKipcbiAqIHNlY3JldEtleVRvTW5lbW9uaWMgdGFrZXMgYW4gQWxnb3JhbmQgc2VjcmV0IGtleSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBtbmVtb25pYy5cbiAqIEBwYXJhbSBzayBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBzdHJpbmcgbW5lbW9uaWNcbiAqL1xuZnVuY3Rpb24gc2VjcmV0S2V5VG9NbmVtb25pYyhzaykge1xuICAgIC8vIGdldCB0aGUgc2VlZCBmcm9tIHRoZSBza1xuICAgIGxldCBzZWVkID0gc2suc2xpY2UoMCwgbmFjbC5TRUVEX0JUWUVTX0xFTkdUSCk7XG4gICAgcmV0dXJuIG1uZW1vbmljLm1uZW1vbmljRnJvbVNlZWQoc2VlZCk7XG59XG5cbi8qKlxuICogbW5lbW9uaWNUb01hc3RlckRlcml2YXRpb25LZXkgdGFrZXMgYSBtbmVtb25pYyBzdHJpbmcgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgbWFzdGVyIGRlcml2YXRpb24ga2V5LlxuICogQHBhcmFtIG1uIDI1IHdvcmRzIEFsZ29yYW5kIG1uZW1vbmljXG4gKiBAcmV0dXJucyBVaW50OEFycmF5XG4gKiBAdGhyb3dzIGVycm9yIGlmIGZhaWxzIHRvIGRlY29kZSB0aGUgbW5lbW9uaWNcbiAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb01hc3RlckRlcml2YXRpb25LZXkobW4pIHtcbiAgICByZXR1cm4gbW5lbW9uaWMuc2VlZEZyb21NbmVtb25pYyhtbik7XG59XG5cbi8qKlxuICogbWFzdGVyRGVyaXZhdGlvbktleVRvTW5lbW9uaWMgdGFrZXMgYSBtYXN0ZXIgZGVyaXZhdGlvbiBrZXkgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgbW5lbW9uaWMuXG4gKiBAcGFyYW0gbWRrIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIHN0cmluZyBtbmVtb25pY1xuICovXG5mdW5jdGlvbiBtYXN0ZXJEZXJpdmF0aW9uS2V5VG9NbmVtb25pYyhtZGspIHtcbiAgICByZXR1cm4gbW5lbW9uaWMubW5lbW9uaWNGcm9tU2VlZChtZGspO1xufVxuXG4vKipcbiAqIHNpZ25UcmFuc2FjdGlvbiB0YWtlcyBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgcGF5bWVudCBvciBrZXkgcmVnaXN0cmF0aW9uIGZpZWxkcyBhbmRcbiAqIGEgc2VjcmV0IGtleSBhbmQgcmV0dXJucyBhIHNpZ25lZCBibG9iLlxuICpcbiAqIFBheW1lbnQgdHJhbnNhY3Rpb24gZmllbGRzOiB0bywgYW1vdW50LCBmZWUsIGZpcnN0Um91bmQsIGxhc3RSb3VuZCwgZ2VuZXNpc0hhc2gsXG4gKiBub3RlKG9wdGlvbmFsKSwgR2VuZXNpc0lEKG9wdGlvbmFsKSwgY2xvc2VSZW1haW5kZXJUbyhvcHRpb25hbClcbiAqXG4gKiBLZXkgcmVnaXN0cmF0aW9uIGZpZWxkczogZmVlLCBmaXJzdFJvdW5kLCBsYXN0Um91bmQsIHZvdGVLZXksIHNlbGVjdGlvbktleSwgdm90ZUZpcnN0LFxuICogdm90ZUxhc3QsIHZvdGVLZXlEaWx1dGlvbiwgZ2VuZXNpc0hhc2gsIG5vdGUob3B0aW9uYWwpLCBHZW5lc2lzSUQob3B0aW9uYWwpXG4gKiBAcGFyYW0gdHhuIG9iamVjdCB3aXRoIGVpdGhlciBwYXltZW50IG9yIGtleSByZWdpc3RyYXRpb24gZmllbGRzXG4gKiBAcGFyYW0gc2sgQWxnb3JhbmQgU2VjcmV0IEtleVxuICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5zIHRoZSBiaW5hcnkgc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBpdHMgdHhJRFxuICovXG5mdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24odHhuLCBzaykge1xuICAgIC8vIEdldCBwayBmcm9tIHNrXG4gICAgbGV0IGtleSA9IG5hY2wua2V5UGFpckZyb21TZWNyZXRLZXkoc2spO1xuICAgIHR4bi5mcm9tID0gYWRkcmVzcy5lbmNvZGUoa2V5LnB1YmxpY0tleSk7XG4gICAgbGV0IGFsZ29UeG4gPSBuZXcgdHhuQnVpbGRlci5UcmFuc2FjdGlvbih0eG4pO1xuXG4gICAgcmV0dXJuIHtcInR4SURcIjogYWxnb1R4bi50eElEKCkudG9TdHJpbmcoKSwgXCJibG9iXCI6IGFsZ29UeG4uc2lnblR4bihzayl9O1xufVxuXG4vKipcbiAqIHNpZ25CaWQgdGFrZXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6IGJpZGRlciBrZXksIGJpZCBhbW91bnQsIG1heCBwcmljZSwgYmlkIElELCBhdWN0aW9uS2V5LCBhdWN0aW9uIElELFxuICogYW5kIGEgc2VjcmV0IGtleSBhbmQgcmV0dXJucyBhIHNpZ25lZCBibG9iIHRvIGJlIGluc2VydGVkIGludG8gYSB0cmFuc2FjdGlvbiBBbGdvcmFuZCBub3RlIGZpZWxkLlxuICogQHBhcmFtIGJpZCBBbGdvcmFuZCBCaWRcbiAqIEBwYXJhbSBzayBBbGdvcmFuZCBzZWNyZXQga2V5XG4gKiBAcmV0dXJucyBVaW50OEFycmF5IGJpbmFyeSBzaWduZWQgYmlkXG4gKi9cbmZ1bmN0aW9uIHNpZ25CaWQoYmlkLCBzaykge1xuICAgIGxldCBzaWduZWRCaWQgPSBuZXcgYmlkQnVpbGRlci5CaWQoYmlkKTtcbiAgICByZXR1cm4gc2lnbmVkQmlkLnNpZ25CaWQoc2spO1xufVxuXG4vKipcbiAqIHNpZ25CeXRlcyB0YWtlcyBhcmJpdHJhcnkgYnl0ZXMgYW5kIGEgc2VjcmV0IGtleSwgcHJlcGVuZHMgdGhlIGJ5dGVzIHdpdGggXCJNWFwiIGZvciBkb21haW4gc2VwYXJhdGlvbiwgc2lnbnMgdGhlIGJ5dGVzXG4gKiB3aXRoIHRoZSBwcml2YXRlIGtleSwgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBieXRlcyBVaW50OGFycmF5XG4gKiBAcGFyYW0gc2sgQWxnb3JhbmQgc2VjcmV0IGtleVxuICogQHJldHVybnMgYmluYXJ5IHNpZ25hdHVyZVxuICovXG5mdW5jdGlvbiBzaWduQnl0ZXMoYnl0ZXMsIHNrKSB7XG4gICAgbGV0IHRvQmVTaWduZWQgPSBCdWZmZXIuZnJvbSh1dGlscy5jb25jYXRBcnJheXMoU0lHTl9CWVRFU19QUkVGSVgsIGJ5dGVzKSk7XG4gICAgbGV0IHNpZyA9IG5hY2wuc2lnbih0b0JlU2lnbmVkLCBzayk7XG4gICAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiB2ZXJpZnlCeXRlcyB0YWtlcyBhcnJheSBvZiBieXRlcywgYW4gYWRkcmVzcywgYW5kIGEgc2lnbmF0dXJlIGFuZCB2ZXJpZmllcyBpZiB0aGUgc2lnbmF0dXJlIGlzIGNvcnJlY3QgZm9yIHRoZSBwdWJsaWNcbiAqIGtleSBhbmQgdGhlIGJ5dGVzICh0aGUgYnl0ZXMgc2hvdWxkIGhhdmUgYmVlbiBzaWduZWQgd2l0aCBcIk1YXCIgcHJlcGVuZGVkIGZvciBkb21haW4gc2VwYXJhdGlvbikuXG4gKiBAcGFyYW0gYnl0ZXMgVWludDhBcnJheVxuICogQHBhcmFtIHNpZ25hdHVyZSBiaW5hcnkgc2lnbmF0dXJlXG4gKiBAcGFyYW0gYWRkciBzdHJpbmcgYWRkcmVzc1xuICogQHJldHVybnMgYm9vbFxuICovXG5mdW5jdGlvbiB2ZXJpZnlCeXRlcyhieXRlcywgc2lnbmF0dXJlLCBhZGRyKSB7XG4gICAgdG9CZVZlcmlmaWVkID0gQnVmZmVyLmZyb20odXRpbHMuY29uY2F0QXJyYXlzKFNJR05fQllURVNfUFJFRklYLCBieXRlcykpO1xuICAgIGxldCBwayA9IGFkZHJlc3MuZGVjb2RlKGFkZHIpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gbmFjbC52ZXJpZnkodG9CZVZlcmlmaWVkLCBzaWduYXR1cmUsIHBrKTtcbn1cblxuLyoqXG4gKiBzaWduTXVsdGlzaWdUcmFuc2FjdGlvbiB0YWtlcyBhIHJhdyB0cmFuc2FjdGlvbiAoc2VlIHNpZ25UcmFuc2FjdGlvbiksIGEgbXVsdGlzaWcgcHJlaW1hZ2UsIGEgc2VjcmV0IGtleSwgYW5kIHJldHVybnNcbiAqIGEgbXVsdGlzaWcgdHJhbnNhY3Rpb24sIHdoaWNoIGlzIGEgYmxvYiByZXByZXNlbnRpbmcgYSB0cmFuc2FjdGlvbiBhbmQgbXVsdGlzaWduYXR1cmUgYWNjb3VudCBwcmVpbWFnZS4gVGhlIHJldHVybmVkXG4gKiBtdWx0aXNpZyB0eG4gY2FuIGFjY3VtdWxhdGUgYWRkaXRpb25hbCBzaWduYXR1cmVzIHRocm91Z2ggbWVyZ2VNdWx0aXNpZ1RyYW5zYWN0aW9ucyBvciBhcHBlbmRNdWx0aXNpZ1RyYW5zYWN0aW9uLlxuICogQHBhcmFtIHR4biBvYmplY3Qgd2l0aCBlaXRoZXIgcGF5bWVudCBvciBrZXkgcmVnaXN0cmF0aW9uIGZpZWxkc1xuICogQHBhcmFtIHZlcnNpb24gbXVsdGlzaWcgdmVyc2lvblxuICogQHBhcmFtIHRocmVzaG9sZCBtdWx0aXNpZyB0aHJlc2hvbGRcbiAqIEBwYXJhbSBhZGRycyBhIGxpc3Qgb2YgQWxnb3JhbmQgYWRkcmVzc2VzIHJlcHJlc2VudGluZyBwb3NzaWJsZSBzaWduZXJzIGZvciB0aGlzIG11bHRpc2lnLiBPcmRlciBpcyBpbXBvcnRhbnQuXG4gKiBAcGFyYW0gc2sgQWxnb3JhbmQgc2VjcmV0IGtleS4gVGhlIGNvcnJlc3BvbmRpbmcgcGsgc2hvdWxkIGJlIGluIHRoZSBwcmUgaW1hZ2UuXG4gKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyB0eElELCBhbmQgYmxvYiBvZiBwYXJ0aWFsbHkgc2lnbmVkIG11bHRpc2lnIHRyYW5zYWN0aW9uICh3aXRoIG11bHRpc2lnIHByZWltYWdlIGluZm9ybWF0aW9uKVxuICovXG5mdW5jdGlvbiBzaWduTXVsdGlzaWdUcmFuc2FjdGlvbih0eG4sIHt2ZXJzaW9uLCB0aHJlc2hvbGQsIGFkZHJzfSwgc2spIHtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBmcm9tIGZpZWxkIG1hdGNoZXMgdGhlIG1TaWdQcmVJbWFnZS4gSWYgZnJvbSBmaWVsZCBpcyBub3QgcG9wdWxhdGVkLCBmaWxsIGl0IGluLlxuICAgIGxldCBleHBlY3RlZEZyb21SYXcgPSBhZGRyZXNzLmZyb21NdWx0aXNpZ1ByZUltZ0FkZHJzKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIGFkZHJzfSk7XG4gICAgaWYgKHR4bi5oYXNPd25Qcm9wZXJ0eSgnZnJvbScpKSB7XG4gICAgICAgIGlmICh0eG4uZnJvbSAhPT0gZXhwZWN0ZWRGcm9tUmF3KSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9NVUxUSVNJR19CQURfU0VOREVSO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHhuLmZyb20gPSBleHBlY3RlZEZyb21SYXc7XG4gICAgfVxuICAgIGxldCBhbGdvVHhuID0gbmV3IG11bHRpc2lnLk11bHRpc2lnVHJhbnNhY3Rpb24odHhuKTtcbiAgICBjb25zdCBwa3MgPSBhZGRycy5tYXAoYWRkciA9PiB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLmRlY29kZShhZGRyKS5wdWJsaWNLZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJ0eElEXCI6IGFsZ29UeG4udHhJRCgpLnRvU3RyaW5nKCksXG4gICAgICAgIFwiYmxvYlwiOiBhbGdvVHhuLnBhcnRpYWxTaWduVHhuKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIHBrc30sIHNrKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIGFwcGVuZFNpZ25NdWx0aXNpZ1RyYW5zYWN0aW9uIHRha2VzIGEgbXVsdGlzaWcgdHJhbnNhY3Rpb24gYmxvYiwgYW5kIGFwcGVuZHMgb3VyIHNpZ25hdHVyZSB0byBpdC5cbiAqIFdoaWxlIHdlIGNvdWxkIGRlcml2ZSBwdWJsaWMga2V5IHByZWltYWdlcnkgZnJvbSB0aGUgcGFydGlhbGx5LXNpZ25lZCBtdWx0aXNpZyB0cmFuc2FjdGlvbixcbiAqIHdlIGFzayB0aGUgY2FsbGVyIHRvIHBhc3MgaXQgYmFjayBpbiwgdG8gZW5zdXJlIHRoZXkga25vdyB3aGF0IHRoZXkgYXJlIHNpZ25pbmcuXG4gKiBAcGFyYW0gbXVsdGlzaWdUeG5CbG9iIGFuIGVuY29kZWQgbXVsdGlzaWcgdHhuLiBTdXBwb3J0cyBub24tcGF5bWVudCB0eG4gdHlwZXMuXG4gKiBAcGFyYW0gdmVyc2lvbiBtdWx0aXNpZyB2ZXJzaW9uXG4gKiBAcGFyYW0gdGhyZXNob2xkIG11bHRpc2lnIHRocmVzaG9sZFxuICogQHBhcmFtIGFkZHJzIGEgbGlzdCBvZiBBbGdvcmFuZCBhZGRyZXNzZXMgcmVwcmVzZW50aW5nIHBvc3NpYmxlIHNpZ25lcnMgZm9yIHRoaXMgbXVsdGlzaWcuIE9yZGVyIGlzIGltcG9ydGFudC5cbiAqIEBwYXJhbSBzayBBbGdvcmFuZCBzZWNyZXQga2V5XG4gKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyB0eElELCBhbmQgYmxvYiByZXByZXNlbnRpbmcgZW5jb2RlZCBtdWx0aXNpZyB0eG5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kU2lnbk11bHRpc2lnVHJhbnNhY3Rpb24obXVsdGlzaWdUeG5CbG9iLCB7dmVyc2lvbiwgdGhyZXNob2xkLCBhZGRyc30sIHNrKSB7XG4gICAgY29uc3QgcGtzID0gYWRkcnMubWFwKGFkZHIgPT4ge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5kZWNvZGUoYWRkcikucHVibGljS2V5O1xuICAgIH0pO1xuICAgIC8vIG9idGFpbiB1bmRlcmx5aW5nIHR4biwgc2lnbiBpdCwgYW5kIG1lcmdlIGl0XG4gICAgbGV0IG11bHRpc2lnVHhPYmogPSBlbmNvZGluZy5kZWNvZGUobXVsdGlzaWdUeG5CbG9iKTtcbiAgICBsZXQgbXNpZ1R4biA9IG11bHRpc2lnLk11bHRpc2lnVHJhbnNhY3Rpb24uZnJvbV9vYmpfZm9yX2VuY29kaW5nKG11bHRpc2lnVHhPYmoudHhuKTtcbiAgICBsZXQgcGFydGlhbFNpZ25lZEJsb2IgPSBtc2lnVHhuLnBhcnRpYWxTaWduVHhuKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIHBrc30sIHNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBcInR4SURcIjogbXNpZ1R4bi50eElEKCkudG9TdHJpbmcoKSxcbiAgICAgICAgXCJibG9iXCI6IG1lcmdlTXVsdGlzaWdUcmFuc2FjdGlvbnMoW211bHRpc2lnVHhuQmxvYiwgcGFydGlhbFNpZ25lZEJsb2JdKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIG1lcmdlTXVsdGlzaWdUcmFuc2FjdGlvbnMgdGFrZXMgYSBsaXN0IG9mIG11bHRpc2lnIHRyYW5zYWN0aW9uIGJsb2JzLCBhbmQgbWVyZ2VzIHRoZW0uXG4gKiBAcGFyYW0gbXVsdGlzaWdUeG5CbG9icyBhIGxpc3Qgb2YgYmxvYnMgcmVwcmVzZW50aW5nIGVuY29kZWQgbXVsdGlzaWcgdHhuc1xuICogQHJldHVybnMgYmxvYiByZXByZXNlbnRpbmcgZW5jb2RlZCBtdWx0aXNpZyB0eG5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VNdWx0aXNpZ1RyYW5zYWN0aW9ucyhtdWx0aXNpZ1R4bkJsb2JzKSB7XG4gICAgcmV0dXJuIG11bHRpc2lnLm1lcmdlTXVsdGlzaWdUcmFuc2FjdGlvbnMobXVsdGlzaWdUeG5CbG9icyk7XG59XG5cbi8qKlxuICogbXVsdGlzaWdBZGRyZXNzIHRha2VzIG11bHRpc2lnIG1ldGFkYXRhIChwcmVpbWFnZSkgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgaHVtYW4gcmVhZGFibGUgQWxnb3JhbmQgYWRkcmVzcy5cbiAqIEBwYXJhbSB2ZXJzaW9uIG11dGxpc2lnIHZlcnNpb25cbiAqIEBwYXJhbSB0aHJlc2hvbGQgbXVsdGlzaWcgdGhyZXNob2xkXG4gKiBAcGFyYW0gYWRkcnMgbGlzdCBvZiBBbGdvcmFuZCBhZGRyZXNzZXNcbiAqL1xuZnVuY3Rpb24gbXVsdGlzaWdBZGRyZXNzKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIGFkZHJzfSkge1xuICAgIHJldHVybiBhZGRyZXNzLmZyb21NdWx0aXNpZ1ByZUltZ0FkZHJzKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIGFkZHJzfSk7XG59XG5cbi8qKlxuICogZW5jb2RlT2JqIHRha2VzIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIHJldHVybnMgaXRzIG1zZ3BhY2sgZW5jb2RpbmdcbiAqIE5vdGUgdGhhdCB0aGUgZW5jb2Rpbmcgc29ydHMgdGhlIGZpZWxkcyBhbHBoYWJldGljYWxseVxuICogQHBhcmFtIG8ganMgb2JqXG4gKiBAcmV0dXJucyBVaW50OEFycmF5IGJpbmFyeSByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBlbmNvZGVPYmoobykge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmNvZGluZy5lbmNvZGUobykpO1xufVxuXG4vKipcbiAqIGRlY29kZU9iaiB0YWtlcyBhIFVpbnQ4QXJyYXkgYW5kIHJldHVybnMgaXRzIGphdmFzY3JpcHQgb2JqXG4gKiBAcGFyYW0gbyBVaW50OEFycmF5IHRvIGRlY29kZVxuICogQHJldHVybnMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZU9iaihvKSB7XG4gICAgcmV0dXJuIGVuY29kaW5nLmRlY29kZShvKTtcbn1cblxuLyoqXG4gKiBtaWNyb2FsZ29zVG9BbGdvcyBjb252ZXJ0cyBtaWNyb2FsZ29zIHRvIGFsZ29zXG4gKiBAcGFyYW0gbWljcm9hbGdvcyBudW1iZXJcbiAqIEByZXR1cm5zIG51bWJlclxuICovXG5mdW5jdGlvbiBtaWNyb2FsZ29zVG9BbGdvcyhtaWNyb2FsZ29zKSB7XG4gICAgaWYgKG1pY3JvYWxnb3MgPCAwIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihtaWNyb2FsZ29zKSl7XG4gICAgICAgIHRocm93IEVSUk9SX0lOVkFMSURfTUlDUk9BTEdPUztcbiAgICB9XG4gICAgcmV0dXJuIG1pY3JvYWxnb3MvTUlDUk9BTEdPU19UT19BTEdPU19SQVRJT1xufVxuXG4vKipcbiAqIGFsZ29zVG9NaWNyb2FsZ29zIGNvbnZlcnRzIGFsZ29zIHRvIG1pY3JvYWxnb3NcbiAqIEBwYXJhbSBhbGdvcyBudW1iZXJcbiAqIEByZXR1cm5zIG51bWJlclxuICovXG5mdW5jdGlvbiBhbGdvc1RvTWljcm9hbGdvcyhhbGdvcykge1xuICAgIGxldCBtaWNyb2FsZ29zID0gYWxnb3MqTUlDUk9BTEdPU19UT19BTEdPU19SQVRJTztcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtaWNyb2FsZ29zKVxufVxuXG4vKipcbiAqIGNvbXB1dGVHcm91cElEIHJldHVybnMgZ3JvdXAgSUQgZm9yIGEgZ3JvdXAgb2YgdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0gdHhucyBhcnJheSBvZiB0cmFuc2FjdGlvbnMgKGV2ZXJ5IGVsZW1lbnQgaXMgYSBkaWN0IG9yIFRyYW5zYWN0aW9uKVxuICogQHJldHVybiBCdWZmZXJcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUdyb3VwSUQodHhucykge1xuICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgIGZvciAobGV0IHR4biBvZiB0eG5zKSAge1xuICAgICAgICBsZXQgdHggPSB0eG47XG4gICAgICAgIGlmICghKHR4biBpbnN0YW5jZW9mIHR4bkJ1aWxkZXIuVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICB0eCA9IG5ldyB0eG5CdWlsZGVyLlRyYW5zYWN0aW9uKHR4bik7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaGVzLnB1c2godHgucmF3VHhJRCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eGdyb3VwID0gbmV3IHR4bkJ1aWxkZXIuVHhHcm91cChoYXNoZXMpO1xuXG4gICAgY29uc3QgYnl0ZXMgPSB0eGdyb3VwLnRvQnl0ZSgpO1xuICAgIGNvbnN0IHRvQmVIYXNoZWQgPSBCdWZmZXIuZnJvbSh1dGlscy5jb25jYXRBcnJheXModHhncm91cC50YWcsIGJ5dGVzKSk7XG4gICAgY29uc3QgZ2lkID0gbmFjbC5nZW5lcmljSGFzaCh0b0JlSGFzaGVkKVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShnaWQpO1xufVxuXG4vKipcbiAqIGFzc2lnbkdyb3VwSUQgYXNzaWducyBncm91cCBpZCB0byBhIGdpdmVuIGxpc3Qgb2YgdW5zaWduZWQgdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0gdHhucyBhcnJheSBvZiB0cmFuc2FjdGlvbnMgKGV2ZXJ5IGVsZW1lbnQgaXMgYSBkaWN0IG9yIFRyYW5zYWN0aW9uKVxuICogQHBhcmFtIGZyb20gb3B0aW9uYWwgc2VuZGVyIGFkZHJlc3Mgc3BlY2lmeWluZyB3aGljaCB0cmFuc2FjdGlvbiByZXR1cm5cbiAqIEByZXR1cm4gcG9zc2libGUgbGlzdCBvZiBtYXRjaGluZyB0cmFuc2FjdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXNzaWduR3JvdXBJRCh0eG5zLCBmcm9tID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZ2lkID0gY29tcHV0ZUdyb3VwSUQodHhucyk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAodHggb2YgdHhucykge1xuICAgICAgICBpZiAoIWZyb20gfHwgYWRkcmVzcy5lbmNvZGUodHguZnJvbS5wdWJsaWNLZXkpID09IGZyb20pIHtcbiAgICAgICAgICAgIHR4Lmdyb3VwID0gZ2lkO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogbWFrZUxvZ2ljU2lnIGNyZWF0ZXMgTG9naWNTaWcgb2JqZWN0IGZyb20gcHJvZ3JhbSBhbmQgYXJndW1lbnRzXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcm9ncmFtIFByb2dyYW0gdG8gbWFrZSBMb2dpY1NpZyBmcm9tXG4gKiBAcGFyYW0ge1tVaW50OEFycmF5XX0gYXJncyBBcmd1bWVudHMgYXMgYXJyYXkgb2YgVWludDhBcnJheVxuICogQHJldHVybnMge0xvZ2ljU2lnfSBMb2dpY1NpZyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFrZUxvZ2ljU2lnKHByb2dyYW0sIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IGxvZ2ljc2lnLkxvZ2ljU2lnKHByb2dyYW0sIGFyZ3MpO1xufVxuXG4vKipcbiAqIHNpZ25Mb2dpY1NpZ1RyYW5zYWN0aW9uIHRha2VzICBhIHJhdyB0cmFuc2FjdGlvbiBhbmQgYSBMb2dpY1NpZyBvYmplY3QgYW5kIHJldHVybnMgYSBsb2dpY3NpZ1xuICogdHJhbnNhY3Rpb24gd2hpY2ggaXMgYSBibG9iIHJlcHJlc2VudGluZyBhIHRyYW5zYWN0aW9uIGFuZCBsb2dpY3NpZyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gdHhuIHRyYW5zYWN0aW9uIG9iamVjdFxuICogQHBhcmFtIHtMb2dpY1NpZ30gbHNpZyBsb2dpY3NpZyBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHR4SUQgYW5kIGJsb2IgcmVwcmVzZW50aW5nIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAqIEB0aHJvd3MgZXJyb3Igb24gZmFpbHVyZVxuICovXG5mdW5jdGlvbiBzaWduTG9naWNTaWdUcmFuc2FjdGlvbih0eG4sIGxzaWcpIHtcbiAgICBpZiAoIWxzaWcudmVyaWZ5KGFkZHJlc3MuZGVjb2RlKHR4bi5mcm9tKS5wdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2lnbmF0dXJlXCIpO1xuICAgIH1cblxuICAgIGxldCBhbGdvVHhuID0gbmV3IHR4bkJ1aWxkZXIuVHJhbnNhY3Rpb24odHhuKTtcblxuICAgIGxldCBsc3R4ID0ge1xuICAgICAgICBsc2lnOiBsc2lnLmdldF9vYmpfZm9yX2VuY29kaW5nKCksXG4gICAgICAgIHR4bjogYWxnb1R4bi5nZXRfb2JqX2Zvcl9lbmNvZGluZygpXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIFwidHhJRFwiOiBhbGdvVHhuLnR4SUQoKS50b1N0cmluZygpLFxuICAgICAgICBcImJsb2JcIjogZW5jb2RpbmcuZW5jb2RlKGxzdHgpXG4gICAgfTtcbn1cblxuXG4vKipcbiAqIG1ha2VQYXltZW50VHhuIHRha2VzIHBheW1lbnQgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgVHJhbnNhY3Rpb24gb2JqZWN0XG4gKiBAcGFyYW0gZnJvbSAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBBbGdvcmFuZCBhZGRyZXNzIG9mIHNlbmRlclxuICogQHBhcmFtIHRvIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEFsZ29yYW5kIGFkZHJlc3Mgb2YgcmVjaXBpZW50XG4gKiBAcGFyYW0gZmVlIC0gaW50ZWdlciBmZWUgcGVyIGJ5dGUsIGluIG1pY3JvQWxnb3MuIGZvciBhIGZsYXQgZmVlLCBvdmVyd3JpdGUgdGhlIGZlZSBwcm9wZXJ0eSBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBAcGFyYW0gYW1vdW50IC0gaW50ZWdlciBhbW91bnQgdG8gc2VuZCwgaW4gbWljcm9BbGdvc1xuICogQHBhcmFtIGNsb3NlUmVtYWluZGVyVG8gLSBvcHRpb25hbGx5IGNsb3NlIG91dCByZW1haW5pbmcgYWNjb3VudCBiYWxhbmNlIHRvIHRoaXMgYWNjb3VudCwgcmVwcmVzZW50ZWQgYXMgc3RyaW5nIHJlcCBvZiBBbGdvcmFuZCBhZGRyZXNzXG4gKiBAcGFyYW0gZmlyc3RSb3VuZCAtIGludGVnZXIgZmlyc3QgcHJvdG9jb2wgcm91bmQgb24gd2hpY2ggdGhpcyB0eG4gaXMgdmFsaWRcbiAqIEBwYXJhbSBsYXN0Um91bmQgLSBpbnRlZ2VyIGxhc3QgcHJvdG9jb2wgcm91bmQgb24gd2hpY2ggdGhpcyB0eG4gaXMgdmFsaWRcbiAqIEBwYXJhbSBub3RlIC0gdWludDhhcnJheSBvZiBhcmJpdHJhcnkgZGF0YSBmb3Igc2VuZGVyIHRvIHN0b3JlXG4gKiBAcGFyYW0gZ2VuZXNpc0hhc2ggLSBzdHJpbmcgc3BlY2lmaWVzIGhhc2ggZ2VuZXNpcyBibG9jayBvZiBuZXR3b3JrIGluIHVzZVxuICogQHBhcmFtIGdlbmVzaXNJRCAtIHN0cmluZyBzcGVjaWZpZXMgZ2VuZXNpcyBJRCBvZiBuZXR3b3JrIGluIHVzZVxuICogQHJldHVybnMge1RyYW5zYWN0aW9ufVxuICovXG5mdW5jdGlvbiBtYWtlUGF5bWVudFR4bihmcm9tLCB0bywgZmVlLCBhbW91bnQsIGNsb3NlUmVtYWluZGVyVG8sIGZpcnN0Um91bmQsIGxhc3RSb3VuZCwgbm90ZSwgZ2VuZXNpc0hhc2gsIGdlbmVzaXNJRCkge1xuICAgIGxldCBvID0ge1xuICAgICAgICBcImZyb21cIjogZnJvbSxcbiAgICAgICAgXCJ0b1wiOiB0byxcbiAgICAgICAgXCJmZWVcIjogZmVlLFxuICAgICAgICBcImFtb3VudFwiOiBhbW91bnQsXG4gICAgICAgIFwiY2xvc2VSZW1haW5kZXJUb1wiOiBjbG9zZVJlbWFpbmRlclRvLFxuICAgICAgICBcImZpcnN0Um91bmRcIjogZmlyc3RSb3VuZCxcbiAgICAgICAgXCJsYXN0Um91bmRcIjogbGFzdFJvdW5kLFxuICAgICAgICBcIm5vdGVcIjogbm90ZSxcbiAgICAgICAgXCJnZW5lc2lzSGFzaFwiOiBnZW5lc2lzSGFzaCxcbiAgICAgICAgXCJnZW5lc2lzSURcIjogZ2VuZXNpc0lELFxuICAgICAgICBcInR5cGVcIjogXCJwYXlcIlxuICAgIH07XG4gICAgcmV0dXJuIG5ldyB0eG5CdWlsZGVyLlRyYW5zYWN0aW9uKG8pO1xufVxuXG4vKipcbiAqIG1ha2VLZXlSZWdpc3RyYXRpb25UeG4gdGFrZXMga2V5IHJlZ2lzdHJhdGlvbiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBUcmFuc2FjdGlvbiBvYmplY3QgZm9yXG4gKiB0aGF0IGtleSByZWdpc3RyYXRpb24gb3BlcmF0aW9uXG4gKlxuICogQHBhcmFtIGZyb20gLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyBvZiBzZW5kZXJcbiAqIEBwYXJhbSBmZWUgLSBpbnRlZ2VyIGZlZSBwZXIgYnl0ZSwgaW4gbWljcm9BbGdvcy4gZm9yIGEgZmxhdCBmZWUsIG92ZXJ3cml0ZSB0aGUgZmVlIHByb3BlcnR5IG9uIHRoZSByZXR1cm5lZCBvYmplY3RcbiAqIEBwYXJhbSBmaXJzdFJvdW5kIC0gaW50ZWdlciBmaXJzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIGxhc3RSb3VuZCAtIGludGVnZXIgbGFzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIG5vdGUgLSB1aW50OGFycmF5IG9mIGFyYml0cmFyeSBkYXRhIGZvciBzZW5kZXIgdG8gc3RvcmVcbiAqIEBwYXJhbSBnZW5lc2lzSGFzaCAtIHN0cmluZyBzcGVjaWZpZXMgaGFzaCBnZW5lc2lzIGJsb2NrIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gZ2VuZXNpc0lEIC0gc3RyaW5nIHNwZWNpZmllcyBnZW5lc2lzIElEIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gdm90ZUtleSAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB2b3Rpbmcga2V5LiBmb3Iga2V5IGRlcmVnaXN0cmF0aW9uLCBsZWF2ZSB1bmRlZmluZWRcbiAqIEBwYXJhbSBzZWxlY3Rpb25LZXkgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc2VsZWN0aW9uIGtleS4gZm9yIGtleSBkZXJlZ2lzdHJhdGlvbiwgbGVhdmUgdW5kZWZpbmVkXG4gKiBAcGFyYW0gdm90ZUZpcnN0IC0gZmlyc3Qgcm91bmQgb24gd2hpY2ggdm90ZUtleSBpcyB2YWxpZFxuICogQHBhcmFtIHZvdGVMYXN0IC0gbGFzdCByb3VuZCBvbiB3aGljaCB2b3RlS2V5IGlzIHZhbGlkXG4gKiBAcGFyYW0gdm90ZUtleURpbHV0aW9uIC0gaW50ZWdlclxuICogQHJldHVybnMge1RyYW5zYWN0aW9ufVxuICovXG5mdW5jdGlvbiBtYWtlS2V5UmVnaXN0cmF0aW9uVHhuKGZyb20sIGZlZSwgZmlyc3RSb3VuZCwgbGFzdFJvdW5kLCBub3RlLCBnZW5lc2lzSGFzaCwgZ2VuZXNpc0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b3RlS2V5LCBzZWxlY3Rpb25LZXksIHZvdGVGaXJzdCwgdm90ZUxhc3QsIHZvdGVLZXlEaWx1dGlvbikge1xuICAgIGxldCBvID0ge1xuICAgICAgICBcImZyb21cIjogZnJvbSxcbiAgICAgICAgXCJmZWVcIjogZmVlLFxuICAgICAgICBcImZpcnN0Um91bmRcIjogZmlyc3RSb3VuZCxcbiAgICAgICAgXCJsYXN0Um91bmRcIjogbGFzdFJvdW5kLFxuICAgICAgICBcIm5vdGVcIjogbm90ZSxcbiAgICAgICAgXCJnZW5lc2lzSGFzaFwiOiBnZW5lc2lzSGFzaCxcbiAgICAgICAgXCJ2b3RlS2V5XCI6IHZvdGVLZXksXG4gICAgICAgIFwic2VsZWN0aW9uS2V5XCI6IHNlbGVjdGlvbktleSxcbiAgICAgICAgXCJ2b3RlRmlyc3RcIjogdm90ZUZpcnN0LFxuICAgICAgICBcInZvdGVMYXN0XCI6IHZvdGVMYXN0LFxuICAgICAgICBcInZvdGVLZXlEaWx1dGlvblwiOiB2b3RlS2V5RGlsdXRpb24sXG4gICAgICAgIFwiZ2VuZXNpc0lEXCI6IGdlbmVzaXNJRCxcbiAgICAgICAgXCJ0eXBlXCI6IFwia2V5cmVnXCJcbiAgICB9O1xuICAgIHJldHVybiBuZXcgdHhuQnVpbGRlci5UcmFuc2FjdGlvbihvKTtcbn1cblxuLyoqIG1ha2VBc3NldENyZWF0ZVR4biB0YWtlcyBhc3NldCBjcmVhdGlvbiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBUcmFuc2FjdGlvbiBvYmplY3RcbiAqIGZvciBjcmVhdGluZyB0aGF0IGFzc2V0XG4gKlxuICogQHBhcmFtIGZyb20gLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyBvZiBzZW5kZXJcbiAqIEBwYXJhbSBmZWUgLSBpbnRlZ2VyIGZlZSBwZXIgYnl0ZSwgaW4gbWljcm9BbGdvcy4gZm9yIGEgZmxhdCBmZWUsIG92ZXJ3cml0ZSB0aGUgZmVlIHByb3BlcnR5IG9uIHRoZSByZXR1cm5lZCBvYmplY3RcbiAqIEBwYXJhbSBmaXJzdFJvdW5kIC0gaW50ZWdlciBmaXJzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIGxhc3RSb3VuZCAtIGludGVnZXIgbGFzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIG5vdGUgLSB1aW50OGFycmF5IG9mIGFyYml0cmFyeSBkYXRhIGZvciBzZW5kZXIgdG8gc3RvcmVcbiAqIEBwYXJhbSBnZW5lc2lzSGFzaCAtIHN0cmluZyBzcGVjaWZpZXMgaGFzaCBnZW5lc2lzIGJsb2NrIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gZ2VuZXNpc0lEIC0gc3RyaW5nIHNwZWNpZmllcyBnZW5lc2lzIElEIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gdG90YWwgLSBpbnRlZ2VyIHRvdGFsIHN1cHBseSBvZiB0aGUgYXNzZXRcbiAqIEBwYXJhbSBkZWZhdWx0RnJvemVuIC0gYm9vbGVhbiB3aGV0aGVyIGFzc2V0IGFjY291bnRzIHNob3VsZCBkZWZhdWx0IHRvIGJlaW5nIGZyb3plblxuICogQHBhcmFtIG1hbmFnZXIgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyBpbiBjaGFyZ2Ugb2YgcmVzZXJ2ZSwgZnJlZXplLCBjbGF3YmFjaywgZGVzdHJ1Y3Rpb24sIGV0Y1xuICogQHBhcmFtIHJlc2VydmUgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyByZXByZXNlbnRpbmcgYXNzZXQgcmVzZXJ2ZVxuICogQHBhcmFtIGZyZWV6ZSAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBBbGdvcmFuZCBhZGRyZXNzIHdpdGggcG93ZXIgdG8gZnJlZXplL3VuZnJlZXplIGFzc2V0IGhvbGRpbmdzXG4gKiBAcGFyYW0gY2xhd2JhY2sgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyB3aXRoIHBvd2VyIHRvIHJldm9rZSBhc3NldCBob2xkaW5nc1xuICogQHBhcmFtIHVuaXROYW1lIC0gc3RyaW5nIHVuaXRzIG5hbWUgZm9yIHRoaXMgYXNzZXRcbiAqIEBwYXJhbSBhc3NldE5hbWUgLSBzdHJpbmcgbmFtZSBmb3IgdGhpcyBhc3NldFxuICogQHBhcmFtIGFzc2V0VVJMIC0gc3RyaW5nIFVSTCByZWxhdGluZyB0byB0aGlzIGFzc2V0XG4gKiBAcGFyYW0gYXNzZXRNZXRhZGF0YUhhc2ggLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc29tZSBzb3J0IG9mIGhhc2ggY29tbWl0bWVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIGFzc2V0XG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1ha2VBc3NldENyZWF0ZVR4bihmcm9tLCBmZWUsIGZpcnN0Um91bmQsIGxhc3RSb3VuZCwgbm90ZSwgZ2VuZXNpc0hhc2gsIGdlbmVzaXNJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCwgZGVmYXVsdEZyb3plbiwgbWFuYWdlciwgcmVzZXJ2ZSwgZnJlZXplLCBjbGF3YmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0TmFtZSwgYXNzZXROYW1lLCBhc3NldFVSTCwgYXNzZXRNZXRhZGF0YUhhc2gpIHtcbiAgICBsZXQgbyA9IHtcbiAgICAgICAgXCJmcm9tXCI6IGZyb20sXG4gICAgICAgIFwiZmVlXCI6IGZlZSxcbiAgICAgICAgXCJmaXJzdFJvdW5kXCI6IGZpcnN0Um91bmQsXG4gICAgICAgIFwibGFzdFJvdW5kXCI6IGxhc3RSb3VuZCxcbiAgICAgICAgXCJub3RlXCI6IG5vdGUsXG4gICAgICAgIFwiZ2VuZXNpc0hhc2hcIjogZ2VuZXNpc0hhc2gsXG4gICAgICAgIFwiYXNzZXRUb3RhbFwiOiB0b3RhbCxcbiAgICAgICAgXCJhc3NldERlZmF1bHRGcm96ZW5cIjogZGVmYXVsdEZyb3plbixcbiAgICAgICAgXCJhc3NldFVuaXROYW1lXCI6IHVuaXROYW1lLFxuICAgICAgICBcImFzc2V0TmFtZVwiOiBhc3NldE5hbWUsXG4gICAgICAgIFwiYXNzZXRVUkxcIjogYXNzZXRVUkwsXG4gICAgICAgIFwiYXNzZXRNZXRhZGF0YUhhc2hcIjogYXNzZXRNZXRhZGF0YUhhc2gsXG4gICAgICAgIFwiYXNzZXRNYW5hZ2VyXCI6IG1hbmFnZXIsXG4gICAgICAgIFwiYXNzZXRSZXNlcnZlXCI6IHJlc2VydmUsXG4gICAgICAgIFwiYXNzZXRGcmVlemVcIjogZnJlZXplLFxuICAgICAgICBcImFzc2V0Q2xhd2JhY2tcIjogY2xhd2JhY2ssXG4gICAgICAgIFwiZ2VuZXNpc0lEXCI6IGdlbmVzaXNJRCxcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWNmZ1wiXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IHR4bkJ1aWxkZXIuVHJhbnNhY3Rpb24obyk7XG59XG5cbi8qKiBtYWtlQXNzZXRDb25maWdUeG4gY2FuIGJlIGlzc3VlZCBieSB0aGUgYXNzZXQgbWFuYWdlciB0byBjaGFuZ2UgdGhlIG1hbmFnZXIsIHJlc2VydmUsIGZyZWV6ZSwgb3IgY2xhd2JhY2tcbiAqIHlvdSBtdXN0IHJlc3BlY2lmeSBleGlzdGluZyBhZGRyZXNzZXMgdG8ga2VlcCB0aGVtIHRoZSBzYW1lOyBsZWF2aW5nIGEgZmllbGQgYmxhbmsgaXMgdGhlIHNhbWUgYXMgdHVybmluZ1xuICogdGhhdCBmZWF0dXJlIG9mZiBmb3IgdGhpcyBhc3NldFxuICpcbiAqIEBwYXJhbSBmcm9tIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEFsZ29yYW5kIGFkZHJlc3Mgb2Ygc2VuZGVyXG4gKiBAcGFyYW0gZmVlIC0gaW50ZWdlciBmZWUgcGVyIGJ5dGUsIGluIG1pY3JvQWxnb3MuIGZvciBhIGZsYXQgZmVlLCBvdmVyd3JpdGUgdGhlIGZlZSBwcm9wZXJ0eSBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBAcGFyYW0gZmlyc3RSb3VuZCAtIGludGVnZXIgZmlyc3QgcHJvdG9jb2wgcm91bmQgb24gd2hpY2ggdGhpcyB0eG4gaXMgdmFsaWRcbiAqIEBwYXJhbSBsYXN0Um91bmQgLSBpbnRlZ2VyIGxhc3QgcHJvdG9jb2wgcm91bmQgb24gd2hpY2ggdGhpcyB0eG4gaXMgdmFsaWRcbiAqIEBwYXJhbSBub3RlIC0gdWludDhhcnJheSBvZiBhcmJpdHJhcnkgZGF0YSBmb3Igc2VuZGVyIHRvIHN0b3JlXG4gKiBAcGFyYW0gZ2VuZXNpc0hhc2ggLSBzdHJpbmcgc3BlY2lmaWVzIGhhc2ggZ2VuZXNpcyBibG9jayBvZiBuZXR3b3JrIGluIHVzZVxuICogQHBhcmFtIGdlbmVzaXNJRCAtIHN0cmluZyBzcGVjaWZpZXMgZ2VuZXNpcyBJRCBvZiBuZXR3b3JrIGluIHVzZVxuICogQHBhcmFtIGFzc2V0SW5kZXggLSBpbnQgYXNzZXQgaW5kZXggdW5pcXVlbHkgc3BlY2lmeWluZyB0aGUgYXNzZXRcbiAqIEBwYXJhbSBtYW5hZ2VyIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIG5ldyBhc3NldCBtYW5hZ2VyIEFsZ29yYW5kIGFkZHJlc3NcbiAqIEBwYXJhbSByZXNlcnZlIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIG5ldyByZXNlcnZlIEFsZ29yYW5kIGFkZHJlc3NcbiAqIEBwYXJhbSBmcmVlemUgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgbmV3IGZyZWV6ZSBtYW5hZ2VyIEFsZ29yYW5kIGFkZHJlc3NcbiAqIEBwYXJhbSBjbGF3YmFjayAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBuZXcgcmV2b2NhdGlvbiBtYW5hZ2VyIEFsZ29yYW5kIGFkZHJlc3NcbiAqIEBwYXJhbSBzdHJpY3RFbXB0eUFkZHJlc3NDaGVja2luZyAtIGJvb2xlYW4gLSB0aHJvdyBhbiBlcnJvciBpZiBhbnkgb2YgbWFuYWdlciwgcmVzZXJ2ZSwgZnJlZXplLCBvciBjbGF3YmFjayBhcmUgdW5kZWZpbmVkLiBvcHRpb25hbCwgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWFrZUFzc2V0Q29uZmlnVHhuKGZyb20sIGZlZSwgZmlyc3RSb3VuZCwgbGFzdFJvdW5kLCBub3RlLCBnZW5lc2lzSGFzaCwgZ2VuZXNpc0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0SW5kZXgsIG1hbmFnZXIsIHJlc2VydmUsIGZyZWV6ZSwgY2xhd2JhY2ssIHN0cmljdEVtcHR5QWRkcmVzc0NoZWNraW5nPXRydWUpIHtcbiAgICBpZiAoc3RyaWN0RW1wdHlBZGRyZXNzQ2hlY2tpbmcgJiYgKChtYW5hZ2VyID09PSB1bmRlZmluZWQpIHx8IChyZXNlcnZlID09PSB1bmRlZmluZWQpIHx8IChmcmVlemUgPT09IHVuZGVmaW5lZCkgfHwgKGNsYXdiYWNrID09PSB1bmRlZmluZWQpKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcInN0cmljdCBlbXB0eSBhZGRyZXNzIGNoZWNraW5nIHdhcyB0dXJuZWQgb24sIGJ1dCBhdCBsZWFzdCBvbmUgZW1wdHkgYWRkcmVzcyB3YXMgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIGxldCBvID0ge1xuICAgICAgICBcImZyb21cIjogZnJvbSxcbiAgICAgICAgXCJmZWVcIjogZmVlLFxuICAgICAgICBcImZpcnN0Um91bmRcIjogZmlyc3RSb3VuZCxcbiAgICAgICAgXCJsYXN0Um91bmRcIjogbGFzdFJvdW5kLFxuICAgICAgICBcImdlbmVzaXNIYXNoXCI6IGdlbmVzaXNIYXNoLFxuICAgICAgICBcImdlbmVzaXNJRFwiOiBnZW5lc2lzSUQsXG4gICAgICAgIFwiYXNzZXRJbmRleFwiOiBhc3NldEluZGV4LFxuICAgICAgICBcImFzc2V0TWFuYWdlclwiOiBtYW5hZ2VyLFxuICAgICAgICBcImFzc2V0UmVzZXJ2ZVwiOiByZXNlcnZlLFxuICAgICAgICBcImFzc2V0RnJlZXplXCI6IGZyZWV6ZSxcbiAgICAgICAgXCJhc3NldENsYXdiYWNrXCI6IGNsYXdiYWNrLFxuICAgICAgICBcInR5cGVcIjogXCJhY2ZnXCIsXG4gICAgICAgIFwibm90ZVwiOiBub3RlXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IHR4bkJ1aWxkZXIuVHJhbnNhY3Rpb24obyk7XG59XG5cbi8qKiBtYWtlQXNzZXREZXN0cm95VHhuIHdpbGwgYWxsb3cgdGhlIGFzc2V0J3MgbWFuYWdlciB0byByZW1vdmUgdGhpcyBhc3NldCBmcm9tIHRoZSBsZWRnZXIsIHNvIGxvbmdcbiAqIGFzIGFsbCBvdXRzdGFuZGluZyBhc3NldHMgYXJlIGhlbGQgYnkgdGhlIGNyZWF0b3IuXG4gKlxuICogQHBhcmFtIGZyb20gLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyBvZiBzZW5kZXJcbiAqIEBwYXJhbSBmZWUgLSBpbnRlZ2VyIGZlZSBwZXIgYnl0ZSwgaW4gbWljcm9BbGdvcy4gZm9yIGEgZmxhdCBmZWUsIG92ZXJ3cml0ZSB0aGUgZmVlIHByb3BlcnR5IG9uIHRoZSByZXR1cm5lZCBvYmplY3RcbiAqIEBwYXJhbSBmaXJzdFJvdW5kIC0gaW50ZWdlciBmaXJzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIGxhc3RSb3VuZCAtIGludGVnZXIgbGFzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIG5vdGUgLSB1aW50OGFycmF5IG9mIGFyYml0cmFyeSBkYXRhIGZvciBzZW5kZXIgdG8gc3RvcmVcbiAqIEBwYXJhbSBnZW5lc2lzSGFzaCAtIHN0cmluZyBzcGVjaWZpZXMgaGFzaCBnZW5lc2lzIGJsb2NrIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gZ2VuZXNpc0lEIC0gc3RyaW5nIHNwZWNpZmllcyBnZW5lc2lzIElEIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gYXNzZXRJbmRleCAtIGludCBhc3NldCBpbmRleCB1bmlxdWVseSBzcGVjaWZ5aW5nIHRoZSBhc3NldFxuICogQHJldHVybnMge1RyYW5zYWN0aW9ufVxuICovXG5mdW5jdGlvbiBtYWtlQXNzZXREZXN0cm95VHhuKGZyb20sIGZlZSwgZmlyc3RSb3VuZCwgbGFzdFJvdW5kLCBub3RlLCBnZW5lc2lzSGFzaCwgZ2VuZXNpc0lELCBhc3NldEluZGV4KSB7XG4gICAgbGV0IG8gPSB7XG4gICAgICAgIFwiZnJvbVwiOiBmcm9tLFxuICAgICAgICBcImZlZVwiOiBmZWUsXG4gICAgICAgIFwiZmlyc3RSb3VuZFwiOiBmaXJzdFJvdW5kLFxuICAgICAgICBcImxhc3RSb3VuZFwiOiBsYXN0Um91bmQsXG4gICAgICAgIFwiZ2VuZXNpc0hhc2hcIjogZ2VuZXNpc0hhc2gsXG4gICAgICAgIFwiZ2VuZXNpc0lEXCI6IGdlbmVzaXNJRCxcbiAgICAgICAgXCJhc3NldEluZGV4XCI6IGFzc2V0SW5kZXgsXG4gICAgICAgIFwidHlwZVwiOiBcImFjZmdcIixcbiAgICAgICAgXCJub3RlXCI6IG5vdGVcbiAgICB9O1xuICAgIHJldHVybiBuZXcgdHhuQnVpbGRlci5UcmFuc2FjdGlvbihvKTtcbn1cblxuLyoqIG1ha2VBc3NldEZyZWV6ZVR4biB3aWxsIGFsbG93IHRoZSBhc3NldCdzIGZyZWV6ZSBtYW5hZ2VyIHRvIGZyZWV6ZSBvciB1bi1mcmVlemUgYW4gYWNjb3VudCxcbiAqIGJsb2NraW5nIG9yIGFsbG93aW5nIGFzc2V0IHRyYW5zZmVycyB0byBhbmQgZnJvbSB0aGUgdGFyZ2V0ZWQgYWNjb3VudC5cbiAqXG4gKiBAcGFyYW0gZnJvbSAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBBbGdvcmFuZCBhZGRyZXNzIG9mIHNlbmRlclxuICogQHBhcmFtIGZlZSAtIGludGVnZXIgZmVlIHBlciBieXRlLCBpbiBtaWNyb0FsZ29zLiBmb3IgYSBmbGF0IGZlZSwgb3ZlcndyaXRlIHRoZSBmZWUgcHJvcGVydHkgb24gdGhlIHJldHVybmVkIG9iamVjdFxuICogQHBhcmFtIGZpcnN0Um91bmQgLSBpbnRlZ2VyIGZpcnN0IHByb3RvY29sIHJvdW5kIG9uIHdoaWNoIHRoaXMgdHhuIGlzIHZhbGlkXG4gKiBAcGFyYW0gbGFzdFJvdW5kIC0gaW50ZWdlciBsYXN0IHByb3RvY29sIHJvdW5kIG9uIHdoaWNoIHRoaXMgdHhuIGlzIHZhbGlkXG4gKiBAcGFyYW0gbm90ZSAtIHVpbnQ4YXJyYXkgb2YgYXJiaXRyYXJ5IGRhdGEgZm9yIHNlbmRlciB0byBzdG9yZVxuICogQHBhcmFtIGdlbmVzaXNIYXNoIC0gc3RyaW5nIHNwZWNpZmllcyBoYXNoIGdlbmVzaXMgYmxvY2sgb2YgbmV0d29yayBpbiB1c2VcbiAqIEBwYXJhbSBnZW5lc2lzSUQgLSBzdHJpbmcgc3BlY2lmaWVzIGdlbmVzaXMgSUQgb2YgbmV0d29yayBpbiB1c2VcbiAqIEBwYXJhbSBhc3NldEluZGV4IC0gaW50IGFzc2V0IGluZGV4IHVuaXF1ZWx5IHNwZWNpZnlpbmcgdGhlIGFzc2V0XG4gKiBAcGFyYW0gZnJlZXplVGFyZ2V0IC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEFsZ29yYW5kIGFkZHJlc3MgYmVpbmcgZnJvemVuIG9yIHVuZnJvemVuXG4gKiBAcGFyYW0gZnJlZXplU3RhdGUgLSB0cnVlIGlmIGZyZWV6ZVRhcmdldCBzaG91bGQgYmUgZnJvemVuLCBmYWxzZSBpZiBmcmVlemVUYXJnZXQgc2hvdWxkIGJlIGFsbG93ZWQgdG8gdHJhbnNhY3RcbiAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWFrZUFzc2V0RnJlZXplVHhuKGZyb20sIGZlZSwgZmlyc3RSb3VuZCwgbGFzdFJvdW5kLCBub3RlLCBnZW5lc2lzSGFzaCwgZ2VuZXNpc0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0SW5kZXgsIGZyZWV6ZVRhcmdldCwgZnJlZXplU3RhdGUpIHtcbiAgICBsZXQgbyA9IHtcbiAgICAgICAgXCJmcm9tXCI6IGZyb20sXG4gICAgICAgIFwiZmVlXCI6IGZlZSxcbiAgICAgICAgXCJmaXJzdFJvdW5kXCI6IGZpcnN0Um91bmQsXG4gICAgICAgIFwibGFzdFJvdW5kXCI6IGxhc3RSb3VuZCxcbiAgICAgICAgXCJnZW5lc2lzSGFzaFwiOiBnZW5lc2lzSGFzaCxcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWZyelwiLFxuICAgICAgICBcImZyZWV6ZUFjY291bnRcIjogZnJlZXplVGFyZ2V0LFxuICAgICAgICBcImFzc2V0SW5kZXhcIjogYXNzZXRJbmRleCxcbiAgICAgICAgXCJmcmVlemVTdGF0ZVwiIDogZnJlZXplU3RhdGUsXG4gICAgICAgIFwibm90ZVwiOiBub3RlXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IHR4bkJ1aWxkZXIuVHJhbnNhY3Rpb24obyk7XG59XG5cbi8qKiBtYWtlQXNzZXRUcmFuc2ZlclR4biBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvbiBvZiBhbiBhc3NldCB0cmFuc2ZlciB0cmFuc2FjdGlvbi5cbiAqIFNwZWNpYWwgY2FzZTogdG8gYmVnaW4gYWNjZXB0aW5nIGFzc2V0cywgc2V0IGFtb3VudD0wIGFuZCBmcm9tPXRvLlxuICpcbiAqIEBwYXJhbSBmcm9tIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEFsZ29yYW5kIGFkZHJlc3Mgb2Ygc2VuZGVyXG4gKiBAcGFyYW0gdG8gLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyBvZiBhc3NldCByZWNpcGllbnRcbiAqIEBwYXJhbSBjbG9zZVJlbWFpbmRlclRvIC0gb3B0aW9uYWwgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgQWxnb3JhbmQgYWRkcmVzcyAtIGlmIHByb3ZpZGVkLFxuICogc2VuZCBhbGwgcmVtYWluaW5nIGFzc2V0cyBhZnRlciB0cmFuc2ZlciB0byB0aGUgXCJjbG9zZVJlbWFpbmRlclRvXCIgYWRkcmVzcyBhbmQgY2xvc2UgXCJmcm9tXCIncyBhc3NldCBob2xkaW5nc1xuICogQHBhcmFtIHJldm9jYXRpb25UYXJnZXQgLSBvcHRpb25hbCAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBBbGdvcmFuZCBhZGRyZXNzIC0gaWYgcHJvdmlkZWQsXG4gKiBhbmQgaWYgXCJmcm9tXCIgaXMgdGhlIGFzc2V0J3MgcmV2b2NhdGlvbiBtYW5hZ2VyLCB0aGVuIGRlZHVjdCBmcm9tIFwicmV2b2NhdGlvblRhcmdldFwiIHJhdGhlciB0aGFuIFwiZnJvbVwiXG4gKiBAcGFyYW0gZmVlIC0gaW50ZWdlciBmZWUgcGVyIGJ5dGUsIGluIG1pY3JvQWxnb3MuIGZvciBhIGZsYXQgZmVlLCBvdmVyd3JpdGUgdGhlIGZlZSBwcm9wZXJ0eSBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBAcGFyYW0gYW1vdW50IC0gaW50ZWdlciBhbW91bnQgb2YgYXNzZXRzIHRvIHNlbmRcbiAqIEBwYXJhbSBmaXJzdFJvdW5kIC0gaW50ZWdlciBmaXJzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIGxhc3RSb3VuZCAtIGludGVnZXIgbGFzdCBwcm90b2NvbCByb3VuZCBvbiB3aGljaCB0aGlzIHR4biBpcyB2YWxpZFxuICogQHBhcmFtIG5vdGUgLSB1aW50OGFycmF5IG9mIGFyYml0cmFyeSBkYXRhIGZvciBzZW5kZXIgdG8gc3RvcmVcbiAqIEBwYXJhbSBnZW5lc2lzSGFzaCAtIHN0cmluZyBzcGVjaWZpZXMgaGFzaCBnZW5lc2lzIGJsb2NrIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gZ2VuZXNpc0lEIC0gc3RyaW5nIHNwZWNpZmllcyBnZW5lc2lzIElEIG9mIG5ldHdvcmsgaW4gdXNlXG4gKiBAcGFyYW0gYXNzZXRJbmRleCAtIGludCBhc3NldCBpbmRleCB1bmlxdWVseSBzcGVjaWZ5aW5nIHRoZSBhc3NldFxuICogQHBhcmFtIGxlYXNlIC0gc2VlIG1ha2VQYXltZW50VHhuXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1ha2VBc3NldFRyYW5zZmVyVHhuKGZyb20sIHRvLCBjbG9zZVJlbWFpbmRlclRvLCByZXZvY2F0aW9uVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVlLCBhbW91bnQsIGZpcnN0Um91bmQsIGxhc3RSb3VuZCwgbm90ZSwgZ2VuZXNpc0hhc2gsIGdlbmVzaXNJRCwgYXNzZXRJbmRleCkge1xuICAgIGxldCBvID0ge1xuICAgICAgICBcInR5cGVcIjogXCJheGZlclwiLFxuICAgICAgICBcImZyb21cIjogZnJvbSxcbiAgICAgICAgXCJ0b1wiOiB0byxcbiAgICAgICAgXCJhbW91bnRcIjogYW1vdW50LFxuICAgICAgICBcImZlZVwiOiBmZWUsXG4gICAgICAgIFwiZmlyc3RSb3VuZFwiOiBmaXJzdFJvdW5kLFxuICAgICAgICBcImxhc3RSb3VuZFwiOiBsYXN0Um91bmQsXG4gICAgICAgIFwiZ2VuZXNpc0hhc2hcIjogZ2VuZXNpc0hhc2gsXG4gICAgICAgIFwiZ2VuZXNpc0lEXCI6IGdlbmVzaXNJRCxcbiAgICAgICAgXCJhc3NldEluZGV4XCI6IGFzc2V0SW5kZXgsXG4gICAgICAgIFwibm90ZVwiOiBub3RlLFxuICAgICAgICBcImFzc2V0UmV2b2NhdGlvblRhcmdldFwiOiByZXZvY2F0aW9uVGFyZ2V0LFxuICAgICAgICBcImNsb3NlUmVtYWluZGVyVG9cIjogY2xvc2VSZW1haW5kZXJUb1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyB0eG5CdWlsZGVyLlRyYW5zYWN0aW9uKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc1ZhbGlkQWRkcmVzcyxcbiAgICBnZW5lcmF0ZUFjY291bnQsXG4gICAgc2VjcmV0S2V5VG9NbmVtb25pYyxcbiAgICBtbmVtb25pY1RvU2VjcmV0S2V5LFxuICAgIHNpZ25UcmFuc2FjdGlvbixcbiAgICBzaWduQmlkLFxuICAgIHNpZ25CeXRlcyxcbiAgICB2ZXJpZnlCeXRlcyxcbiAgICBlbmNvZGVPYmosXG4gICAgZGVjb2RlT2JqLFxuICAgIEFsZ29kLFxuICAgIEttZCxcbiAgICBtbmVtb25pY1RvTWFzdGVyRGVyaXZhdGlvbktleSxcbiAgICBtYXN0ZXJEZXJpdmF0aW9uS2V5VG9NbmVtb25pYyxcbiAgICBhcHBlbmRTaWduTXVsdGlzaWdUcmFuc2FjdGlvbixcbiAgICBtZXJnZU11bHRpc2lnVHJhbnNhY3Rpb25zLFxuICAgIHNpZ25NdWx0aXNpZ1RyYW5zYWN0aW9uLFxuICAgIG11bHRpc2lnQWRkcmVzcyxcbiAgICBFUlJPUl9NVUxUSVNJR19CQURfU0VOREVSLFxuICAgIEVSUk9SX0lOVkFMSURfTUlDUk9BTEdPUyxcbiAgICBtaWNyb2FsZ29zVG9BbGdvcyxcbiAgICBhbGdvc1RvTWljcm9hbGdvcyxcbiAgICBjb21wdXRlR3JvdXBJRCxcbiAgICBhc3NpZ25Hcm91cElELFxuICAgIG1ha2VMb2dpY1NpZyxcbiAgICBzaWduTG9naWNTaWdUcmFuc2FjdGlvbixcbiAgICBtYWtlUGF5bWVudFR4bixcbiAgICBtYWtlS2V5UmVnaXN0cmF0aW9uVHhuLFxuICAgIG1ha2VBc3NldENyZWF0ZVR4bixcbiAgICBtYWtlQXNzZXRDb25maWdUeG4sXG4gICAgbWFrZUFzc2V0RGVzdHJveVR4bixcbiAgICBtYWtlQXNzZXRGcmVlemVUeG4sXG4gICAgbWFrZUFzc2V0VHJhbnNmZXJUeG4sXG59O1xuIiwiY29uc3QgZW5nbGlzaCA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0cy9lbmdsaXNoXCIpO1xuY29uc3QgbmFjbCA9IHJlcXVpcmUoXCIuLi9uYWNsL25hY2xXcmFwcGVyc1wiKTtcblxuY29uc3QgRVJST1JfRkFJTF9UT19ERUNPREVfTU5FTU9OSUMgPSBFcnJvcignZmFpbGVkIHRvIGRlY29kZSBtbmVtb25pYycpO1xuY29uc3QgRVJST1JfTk9UX0lOX1dPUkRTX0xJU1QgPSBFcnJvcigndGhlIG1uZW1vbmljIGNvbnRhaW5zIGEgd29yZCB0aGF0IGlzIG5vdCBpbiB0aGUgd29yZGxpc3QnKTtcblxuLyoqXG4gKiBtbmVtb25pY0Zyb21TZWVkIGNvbnZlcnRzIGEgMzItYnl0ZSBrZXkgaW50byBhIDI1IHdvcmQgbW5lbW9uaWMuIFRoZSBnZW5lcmF0ZWQgbW5lbW9uaWMgaW5jbHVkZXMgYSBjaGVja3N1bS5cbiAqIEVhY2ggd29yZCBpbiB0aGUgbW5lbW9uaWMgcmVwcmVzZW50cyAxMSBiaXRzIG9mIGRhdGEsIGFuZCB0aGUgbGFzdCAxMSBiaXRzIGFyZSByZXNlcnZlZCBmb3IgdGhlIGNoZWNrc3VtLlxuICogQHBhcmFtIHNlZWQgMzIgYnl0ZXMgbG9uZyBzZWVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAyNSB3b3JkcyBtbmVtb25pY1xuICovXG5mdW5jdGlvbiBtbmVtb25pY0Zyb21TZWVkKHNlZWQpIHtcbiAgICAvLyBTYW5pdHkgbGVuZ3RoIGNoZWNrXG4gICAgaWYgKHNlZWQubGVuZ3RoICE9PSBuYWNsLlNFRURfQlRZRVNfTEVOR1RIKSB7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWVkIGxlbmd0aCBtdXN0IGJlIFwiICtcbiAgICAgICAgbmFjbC5TRUVEX0JUWUVTX0xFTkdUSCk7fVxuXG4gICAgY29uc3QgdWludDExQXJyYXkgPSB0b1VpbnQxMUFycmF5KHNlZWQpO1xuICAgIGNvbnN0IHdvcmRzID0gYXBwbHlXb3Jkcyh1aW50MTFBcnJheSk7XG4gICAgY29uc3QgY2hlY2tzdW1Xb3JkID0gY29tcHV0ZUNoZWNrc3VtKHNlZWQpO1xuXG4gICAgcmV0dXJuIHdvcmRzLmpvaW4oJyAnKSArICcgJyArIGNoZWNrc3VtV29yZDtcbn1cblxuLyoqXG4gKiBzZWVkRnJvbU1uZW1vbmljIGNvbnZlcnRzIGEgbW5lbW9uaWMgZ2VuZXJhdGVkIHVzaW5nIHRoaXMgbGlicmFyeSBpbnRvIHRoZSBzb3VyY2Uga2V5IHVzZWQgdG8gY3JlYXRlIGl0LlxuICogSXQgcmV0dXJucyBhbiBlcnJvciBpZiB0aGUgcGFzc2VkIG1uZW1vbmljIGhhcyBhbiBpbmNvcnJlY3QgY2hlY2tzdW0sIGlmIHRoZSBudW1iZXIgb2Ygd29yZHMgaXMgdW5leHBlY3RlZCwgb3IgaWYgb25lXG4gKiBvZiB0aGUgcGFzc2VkIHdvcmRzIGlzIG5vdCBmb3VuZCBpbiB0aGUgd29yZHMgbGlzdC5cbiAqIEBwYXJhbSBtbmVtb25pYyAyNSB3b3JkcyBtbmVtb25pY1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IDMyIGJ5dGVzIGxvbmcgc2VlZFxuICovXG5mdW5jdGlvbiBzZWVkRnJvbU1uZW1vbmljKG1uZW1vbmljKSB7XG4gICAgY29uc3Qgd29yZHMgPSBtbmVtb25pYy5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGtleSA9IHdvcmRzLnNsaWNlKDAsIDI0KTtcblxuICAgIC8vQ2hlY2sgdGhhdCBhbGwgd29yZHMgYXJlIGluIGxpc3RcbiAgICBmb3IgKGxldCB3IG9mIGtleSkge1xuICAgICAgICBpZiAoZW5nbGlzaC5pbmRleE9mKHcpID09PSAtMSkgdGhyb3cgRVJST1JfTk9UX0lOX1dPUkRTX0xJU1Q7XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tzdW0gPSB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCB1aW50MTFBcnJheSA9IGtleS5tYXAod29yZCA9PiBlbmdsaXNoLmluZGV4T2Yod29yZCkpO1xuXG4gICAgLy8gQ29udmVydCB0aGUga2V5IHRvIHVpbnQ4QXJyYXlcbiAgICBsZXQgdWludDhBcnJheSA9IHRvVWludDhBcnJheSh1aW50MTFBcnJheSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNob3AgdGhlIGxhc3QgYnl0ZSAtXG4gICAgLy8gdGhlIHNob3J0IGV4cGxhbmF0aW9uIC0gU2luY2UgMjU2IGlzIG5vdCBkaXZpc2libGUgYnkgMTEsIHdlIGhhdmUgYW4gZXh0cmEgMHgwIGJ5dGUuXG4gICAgLy8gVGhlIGxvbmdlciBleHBsYW5hdGlvbiAtIFdoZW4gc3BsaXR0aW5nIHRoZSAyNTYgYml0cyB0byBjaHVua3Mgb2YgMTEsIHdlIGdldCAyMyB3b3JkcyBhbmQgYSBsZWZ0IG92ZXIgb2YgMyBiaXRzLlxuICAgIC8vIFRoaXMgbGVmdCBnZXRzIHBhZGRlZCB3aXRoIGFub3RoZXIgOCBiaXRzIHRvIHRoZSBjcmVhdGUgdGhlIDI0dGggd29yZC5cbiAgICAvLyBXaGlsZSBjb252ZXJ0aW5nIGJhY2sgdG8gYnl0ZSBhcnJheSwgb3VyIG5ldyAyNjQgYml0cyBhcnJheSBpcyBkaXZpc2libGUgYnkgOCBidXQgdGhlIGxhc3QgYnl0ZSBpcyBqdXN0IHRoZSBwYWRkaW5nLlxuXG4gICAgLy8gY2hlY2sgdGhhdCB3ZSBoYXZlIDMzIGJ5dGVzIGxvbmcgYXJyYXkgYXMgZXhwZWN0ZWRcbiAgICBpZiAodWludDhBcnJheS5sZW5ndGggIT09IDMzKSB0aHJvdyBFUlJPUl9GQUlMX1RPX0RFQ09ERV9NTkVNT05JQztcblxuICAgIC8vIGNoZWNrIHRoYXQgdGhlIGxhc3QgYnl0ZSBpcyBhY3R1YWxseSAweDBcbiAgICBpZiAodWludDhBcnJheVt1aW50OEFycmF5Lmxlbmd0aCAtIDFdICE9PSAweDApIHRocm93IEVSUk9SX0ZBSUxfVE9fREVDT0RFX01ORU1PTklDO1xuXG4gICAgLy8gY2hvcCBpdCAhXG4gICAgdWludDhBcnJheSA9IHVpbnQ4QXJyYXkuc2xpY2UoMCwgdWludDhBcnJheS5sZW5ndGggLSAxKTtcblxuXG4gICAgLy8gY29tcHV0ZSBjaGVja3N1bVxuICAgIGNvbnN0IGNzID0gY29tcHV0ZUNoZWNrc3VtKHVpbnQ4QXJyYXkpO1xuXG4gICAgLy8gc3VjY2VzcyFcbiAgICBpZiAoY3MgPT09IGNoZWNrc3VtKSByZXR1cm4gdWludDhBcnJheTtcblxuICAgIHRocm93IEVSUk9SX0ZBSUxfVE9fREVDT0RFX01ORU1PTklDO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hlY2tzdW0oc2VlZCkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBuYWNsLmdlbmVyaWNIYXNoKHNlZWQpO1xuICAgIGNvbnN0IHVpbnQxMUhhc2ggPSB0b1VpbnQxMUFycmF5KGhhc2hCdWZmZXIpO1xuICAgIGNvbnN0IHdvcmRzID0gYXBwbHlXb3Jkcyh1aW50MTFIYXNoKTtcblxuICAgIHJldHVybiB3b3Jkc1swXTtcbn1cblxuZnVuY3Rpb24gYXBwbHlXb3JkcyhudW1zKSB7XG4gICAgcmV0dXJuIG51bXMubWFwKG4gPT4gZW5nbGlzaFtuXSk7XG59XG5cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUxNDUyNjE0XG5mdW5jdGlvbiB0b1VpbnQxMUFycmF5KGJ1ZmZlcjgpIHtcbiAgICBsZXQgYnVmZmVyMTEgPSBbXTtcbiAgICBsZXQgYWNjID0gMDtcbiAgICBsZXQgYWNjQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkKG9jdGV0KSB7XG4gICAgICAgIGFjYyA9IChvY3RldCA8PCBhY2NCaXRzKSB8IGFjYztcbiAgICAgICAgYWNjQml0cyArPSA4O1xuICAgICAgICBpZiAoYWNjQml0cyA+PTExKSB7XG4gICAgICAgICAgICBidWZmZXIxMS5wdXNoKCBhY2MgJiAweDdmZik7XG4gICAgICAgICAgICBhY2MgPj49IDExO1xuICAgICAgICAgICAgYWNjQml0cyAtPSAxMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgaWYgKGFjY0JpdHMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcjExLnB1c2goIGFjYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXI4LmZvckVhY2goIGFkZCk7XG4gICAgZmx1c2goKTtcbiAgICByZXR1cm4gYnVmZmVyMTE7XG59XG5cbi8vIGZyb20gVWludDExQXJyYXlcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MTQ1MjYxNFxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJ1ZmZlcjExKSB7XG4gICAgbGV0IGJ1ZmZlcjggPSBbXTtcbiAgICBsZXQgYWNjID0gMDtcbiAgICBsZXQgYWNjQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkKHVpMTEpIHtcbiAgICAgICAgYWNjID0gKHVpMTEgPDwgYWNjQml0cykgfCBhY2M7XG4gICAgICAgIGFjY0JpdHMgKz0gMTE7XG4gICAgICAgIHdoaWxlIChhY2NCaXRzID49IDgpIHtcbiAgICAgICAgICAgIGJ1ZmZlcjgucHVzaCggYWNjICYgMHhmZik7XG4gICAgICAgICAgICBhY2MgPj49IDg7XG4gICAgICAgICAgICBhY2NCaXRzIC09IDg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIGlmIChhY2NCaXRzKSB7XG4gICAgICAgICAgICBidWZmZXI4LnB1c2goIGFjYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXIxMS5mb3JFYWNoKCBhZGQpO1xuICAgIGZsdXNoKCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcjgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHttbmVtb25pY0Zyb21TZWVkLCBzZWVkRnJvbU1uZW1vbmljLCBFUlJPUl9GQUlMX1RPX0RFQ09ERV9NTkVNT05JQywgRVJST1JfTk9UX0lOX1dPUkRTX0xJU1R9OyIsImNvbnN0IGVuZ2xpc2ggPSBbXG4gICAgXCJhYmFuZG9uXCIsXG4gICAgXCJhYmlsaXR5XCIsXG4gICAgXCJhYmxlXCIsXG4gICAgXCJhYm91dFwiLFxuICAgIFwiYWJvdmVcIixcbiAgICBcImFic2VudFwiLFxuICAgIFwiYWJzb3JiXCIsXG4gICAgXCJhYnN0cmFjdFwiLFxuICAgIFwiYWJzdXJkXCIsXG4gICAgXCJhYnVzZVwiLFxuICAgIFwiYWNjZXNzXCIsXG4gICAgXCJhY2NpZGVudFwiLFxuICAgIFwiYWNjb3VudFwiLFxuICAgIFwiYWNjdXNlXCIsXG4gICAgXCJhY2hpZXZlXCIsXG4gICAgXCJhY2lkXCIsXG4gICAgXCJhY291c3RpY1wiLFxuICAgIFwiYWNxdWlyZVwiLFxuICAgIFwiYWNyb3NzXCIsXG4gICAgXCJhY3RcIixcbiAgICBcImFjdGlvblwiLFxuICAgIFwiYWN0b3JcIixcbiAgICBcImFjdHJlc3NcIixcbiAgICBcImFjdHVhbFwiLFxuICAgIFwiYWRhcHRcIixcbiAgICBcImFkZFwiLFxuICAgIFwiYWRkaWN0XCIsXG4gICAgXCJhZGRyZXNzXCIsXG4gICAgXCJhZGp1c3RcIixcbiAgICBcImFkbWl0XCIsXG4gICAgXCJhZHVsdFwiLFxuICAgIFwiYWR2YW5jZVwiLFxuICAgIFwiYWR2aWNlXCIsXG4gICAgXCJhZXJvYmljXCIsXG4gICAgXCJhZmZhaXJcIixcbiAgICBcImFmZm9yZFwiLFxuICAgIFwiYWZyYWlkXCIsXG4gICAgXCJhZ2FpblwiLFxuICAgIFwiYWdlXCIsXG4gICAgXCJhZ2VudFwiLFxuICAgIFwiYWdyZWVcIixcbiAgICBcImFoZWFkXCIsXG4gICAgXCJhaW1cIixcbiAgICBcImFpclwiLFxuICAgIFwiYWlycG9ydFwiLFxuICAgIFwiYWlzbGVcIixcbiAgICBcImFsYXJtXCIsXG4gICAgXCJhbGJ1bVwiLFxuICAgIFwiYWxjb2hvbFwiLFxuICAgIFwiYWxlcnRcIixcbiAgICBcImFsaWVuXCIsXG4gICAgXCJhbGxcIixcbiAgICBcImFsbGV5XCIsXG4gICAgXCJhbGxvd1wiLFxuICAgIFwiYWxtb3N0XCIsXG4gICAgXCJhbG9uZVwiLFxuICAgIFwiYWxwaGFcIixcbiAgICBcImFscmVhZHlcIixcbiAgICBcImFsc29cIixcbiAgICBcImFsdGVyXCIsXG4gICAgXCJhbHdheXNcIixcbiAgICBcImFtYXRldXJcIixcbiAgICBcImFtYXppbmdcIixcbiAgICBcImFtb25nXCIsXG4gICAgXCJhbW91bnRcIixcbiAgICBcImFtdXNlZFwiLFxuICAgIFwiYW5hbHlzdFwiLFxuICAgIFwiYW5jaG9yXCIsXG4gICAgXCJhbmNpZW50XCIsXG4gICAgXCJhbmdlclwiLFxuICAgIFwiYW5nbGVcIixcbiAgICBcImFuZ3J5XCIsXG4gICAgXCJhbmltYWxcIixcbiAgICBcImFua2xlXCIsXG4gICAgXCJhbm5vdW5jZVwiLFxuICAgIFwiYW5udWFsXCIsXG4gICAgXCJhbm90aGVyXCIsXG4gICAgXCJhbnN3ZXJcIixcbiAgICBcImFudGVubmFcIixcbiAgICBcImFudGlxdWVcIixcbiAgICBcImFueGlldHlcIixcbiAgICBcImFueVwiLFxuICAgIFwiYXBhcnRcIixcbiAgICBcImFwb2xvZ3lcIixcbiAgICBcImFwcGVhclwiLFxuICAgIFwiYXBwbGVcIixcbiAgICBcImFwcHJvdmVcIixcbiAgICBcImFwcmlsXCIsXG4gICAgXCJhcmNoXCIsXG4gICAgXCJhcmN0aWNcIixcbiAgICBcImFyZWFcIixcbiAgICBcImFyZW5hXCIsXG4gICAgXCJhcmd1ZVwiLFxuICAgIFwiYXJtXCIsXG4gICAgXCJhcm1lZFwiLFxuICAgIFwiYXJtb3JcIixcbiAgICBcImFybXlcIixcbiAgICBcImFyb3VuZFwiLFxuICAgIFwiYXJyYW5nZVwiLFxuICAgIFwiYXJyZXN0XCIsXG4gICAgXCJhcnJpdmVcIixcbiAgICBcImFycm93XCIsXG4gICAgXCJhcnRcIixcbiAgICBcImFydGVmYWN0XCIsXG4gICAgXCJhcnRpc3RcIixcbiAgICBcImFydHdvcmtcIixcbiAgICBcImFza1wiLFxuICAgIFwiYXNwZWN0XCIsXG4gICAgXCJhc3NhdWx0XCIsXG4gICAgXCJhc3NldFwiLFxuICAgIFwiYXNzaXN0XCIsXG4gICAgXCJhc3N1bWVcIixcbiAgICBcImFzdGhtYVwiLFxuICAgIFwiYXRobGV0ZVwiLFxuICAgIFwiYXRvbVwiLFxuICAgIFwiYXR0YWNrXCIsXG4gICAgXCJhdHRlbmRcIixcbiAgICBcImF0dGl0dWRlXCIsXG4gICAgXCJhdHRyYWN0XCIsXG4gICAgXCJhdWN0aW9uXCIsXG4gICAgXCJhdWRpdFwiLFxuICAgIFwiYXVndXN0XCIsXG4gICAgXCJhdW50XCIsXG4gICAgXCJhdXRob3JcIixcbiAgICBcImF1dG9cIixcbiAgICBcImF1dHVtblwiLFxuICAgIFwiYXZlcmFnZVwiLFxuICAgIFwiYXZvY2Fkb1wiLFxuICAgIFwiYXZvaWRcIixcbiAgICBcImF3YWtlXCIsXG4gICAgXCJhd2FyZVwiLFxuICAgIFwiYXdheVwiLFxuICAgIFwiYXdlc29tZVwiLFxuICAgIFwiYXdmdWxcIixcbiAgICBcImF3a3dhcmRcIixcbiAgICBcImF4aXNcIixcbiAgICBcImJhYnlcIixcbiAgICBcImJhY2hlbG9yXCIsXG4gICAgXCJiYWNvblwiLFxuICAgIFwiYmFkZ2VcIixcbiAgICBcImJhZ1wiLFxuICAgIFwiYmFsYW5jZVwiLFxuICAgIFwiYmFsY29ueVwiLFxuICAgIFwiYmFsbFwiLFxuICAgIFwiYmFtYm9vXCIsXG4gICAgXCJiYW5hbmFcIixcbiAgICBcImJhbm5lclwiLFxuICAgIFwiYmFyXCIsXG4gICAgXCJiYXJlbHlcIixcbiAgICBcImJhcmdhaW5cIixcbiAgICBcImJhcnJlbFwiLFxuICAgIFwiYmFzZVwiLFxuICAgIFwiYmFzaWNcIixcbiAgICBcImJhc2tldFwiLFxuICAgIFwiYmF0dGxlXCIsXG4gICAgXCJiZWFjaFwiLFxuICAgIFwiYmVhblwiLFxuICAgIFwiYmVhdXR5XCIsXG4gICAgXCJiZWNhdXNlXCIsXG4gICAgXCJiZWNvbWVcIixcbiAgICBcImJlZWZcIixcbiAgICBcImJlZm9yZVwiLFxuICAgIFwiYmVnaW5cIixcbiAgICBcImJlaGF2ZVwiLFxuICAgIFwiYmVoaW5kXCIsXG4gICAgXCJiZWxpZXZlXCIsXG4gICAgXCJiZWxvd1wiLFxuICAgIFwiYmVsdFwiLFxuICAgIFwiYmVuY2hcIixcbiAgICBcImJlbmVmaXRcIixcbiAgICBcImJlc3RcIixcbiAgICBcImJldHJheVwiLFxuICAgIFwiYmV0dGVyXCIsXG4gICAgXCJiZXR3ZWVuXCIsXG4gICAgXCJiZXlvbmRcIixcbiAgICBcImJpY3ljbGVcIixcbiAgICBcImJpZFwiLFxuICAgIFwiYmlrZVwiLFxuICAgIFwiYmluZFwiLFxuICAgIFwiYmlvbG9neVwiLFxuICAgIFwiYmlyZFwiLFxuICAgIFwiYmlydGhcIixcbiAgICBcImJpdHRlclwiLFxuICAgIFwiYmxhY2tcIixcbiAgICBcImJsYWRlXCIsXG4gICAgXCJibGFtZVwiLFxuICAgIFwiYmxhbmtldFwiLFxuICAgIFwiYmxhc3RcIixcbiAgICBcImJsZWFrXCIsXG4gICAgXCJibGVzc1wiLFxuICAgIFwiYmxpbmRcIixcbiAgICBcImJsb29kXCIsXG4gICAgXCJibG9zc29tXCIsXG4gICAgXCJibG91c2VcIixcbiAgICBcImJsdWVcIixcbiAgICBcImJsdXJcIixcbiAgICBcImJsdXNoXCIsXG4gICAgXCJib2FyZFwiLFxuICAgIFwiYm9hdFwiLFxuICAgIFwiYm9keVwiLFxuICAgIFwiYm9pbFwiLFxuICAgIFwiYm9tYlwiLFxuICAgIFwiYm9uZVwiLFxuICAgIFwiYm9udXNcIixcbiAgICBcImJvb2tcIixcbiAgICBcImJvb3N0XCIsXG4gICAgXCJib3JkZXJcIixcbiAgICBcImJvcmluZ1wiLFxuICAgIFwiYm9ycm93XCIsXG4gICAgXCJib3NzXCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcImJvdW5jZVwiLFxuICAgIFwiYm94XCIsXG4gICAgXCJib3lcIixcbiAgICBcImJyYWNrZXRcIixcbiAgICBcImJyYWluXCIsXG4gICAgXCJicmFuZFwiLFxuICAgIFwiYnJhc3NcIixcbiAgICBcImJyYXZlXCIsXG4gICAgXCJicmVhZFwiLFxuICAgIFwiYnJlZXplXCIsXG4gICAgXCJicmlja1wiLFxuICAgIFwiYnJpZGdlXCIsXG4gICAgXCJicmllZlwiLFxuICAgIFwiYnJpZ2h0XCIsXG4gICAgXCJicmluZ1wiLFxuICAgIFwiYnJpc2tcIixcbiAgICBcImJyb2Njb2xpXCIsXG4gICAgXCJicm9rZW5cIixcbiAgICBcImJyb256ZVwiLFxuICAgIFwiYnJvb21cIixcbiAgICBcImJyb3RoZXJcIixcbiAgICBcImJyb3duXCIsXG4gICAgXCJicnVzaFwiLFxuICAgIFwiYnViYmxlXCIsXG4gICAgXCJidWRkeVwiLFxuICAgIFwiYnVkZ2V0XCIsXG4gICAgXCJidWZmYWxvXCIsXG4gICAgXCJidWlsZFwiLFxuICAgIFwiYnVsYlwiLFxuICAgIFwiYnVsa1wiLFxuICAgIFwiYnVsbGV0XCIsXG4gICAgXCJidW5kbGVcIixcbiAgICBcImJ1bmtlclwiLFxuICAgIFwiYnVyZGVuXCIsXG4gICAgXCJidXJnZXJcIixcbiAgICBcImJ1cnN0XCIsXG4gICAgXCJidXNcIixcbiAgICBcImJ1c2luZXNzXCIsXG4gICAgXCJidXN5XCIsXG4gICAgXCJidXR0ZXJcIixcbiAgICBcImJ1eWVyXCIsXG4gICAgXCJidXp6XCIsXG4gICAgXCJjYWJiYWdlXCIsXG4gICAgXCJjYWJpblwiLFxuICAgIFwiY2FibGVcIixcbiAgICBcImNhY3R1c1wiLFxuICAgIFwiY2FnZVwiLFxuICAgIFwiY2FrZVwiLFxuICAgIFwiY2FsbFwiLFxuICAgIFwiY2FsbVwiLFxuICAgIFwiY2FtZXJhXCIsXG4gICAgXCJjYW1wXCIsXG4gICAgXCJjYW5cIixcbiAgICBcImNhbmFsXCIsXG4gICAgXCJjYW5jZWxcIixcbiAgICBcImNhbmR5XCIsXG4gICAgXCJjYW5ub25cIixcbiAgICBcImNhbm9lXCIsXG4gICAgXCJjYW52YXNcIixcbiAgICBcImNhbnlvblwiLFxuICAgIFwiY2FwYWJsZVwiLFxuICAgIFwiY2FwaXRhbFwiLFxuICAgIFwiY2FwdGFpblwiLFxuICAgIFwiY2FyXCIsXG4gICAgXCJjYXJib25cIixcbiAgICBcImNhcmRcIixcbiAgICBcImNhcmdvXCIsXG4gICAgXCJjYXJwZXRcIixcbiAgICBcImNhcnJ5XCIsXG4gICAgXCJjYXJ0XCIsXG4gICAgXCJjYXNlXCIsXG4gICAgXCJjYXNoXCIsXG4gICAgXCJjYXNpbm9cIixcbiAgICBcImNhc3RsZVwiLFxuICAgIFwiY2FzdWFsXCIsXG4gICAgXCJjYXRcIixcbiAgICBcImNhdGFsb2dcIixcbiAgICBcImNhdGNoXCIsXG4gICAgXCJjYXRlZ29yeVwiLFxuICAgIFwiY2F0dGxlXCIsXG4gICAgXCJjYXVnaHRcIixcbiAgICBcImNhdXNlXCIsXG4gICAgXCJjYXV0aW9uXCIsXG4gICAgXCJjYXZlXCIsXG4gICAgXCJjZWlsaW5nXCIsXG4gICAgXCJjZWxlcnlcIixcbiAgICBcImNlbWVudFwiLFxuICAgIFwiY2Vuc3VzXCIsXG4gICAgXCJjZW50dXJ5XCIsXG4gICAgXCJjZXJlYWxcIixcbiAgICBcImNlcnRhaW5cIixcbiAgICBcImNoYWlyXCIsXG4gICAgXCJjaGFsa1wiLFxuICAgIFwiY2hhbXBpb25cIixcbiAgICBcImNoYW5nZVwiLFxuICAgIFwiY2hhb3NcIixcbiAgICBcImNoYXB0ZXJcIixcbiAgICBcImNoYXJnZVwiLFxuICAgIFwiY2hhc2VcIixcbiAgICBcImNoYXRcIixcbiAgICBcImNoZWFwXCIsXG4gICAgXCJjaGVja1wiLFxuICAgIFwiY2hlZXNlXCIsXG4gICAgXCJjaGVmXCIsXG4gICAgXCJjaGVycnlcIixcbiAgICBcImNoZXN0XCIsXG4gICAgXCJjaGlja2VuXCIsXG4gICAgXCJjaGllZlwiLFxuICAgIFwiY2hpbGRcIixcbiAgICBcImNoaW1uZXlcIixcbiAgICBcImNob2ljZVwiLFxuICAgIFwiY2hvb3NlXCIsXG4gICAgXCJjaHJvbmljXCIsXG4gICAgXCJjaHVja2xlXCIsXG4gICAgXCJjaHVua1wiLFxuICAgIFwiY2h1cm5cIixcbiAgICBcImNpZ2FyXCIsXG4gICAgXCJjaW5uYW1vblwiLFxuICAgIFwiY2lyY2xlXCIsXG4gICAgXCJjaXRpemVuXCIsXG4gICAgXCJjaXR5XCIsXG4gICAgXCJjaXZpbFwiLFxuICAgIFwiY2xhaW1cIixcbiAgICBcImNsYXBcIixcbiAgICBcImNsYXJpZnlcIixcbiAgICBcImNsYXdcIixcbiAgICBcImNsYXlcIixcbiAgICBcImNsZWFuXCIsXG4gICAgXCJjbGVya1wiLFxuICAgIFwiY2xldmVyXCIsXG4gICAgXCJjbGlja1wiLFxuICAgIFwiY2xpZW50XCIsXG4gICAgXCJjbGlmZlwiLFxuICAgIFwiY2xpbWJcIixcbiAgICBcImNsaW5pY1wiLFxuICAgIFwiY2xpcFwiLFxuICAgIFwiY2xvY2tcIixcbiAgICBcImNsb2dcIixcbiAgICBcImNsb3NlXCIsXG4gICAgXCJjbG90aFwiLFxuICAgIFwiY2xvdWRcIixcbiAgICBcImNsb3duXCIsXG4gICAgXCJjbHViXCIsXG4gICAgXCJjbHVtcFwiLFxuICAgIFwiY2x1c3RlclwiLFxuICAgIFwiY2x1dGNoXCIsXG4gICAgXCJjb2FjaFwiLFxuICAgIFwiY29hc3RcIixcbiAgICBcImNvY29udXRcIixcbiAgICBcImNvZGVcIixcbiAgICBcImNvZmZlZVwiLFxuICAgIFwiY29pbFwiLFxuICAgIFwiY29pblwiLFxuICAgIFwiY29sbGVjdFwiLFxuICAgIFwiY29sb3JcIixcbiAgICBcImNvbHVtblwiLFxuICAgIFwiY29tYmluZVwiLFxuICAgIFwiY29tZVwiLFxuICAgIFwiY29tZm9ydFwiLFxuICAgIFwiY29taWNcIixcbiAgICBcImNvbW1vblwiLFxuICAgIFwiY29tcGFueVwiLFxuICAgIFwiY29uY2VydFwiLFxuICAgIFwiY29uZHVjdFwiLFxuICAgIFwiY29uZmlybVwiLFxuICAgIFwiY29uZ3Jlc3NcIixcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbnNpZGVyXCIsXG4gICAgXCJjb250cm9sXCIsXG4gICAgXCJjb252aW5jZVwiLFxuICAgIFwiY29va1wiLFxuICAgIFwiY29vbFwiLFxuICAgIFwiY29wcGVyXCIsXG4gICAgXCJjb3B5XCIsXG4gICAgXCJjb3JhbFwiLFxuICAgIFwiY29yZVwiLFxuICAgIFwiY29yblwiLFxuICAgIFwiY29ycmVjdFwiLFxuICAgIFwiY29zdFwiLFxuICAgIFwiY290dG9uXCIsXG4gICAgXCJjb3VjaFwiLFxuICAgIFwiY291bnRyeVwiLFxuICAgIFwiY291cGxlXCIsXG4gICAgXCJjb3Vyc2VcIixcbiAgICBcImNvdXNpblwiLFxuICAgIFwiY292ZXJcIixcbiAgICBcImNveW90ZVwiLFxuICAgIFwiY3JhY2tcIixcbiAgICBcImNyYWRsZVwiLFxuICAgIFwiY3JhZnRcIixcbiAgICBcImNyYW1cIixcbiAgICBcImNyYW5lXCIsXG4gICAgXCJjcmFzaFwiLFxuICAgIFwiY3JhdGVyXCIsXG4gICAgXCJjcmF3bFwiLFxuICAgIFwiY3JhenlcIixcbiAgICBcImNyZWFtXCIsXG4gICAgXCJjcmVkaXRcIixcbiAgICBcImNyZWVrXCIsXG4gICAgXCJjcmV3XCIsXG4gICAgXCJjcmlja2V0XCIsXG4gICAgXCJjcmltZVwiLFxuICAgIFwiY3Jpc3BcIixcbiAgICBcImNyaXRpY1wiLFxuICAgIFwiY3JvcFwiLFxuICAgIFwiY3Jvc3NcIixcbiAgICBcImNyb3VjaFwiLFxuICAgIFwiY3Jvd2RcIixcbiAgICBcImNydWNpYWxcIixcbiAgICBcImNydWVsXCIsXG4gICAgXCJjcnVpc2VcIixcbiAgICBcImNydW1ibGVcIixcbiAgICBcImNydW5jaFwiLFxuICAgIFwiY3J1c2hcIixcbiAgICBcImNyeVwiLFxuICAgIFwiY3J5c3RhbFwiLFxuICAgIFwiY3ViZVwiLFxuICAgIFwiY3VsdHVyZVwiLFxuICAgIFwiY3VwXCIsXG4gICAgXCJjdXBib2FyZFwiLFxuICAgIFwiY3VyaW91c1wiLFxuICAgIFwiY3VycmVudFwiLFxuICAgIFwiY3VydGFpblwiLFxuICAgIFwiY3VydmVcIixcbiAgICBcImN1c2hpb25cIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiY3V0ZVwiLFxuICAgIFwiY3ljbGVcIixcbiAgICBcImRhZFwiLFxuICAgIFwiZGFtYWdlXCIsXG4gICAgXCJkYW1wXCIsXG4gICAgXCJkYW5jZVwiLFxuICAgIFwiZGFuZ2VyXCIsXG4gICAgXCJkYXJpbmdcIixcbiAgICBcImRhc2hcIixcbiAgICBcImRhdWdodGVyXCIsXG4gICAgXCJkYXduXCIsXG4gICAgXCJkYXlcIixcbiAgICBcImRlYWxcIixcbiAgICBcImRlYmF0ZVwiLFxuICAgIFwiZGVicmlzXCIsXG4gICAgXCJkZWNhZGVcIixcbiAgICBcImRlY2VtYmVyXCIsXG4gICAgXCJkZWNpZGVcIixcbiAgICBcImRlY2xpbmVcIixcbiAgICBcImRlY29yYXRlXCIsXG4gICAgXCJkZWNyZWFzZVwiLFxuICAgIFwiZGVlclwiLFxuICAgIFwiZGVmZW5zZVwiLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgXCJkZWZ5XCIsXG4gICAgXCJkZWdyZWVcIixcbiAgICBcImRlbGF5XCIsXG4gICAgXCJkZWxpdmVyXCIsXG4gICAgXCJkZW1hbmRcIixcbiAgICBcImRlbWlzZVwiLFxuICAgIFwiZGVuaWFsXCIsXG4gICAgXCJkZW50aXN0XCIsXG4gICAgXCJkZW55XCIsXG4gICAgXCJkZXBhcnRcIixcbiAgICBcImRlcGVuZFwiLFxuICAgIFwiZGVwb3NpdFwiLFxuICAgIFwiZGVwdGhcIixcbiAgICBcImRlcHV0eVwiLFxuICAgIFwiZGVyaXZlXCIsXG4gICAgXCJkZXNjcmliZVwiLFxuICAgIFwiZGVzZXJ0XCIsXG4gICAgXCJkZXNpZ25cIixcbiAgICBcImRlc2tcIixcbiAgICBcImRlc3BhaXJcIixcbiAgICBcImRlc3Ryb3lcIixcbiAgICBcImRldGFpbFwiLFxuICAgIFwiZGV0ZWN0XCIsXG4gICAgXCJkZXZlbG9wXCIsXG4gICAgXCJkZXZpY2VcIixcbiAgICBcImRldm90ZVwiLFxuICAgIFwiZGlhZ3JhbVwiLFxuICAgIFwiZGlhbFwiLFxuICAgIFwiZGlhbW9uZFwiLFxuICAgIFwiZGlhcnlcIixcbiAgICBcImRpY2VcIixcbiAgICBcImRpZXNlbFwiLFxuICAgIFwiZGlldFwiLFxuICAgIFwiZGlmZmVyXCIsXG4gICAgXCJkaWdpdGFsXCIsXG4gICAgXCJkaWduaXR5XCIsXG4gICAgXCJkaWxlbW1hXCIsXG4gICAgXCJkaW5uZXJcIixcbiAgICBcImRpbm9zYXVyXCIsXG4gICAgXCJkaXJlY3RcIixcbiAgICBcImRpcnRcIixcbiAgICBcImRpc2FncmVlXCIsXG4gICAgXCJkaXNjb3ZlclwiLFxuICAgIFwiZGlzZWFzZVwiLFxuICAgIFwiZGlzaFwiLFxuICAgIFwiZGlzbWlzc1wiLFxuICAgIFwiZGlzb3JkZXJcIixcbiAgICBcImRpc3BsYXlcIixcbiAgICBcImRpc3RhbmNlXCIsXG4gICAgXCJkaXZlcnRcIixcbiAgICBcImRpdmlkZVwiLFxuICAgIFwiZGl2b3JjZVwiLFxuICAgIFwiZGl6enlcIixcbiAgICBcImRvY3RvclwiLFxuICAgIFwiZG9jdW1lbnRcIixcbiAgICBcImRvZ1wiLFxuICAgIFwiZG9sbFwiLFxuICAgIFwiZG9scGhpblwiLFxuICAgIFwiZG9tYWluXCIsXG4gICAgXCJkb25hdGVcIixcbiAgICBcImRvbmtleVwiLFxuICAgIFwiZG9ub3JcIixcbiAgICBcImRvb3JcIixcbiAgICBcImRvc2VcIixcbiAgICBcImRvdWJsZVwiLFxuICAgIFwiZG92ZVwiLFxuICAgIFwiZHJhZnRcIixcbiAgICBcImRyYWdvblwiLFxuICAgIFwiZHJhbWFcIixcbiAgICBcImRyYXN0aWNcIixcbiAgICBcImRyYXdcIixcbiAgICBcImRyZWFtXCIsXG4gICAgXCJkcmVzc1wiLFxuICAgIFwiZHJpZnRcIixcbiAgICBcImRyaWxsXCIsXG4gICAgXCJkcmlua1wiLFxuICAgIFwiZHJpcFwiLFxuICAgIFwiZHJpdmVcIixcbiAgICBcImRyb3BcIixcbiAgICBcImRydW1cIixcbiAgICBcImRyeVwiLFxuICAgIFwiZHVja1wiLFxuICAgIFwiZHVtYlwiLFxuICAgIFwiZHVuZVwiLFxuICAgIFwiZHVyaW5nXCIsXG4gICAgXCJkdXN0XCIsXG4gICAgXCJkdXRjaFwiLFxuICAgIFwiZHV0eVwiLFxuICAgIFwiZHdhcmZcIixcbiAgICBcImR5bmFtaWNcIixcbiAgICBcImVhZ2VyXCIsXG4gICAgXCJlYWdsZVwiLFxuICAgIFwiZWFybHlcIixcbiAgICBcImVhcm5cIixcbiAgICBcImVhcnRoXCIsXG4gICAgXCJlYXNpbHlcIixcbiAgICBcImVhc3RcIixcbiAgICBcImVhc3lcIixcbiAgICBcImVjaG9cIixcbiAgICBcImVjb2xvZ3lcIixcbiAgICBcImVjb25vbXlcIixcbiAgICBcImVkZ2VcIixcbiAgICBcImVkaXRcIixcbiAgICBcImVkdWNhdGVcIixcbiAgICBcImVmZm9ydFwiLFxuICAgIFwiZWdnXCIsXG4gICAgXCJlaWdodFwiLFxuICAgIFwiZWl0aGVyXCIsXG4gICAgXCJlbGJvd1wiLFxuICAgIFwiZWxkZXJcIixcbiAgICBcImVsZWN0cmljXCIsXG4gICAgXCJlbGVnYW50XCIsXG4gICAgXCJlbGVtZW50XCIsXG4gICAgXCJlbGVwaGFudFwiLFxuICAgIFwiZWxldmF0b3JcIixcbiAgICBcImVsaXRlXCIsXG4gICAgXCJlbHNlXCIsXG4gICAgXCJlbWJhcmtcIixcbiAgICBcImVtYm9keVwiLFxuICAgIFwiZW1icmFjZVwiLFxuICAgIFwiZW1lcmdlXCIsXG4gICAgXCJlbW90aW9uXCIsXG4gICAgXCJlbXBsb3lcIixcbiAgICBcImVtcG93ZXJcIixcbiAgICBcImVtcHR5XCIsXG4gICAgXCJlbmFibGVcIixcbiAgICBcImVuYWN0XCIsXG4gICAgXCJlbmRcIixcbiAgICBcImVuZGxlc3NcIixcbiAgICBcImVuZG9yc2VcIixcbiAgICBcImVuZW15XCIsXG4gICAgXCJlbmVyZ3lcIixcbiAgICBcImVuZm9yY2VcIixcbiAgICBcImVuZ2FnZVwiLFxuICAgIFwiZW5naW5lXCIsXG4gICAgXCJlbmhhbmNlXCIsXG4gICAgXCJlbmpveVwiLFxuICAgIFwiZW5saXN0XCIsXG4gICAgXCJlbm91Z2hcIixcbiAgICBcImVucmljaFwiLFxuICAgIFwiZW5yb2xsXCIsXG4gICAgXCJlbnN1cmVcIixcbiAgICBcImVudGVyXCIsXG4gICAgXCJlbnRpcmVcIixcbiAgICBcImVudHJ5XCIsXG4gICAgXCJlbnZlbG9wZVwiLFxuICAgIFwiZXBpc29kZVwiLFxuICAgIFwiZXF1YWxcIixcbiAgICBcImVxdWlwXCIsXG4gICAgXCJlcmFcIixcbiAgICBcImVyYXNlXCIsXG4gICAgXCJlcm9kZVwiLFxuICAgIFwiZXJvc2lvblwiLFxuICAgIFwiZXJyb3JcIixcbiAgICBcImVydXB0XCIsXG4gICAgXCJlc2NhcGVcIixcbiAgICBcImVzc2F5XCIsXG4gICAgXCJlc3NlbmNlXCIsXG4gICAgXCJlc3RhdGVcIixcbiAgICBcImV0ZXJuYWxcIixcbiAgICBcImV0aGljc1wiLFxuICAgIFwiZXZpZGVuY2VcIixcbiAgICBcImV2aWxcIixcbiAgICBcImV2b2tlXCIsXG4gICAgXCJldm9sdmVcIixcbiAgICBcImV4YWN0XCIsXG4gICAgXCJleGFtcGxlXCIsXG4gICAgXCJleGNlc3NcIixcbiAgICBcImV4Y2hhbmdlXCIsXG4gICAgXCJleGNpdGVcIixcbiAgICBcImV4Y2x1ZGVcIixcbiAgICBcImV4Y3VzZVwiLFxuICAgIFwiZXhlY3V0ZVwiLFxuICAgIFwiZXhlcmNpc2VcIixcbiAgICBcImV4aGF1c3RcIixcbiAgICBcImV4aGliaXRcIixcbiAgICBcImV4aWxlXCIsXG4gICAgXCJleGlzdFwiLFxuICAgIFwiZXhpdFwiLFxuICAgIFwiZXhvdGljXCIsXG4gICAgXCJleHBhbmRcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiZXhwaXJlXCIsXG4gICAgXCJleHBsYWluXCIsXG4gICAgXCJleHBvc2VcIixcbiAgICBcImV4cHJlc3NcIixcbiAgICBcImV4dGVuZFwiLFxuICAgIFwiZXh0cmFcIixcbiAgICBcImV5ZVwiLFxuICAgIFwiZXllYnJvd1wiLFxuICAgIFwiZmFicmljXCIsXG4gICAgXCJmYWNlXCIsXG4gICAgXCJmYWN1bHR5XCIsXG4gICAgXCJmYWRlXCIsXG4gICAgXCJmYWludFwiLFxuICAgIFwiZmFpdGhcIixcbiAgICBcImZhbGxcIixcbiAgICBcImZhbHNlXCIsXG4gICAgXCJmYW1lXCIsXG4gICAgXCJmYW1pbHlcIixcbiAgICBcImZhbW91c1wiLFxuICAgIFwiZmFuXCIsXG4gICAgXCJmYW5jeVwiLFxuICAgIFwiZmFudGFzeVwiLFxuICAgIFwiZmFybVwiLFxuICAgIFwiZmFzaGlvblwiLFxuICAgIFwiZmF0XCIsXG4gICAgXCJmYXRhbFwiLFxuICAgIFwiZmF0aGVyXCIsXG4gICAgXCJmYXRpZ3VlXCIsXG4gICAgXCJmYXVsdFwiLFxuICAgIFwiZmF2b3JpdGVcIixcbiAgICBcImZlYXR1cmVcIixcbiAgICBcImZlYnJ1YXJ5XCIsXG4gICAgXCJmZWRlcmFsXCIsXG4gICAgXCJmZWVcIixcbiAgICBcImZlZWRcIixcbiAgICBcImZlZWxcIixcbiAgICBcImZlbWFsZVwiLFxuICAgIFwiZmVuY2VcIixcbiAgICBcImZlc3RpdmFsXCIsXG4gICAgXCJmZXRjaFwiLFxuICAgIFwiZmV2ZXJcIixcbiAgICBcImZld1wiLFxuICAgIFwiZmliZXJcIixcbiAgICBcImZpY3Rpb25cIixcbiAgICBcImZpZWxkXCIsXG4gICAgXCJmaWd1cmVcIixcbiAgICBcImZpbGVcIixcbiAgICBcImZpbG1cIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwiZmluYWxcIixcbiAgICBcImZpbmRcIixcbiAgICBcImZpbmVcIixcbiAgICBcImZpbmdlclwiLFxuICAgIFwiZmluaXNoXCIsXG4gICAgXCJmaXJlXCIsXG4gICAgXCJmaXJtXCIsXG4gICAgXCJmaXJzdFwiLFxuICAgIFwiZmlzY2FsXCIsXG4gICAgXCJmaXNoXCIsXG4gICAgXCJmaXRcIixcbiAgICBcImZpdG5lc3NcIixcbiAgICBcImZpeFwiLFxuICAgIFwiZmxhZ1wiLFxuICAgIFwiZmxhbWVcIixcbiAgICBcImZsYXNoXCIsXG4gICAgXCJmbGF0XCIsXG4gICAgXCJmbGF2b3JcIixcbiAgICBcImZsZWVcIixcbiAgICBcImZsaWdodFwiLFxuICAgIFwiZmxpcFwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImZsb2NrXCIsXG4gICAgXCJmbG9vclwiLFxuICAgIFwiZmxvd2VyXCIsXG4gICAgXCJmbHVpZFwiLFxuICAgIFwiZmx1c2hcIixcbiAgICBcImZseVwiLFxuICAgIFwiZm9hbVwiLFxuICAgIFwiZm9jdXNcIixcbiAgICBcImZvZ1wiLFxuICAgIFwiZm9pbFwiLFxuICAgIFwiZm9sZFwiLFxuICAgIFwiZm9sbG93XCIsXG4gICAgXCJmb29kXCIsXG4gICAgXCJmb290XCIsXG4gICAgXCJmb3JjZVwiLFxuICAgIFwiZm9yZXN0XCIsXG4gICAgXCJmb3JnZXRcIixcbiAgICBcImZvcmtcIixcbiAgICBcImZvcnR1bmVcIixcbiAgICBcImZvcnVtXCIsXG4gICAgXCJmb3J3YXJkXCIsXG4gICAgXCJmb3NzaWxcIixcbiAgICBcImZvc3RlclwiLFxuICAgIFwiZm91bmRcIixcbiAgICBcImZveFwiLFxuICAgIFwiZnJhZ2lsZVwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImZyZXF1ZW50XCIsXG4gICAgXCJmcmVzaFwiLFxuICAgIFwiZnJpZW5kXCIsXG4gICAgXCJmcmluZ2VcIixcbiAgICBcImZyb2dcIixcbiAgICBcImZyb250XCIsXG4gICAgXCJmcm9zdFwiLFxuICAgIFwiZnJvd25cIixcbiAgICBcImZyb3plblwiLFxuICAgIFwiZnJ1aXRcIixcbiAgICBcImZ1ZWxcIixcbiAgICBcImZ1blwiLFxuICAgIFwiZnVubnlcIixcbiAgICBcImZ1cm5hY2VcIixcbiAgICBcImZ1cnlcIixcbiAgICBcImZ1dHVyZVwiLFxuICAgIFwiZ2FkZ2V0XCIsXG4gICAgXCJnYWluXCIsXG4gICAgXCJnYWxheHlcIixcbiAgICBcImdhbGxlcnlcIixcbiAgICBcImdhbWVcIixcbiAgICBcImdhcFwiLFxuICAgIFwiZ2FyYWdlXCIsXG4gICAgXCJnYXJiYWdlXCIsXG4gICAgXCJnYXJkZW5cIixcbiAgICBcImdhcmxpY1wiLFxuICAgIFwiZ2FybWVudFwiLFxuICAgIFwiZ2FzXCIsXG4gICAgXCJnYXNwXCIsXG4gICAgXCJnYXRlXCIsXG4gICAgXCJnYXRoZXJcIixcbiAgICBcImdhdWdlXCIsXG4gICAgXCJnYXplXCIsXG4gICAgXCJnZW5lcmFsXCIsXG4gICAgXCJnZW5pdXNcIixcbiAgICBcImdlbnJlXCIsXG4gICAgXCJnZW50bGVcIixcbiAgICBcImdlbnVpbmVcIixcbiAgICBcImdlc3R1cmVcIixcbiAgICBcImdob3N0XCIsXG4gICAgXCJnaWFudFwiLFxuICAgIFwiZ2lmdFwiLFxuICAgIFwiZ2lnZ2xlXCIsXG4gICAgXCJnaW5nZXJcIixcbiAgICBcImdpcmFmZmVcIixcbiAgICBcImdpcmxcIixcbiAgICBcImdpdmVcIixcbiAgICBcImdsYWRcIixcbiAgICBcImdsYW5jZVwiLFxuICAgIFwiZ2xhcmVcIixcbiAgICBcImdsYXNzXCIsXG4gICAgXCJnbGlkZVwiLFxuICAgIFwiZ2xpbXBzZVwiLFxuICAgIFwiZ2xvYmVcIixcbiAgICBcImdsb29tXCIsXG4gICAgXCJnbG9yeVwiLFxuICAgIFwiZ2xvdmVcIixcbiAgICBcImdsb3dcIixcbiAgICBcImdsdWVcIixcbiAgICBcImdvYXRcIixcbiAgICBcImdvZGRlc3NcIixcbiAgICBcImdvbGRcIixcbiAgICBcImdvb2RcIixcbiAgICBcImdvb3NlXCIsXG4gICAgXCJnb3JpbGxhXCIsXG4gICAgXCJnb3NwZWxcIixcbiAgICBcImdvc3NpcFwiLFxuICAgIFwiZ292ZXJuXCIsXG4gICAgXCJnb3duXCIsXG4gICAgXCJncmFiXCIsXG4gICAgXCJncmFjZVwiLFxuICAgIFwiZ3JhaW5cIixcbiAgICBcImdyYW50XCIsXG4gICAgXCJncmFwZVwiLFxuICAgIFwiZ3Jhc3NcIixcbiAgICBcImdyYXZpdHlcIixcbiAgICBcImdyZWF0XCIsXG4gICAgXCJncmVlblwiLFxuICAgIFwiZ3JpZFwiLFxuICAgIFwiZ3JpZWZcIixcbiAgICBcImdyaXRcIixcbiAgICBcImdyb2NlcnlcIixcbiAgICBcImdyb3VwXCIsXG4gICAgXCJncm93XCIsXG4gICAgXCJncnVudFwiLFxuICAgIFwiZ3VhcmRcIixcbiAgICBcImd1ZXNzXCIsXG4gICAgXCJndWlkZVwiLFxuICAgIFwiZ3VpbHRcIixcbiAgICBcImd1aXRhclwiLFxuICAgIFwiZ3VuXCIsXG4gICAgXCJneW1cIixcbiAgICBcImhhYml0XCIsXG4gICAgXCJoYWlyXCIsXG4gICAgXCJoYWxmXCIsXG4gICAgXCJoYW1tZXJcIixcbiAgICBcImhhbXN0ZXJcIixcbiAgICBcImhhbmRcIixcbiAgICBcImhhcHB5XCIsXG4gICAgXCJoYXJib3JcIixcbiAgICBcImhhcmRcIixcbiAgICBcImhhcnNoXCIsXG4gICAgXCJoYXJ2ZXN0XCIsXG4gICAgXCJoYXRcIixcbiAgICBcImhhdmVcIixcbiAgICBcImhhd2tcIixcbiAgICBcImhhemFyZFwiLFxuICAgIFwiaGVhZFwiLFxuICAgIFwiaGVhbHRoXCIsXG4gICAgXCJoZWFydFwiLFxuICAgIFwiaGVhdnlcIixcbiAgICBcImhlZGdlaG9nXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcImhlbGxvXCIsXG4gICAgXCJoZWxtZXRcIixcbiAgICBcImhlbHBcIixcbiAgICBcImhlblwiLFxuICAgIFwiaGVyb1wiLFxuICAgIFwiaGlkZGVuXCIsXG4gICAgXCJoaWdoXCIsXG4gICAgXCJoaWxsXCIsXG4gICAgXCJoaW50XCIsXG4gICAgXCJoaXBcIixcbiAgICBcImhpcmVcIixcbiAgICBcImhpc3RvcnlcIixcbiAgICBcImhvYmJ5XCIsXG4gICAgXCJob2NrZXlcIixcbiAgICBcImhvbGRcIixcbiAgICBcImhvbGVcIixcbiAgICBcImhvbGlkYXlcIixcbiAgICBcImhvbGxvd1wiLFxuICAgIFwiaG9tZVwiLFxuICAgIFwiaG9uZXlcIixcbiAgICBcImhvb2RcIixcbiAgICBcImhvcGVcIixcbiAgICBcImhvcm5cIixcbiAgICBcImhvcnJvclwiLFxuICAgIFwiaG9yc2VcIixcbiAgICBcImhvc3BpdGFsXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3RlbFwiLFxuICAgIFwiaG91clwiLFxuICAgIFwiaG92ZXJcIixcbiAgICBcImh1YlwiLFxuICAgIFwiaHVnZVwiLFxuICAgIFwiaHVtYW5cIixcbiAgICBcImh1bWJsZVwiLFxuICAgIFwiaHVtb3JcIixcbiAgICBcImh1bmRyZWRcIixcbiAgICBcImh1bmdyeVwiLFxuICAgIFwiaHVudFwiLFxuICAgIFwiaHVyZGxlXCIsXG4gICAgXCJodXJyeVwiLFxuICAgIFwiaHVydFwiLFxuICAgIFwiaHVzYmFuZFwiLFxuICAgIFwiaHlicmlkXCIsXG4gICAgXCJpY2VcIixcbiAgICBcImljb25cIixcbiAgICBcImlkZWFcIixcbiAgICBcImlkZW50aWZ5XCIsXG4gICAgXCJpZGxlXCIsXG4gICAgXCJpZ25vcmVcIixcbiAgICBcImlsbFwiLFxuICAgIFwiaWxsZWdhbFwiLFxuICAgIFwiaWxsbmVzc1wiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImltaXRhdGVcIixcbiAgICBcImltbWVuc2VcIixcbiAgICBcImltbXVuZVwiLFxuICAgIFwiaW1wYWN0XCIsXG4gICAgXCJpbXBvc2VcIixcbiAgICBcImltcHJvdmVcIixcbiAgICBcImltcHVsc2VcIixcbiAgICBcImluY2hcIixcbiAgICBcImluY2x1ZGVcIixcbiAgICBcImluY29tZVwiLFxuICAgIFwiaW5jcmVhc2VcIixcbiAgICBcImluZGV4XCIsXG4gICAgXCJpbmRpY2F0ZVwiLFxuICAgIFwiaW5kb29yXCIsXG4gICAgXCJpbmR1c3RyeVwiLFxuICAgIFwiaW5mYW50XCIsXG4gICAgXCJpbmZsaWN0XCIsXG4gICAgXCJpbmZvcm1cIixcbiAgICBcImluaGFsZVwiLFxuICAgIFwiaW5oZXJpdFwiLFxuICAgIFwiaW5pdGlhbFwiLFxuICAgIFwiaW5qZWN0XCIsXG4gICAgXCJpbmp1cnlcIixcbiAgICBcImlubWF0ZVwiLFxuICAgIFwiaW5uZXJcIixcbiAgICBcImlubm9jZW50XCIsXG4gICAgXCJpbnB1dFwiLFxuICAgIFwiaW5xdWlyeVwiLFxuICAgIFwiaW5zYW5lXCIsXG4gICAgXCJpbnNlY3RcIixcbiAgICBcImluc2lkZVwiLFxuICAgIFwiaW5zcGlyZVwiLFxuICAgIFwiaW5zdGFsbFwiLFxuICAgIFwiaW50YWN0XCIsXG4gICAgXCJpbnRlcmVzdFwiLFxuICAgIFwiaW50b1wiLFxuICAgIFwiaW52ZXN0XCIsXG4gICAgXCJpbnZpdGVcIixcbiAgICBcImludm9sdmVcIixcbiAgICBcImlyb25cIixcbiAgICBcImlzbGFuZFwiLFxuICAgIFwiaXNvbGF0ZVwiLFxuICAgIFwiaXNzdWVcIixcbiAgICBcIml0ZW1cIixcbiAgICBcIml2b3J5XCIsXG4gICAgXCJqYWNrZXRcIixcbiAgICBcImphZ3VhclwiLFxuICAgIFwiamFyXCIsXG4gICAgXCJqYXp6XCIsXG4gICAgXCJqZWFsb3VzXCIsXG4gICAgXCJqZWFuc1wiLFxuICAgIFwiamVsbHlcIixcbiAgICBcImpld2VsXCIsXG4gICAgXCJqb2JcIixcbiAgICBcImpvaW5cIixcbiAgICBcImpva2VcIixcbiAgICBcImpvdXJuZXlcIixcbiAgICBcImpveVwiLFxuICAgIFwianVkZ2VcIixcbiAgICBcImp1aWNlXCIsXG4gICAgXCJqdW1wXCIsXG4gICAgXCJqdW5nbGVcIixcbiAgICBcImp1bmlvclwiLFxuICAgIFwianVua1wiLFxuICAgIFwianVzdFwiLFxuICAgIFwia2FuZ2Fyb29cIixcbiAgICBcImtlZW5cIixcbiAgICBcImtlZXBcIixcbiAgICBcImtldGNodXBcIixcbiAgICBcImtleVwiLFxuICAgIFwia2lja1wiLFxuICAgIFwia2lkXCIsXG4gICAgXCJraWRuZXlcIixcbiAgICBcImtpbmRcIixcbiAgICBcImtpbmdkb21cIixcbiAgICBcImtpc3NcIixcbiAgICBcImtpdFwiLFxuICAgIFwia2l0Y2hlblwiLFxuICAgIFwia2l0ZVwiLFxuICAgIFwia2l0dGVuXCIsXG4gICAgXCJraXdpXCIsXG4gICAgXCJrbmVlXCIsXG4gICAgXCJrbmlmZVwiLFxuICAgIFwia25vY2tcIixcbiAgICBcImtub3dcIixcbiAgICBcImxhYlwiLFxuICAgIFwibGFiZWxcIixcbiAgICBcImxhYm9yXCIsXG4gICAgXCJsYWRkZXJcIixcbiAgICBcImxhZHlcIixcbiAgICBcImxha2VcIixcbiAgICBcImxhbXBcIixcbiAgICBcImxhbmd1YWdlXCIsXG4gICAgXCJsYXB0b3BcIixcbiAgICBcImxhcmdlXCIsXG4gICAgXCJsYXRlclwiLFxuICAgIFwibGF0aW5cIixcbiAgICBcImxhdWdoXCIsXG4gICAgXCJsYXVuZHJ5XCIsXG4gICAgXCJsYXZhXCIsXG4gICAgXCJsYXdcIixcbiAgICBcImxhd25cIixcbiAgICBcImxhd3N1aXRcIixcbiAgICBcImxheWVyXCIsXG4gICAgXCJsYXp5XCIsXG4gICAgXCJsZWFkZXJcIixcbiAgICBcImxlYWZcIixcbiAgICBcImxlYXJuXCIsXG4gICAgXCJsZWF2ZVwiLFxuICAgIFwibGVjdHVyZVwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwibGVnXCIsXG4gICAgXCJsZWdhbFwiLFxuICAgIFwibGVnZW5kXCIsXG4gICAgXCJsZWlzdXJlXCIsXG4gICAgXCJsZW1vblwiLFxuICAgIFwibGVuZFwiLFxuICAgIFwibGVuZ3RoXCIsXG4gICAgXCJsZW5zXCIsXG4gICAgXCJsZW9wYXJkXCIsXG4gICAgXCJsZXNzb25cIixcbiAgICBcImxldHRlclwiLFxuICAgIFwibGV2ZWxcIixcbiAgICBcImxpYXJcIixcbiAgICBcImxpYmVydHlcIixcbiAgICBcImxpYnJhcnlcIixcbiAgICBcImxpY2Vuc2VcIixcbiAgICBcImxpZmVcIixcbiAgICBcImxpZnRcIixcbiAgICBcImxpZ2h0XCIsXG4gICAgXCJsaWtlXCIsXG4gICAgXCJsaW1iXCIsXG4gICAgXCJsaW1pdFwiLFxuICAgIFwibGlua1wiLFxuICAgIFwibGlvblwiLFxuICAgIFwibGlxdWlkXCIsXG4gICAgXCJsaXN0XCIsXG4gICAgXCJsaXR0bGVcIixcbiAgICBcImxpdmVcIixcbiAgICBcImxpemFyZFwiLFxuICAgIFwibG9hZFwiLFxuICAgIFwibG9hblwiLFxuICAgIFwibG9ic3RlclwiLFxuICAgIFwibG9jYWxcIixcbiAgICBcImxvY2tcIixcbiAgICBcImxvZ2ljXCIsXG4gICAgXCJsb25lbHlcIixcbiAgICBcImxvbmdcIixcbiAgICBcImxvb3BcIixcbiAgICBcImxvdHRlcnlcIixcbiAgICBcImxvdWRcIixcbiAgICBcImxvdW5nZVwiLFxuICAgIFwibG92ZVwiLFxuICAgIFwibG95YWxcIixcbiAgICBcImx1Y2t5XCIsXG4gICAgXCJsdWdnYWdlXCIsXG4gICAgXCJsdW1iZXJcIixcbiAgICBcImx1bmFyXCIsXG4gICAgXCJsdW5jaFwiLFxuICAgIFwibHV4dXJ5XCIsXG4gICAgXCJseXJpY3NcIixcbiAgICBcIm1hY2hpbmVcIixcbiAgICBcIm1hZFwiLFxuICAgIFwibWFnaWNcIixcbiAgICBcIm1hZ25ldFwiLFxuICAgIFwibWFpZFwiLFxuICAgIFwibWFpbFwiLFxuICAgIFwibWFpblwiLFxuICAgIFwibWFqb3JcIixcbiAgICBcIm1ha2VcIixcbiAgICBcIm1hbW1hbFwiLFxuICAgIFwibWFuXCIsXG4gICAgXCJtYW5hZ2VcIixcbiAgICBcIm1hbmRhdGVcIixcbiAgICBcIm1hbmdvXCIsXG4gICAgXCJtYW5zaW9uXCIsXG4gICAgXCJtYW51YWxcIixcbiAgICBcIm1hcGxlXCIsXG4gICAgXCJtYXJibGVcIixcbiAgICBcIm1hcmNoXCIsXG4gICAgXCJtYXJnaW5cIixcbiAgICBcIm1hcmluZVwiLFxuICAgIFwibWFya2V0XCIsXG4gICAgXCJtYXJyaWFnZVwiLFxuICAgIFwibWFza1wiLFxuICAgIFwibWFzc1wiLFxuICAgIFwibWFzdGVyXCIsXG4gICAgXCJtYXRjaFwiLFxuICAgIFwibWF0ZXJpYWxcIixcbiAgICBcIm1hdGhcIixcbiAgICBcIm1hdHJpeFwiLFxuICAgIFwibWF0dGVyXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJtYXplXCIsXG4gICAgXCJtZWFkb3dcIixcbiAgICBcIm1lYW5cIixcbiAgICBcIm1lYXN1cmVcIixcbiAgICBcIm1lYXRcIixcbiAgICBcIm1lY2hhbmljXCIsXG4gICAgXCJtZWRhbFwiLFxuICAgIFwibWVkaWFcIixcbiAgICBcIm1lbG9keVwiLFxuICAgIFwibWVsdFwiLFxuICAgIFwibWVtYmVyXCIsXG4gICAgXCJtZW1vcnlcIixcbiAgICBcIm1lbnRpb25cIixcbiAgICBcIm1lbnVcIixcbiAgICBcIm1lcmN5XCIsXG4gICAgXCJtZXJnZVwiLFxuICAgIFwibWVyaXRcIixcbiAgICBcIm1lcnJ5XCIsXG4gICAgXCJtZXNoXCIsXG4gICAgXCJtZXNzYWdlXCIsXG4gICAgXCJtZXRhbFwiLFxuICAgIFwibWV0aG9kXCIsXG4gICAgXCJtaWRkbGVcIixcbiAgICBcIm1pZG5pZ2h0XCIsXG4gICAgXCJtaWxrXCIsXG4gICAgXCJtaWxsaW9uXCIsXG4gICAgXCJtaW1pY1wiLFxuICAgIFwibWluZFwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwibWlub3JcIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwibWlyYWNsZVwiLFxuICAgIFwibWlycm9yXCIsXG4gICAgXCJtaXNlcnlcIixcbiAgICBcIm1pc3NcIixcbiAgICBcIm1pc3Rha2VcIixcbiAgICBcIm1peFwiLFxuICAgIFwibWl4ZWRcIixcbiAgICBcIm1peHR1cmVcIixcbiAgICBcIm1vYmlsZVwiLFxuICAgIFwibW9kZWxcIixcbiAgICBcIm1vZGlmeVwiLFxuICAgIFwibW9tXCIsXG4gICAgXCJtb21lbnRcIixcbiAgICBcIm1vbml0b3JcIixcbiAgICBcIm1vbmtleVwiLFxuICAgIFwibW9uc3RlclwiLFxuICAgIFwibW9udGhcIixcbiAgICBcIm1vb25cIixcbiAgICBcIm1vcmFsXCIsXG4gICAgXCJtb3JlXCIsXG4gICAgXCJtb3JuaW5nXCIsXG4gICAgXCJtb3NxdWl0b1wiLFxuICAgIFwibW90aGVyXCIsXG4gICAgXCJtb3Rpb25cIixcbiAgICBcIm1vdG9yXCIsXG4gICAgXCJtb3VudGFpblwiLFxuICAgIFwibW91c2VcIixcbiAgICBcIm1vdmVcIixcbiAgICBcIm1vdmllXCIsXG4gICAgXCJtdWNoXCIsXG4gICAgXCJtdWZmaW5cIixcbiAgICBcIm11bGVcIixcbiAgICBcIm11bHRpcGx5XCIsXG4gICAgXCJtdXNjbGVcIixcbiAgICBcIm11c2V1bVwiLFxuICAgIFwibXVzaHJvb21cIixcbiAgICBcIm11c2ljXCIsXG4gICAgXCJtdXN0XCIsXG4gICAgXCJtdXR1YWxcIixcbiAgICBcIm15c2VsZlwiLFxuICAgIFwibXlzdGVyeVwiLFxuICAgIFwibXl0aFwiLFxuICAgIFwibmFpdmVcIixcbiAgICBcIm5hbWVcIixcbiAgICBcIm5hcGtpblwiLFxuICAgIFwibmFycm93XCIsXG4gICAgXCJuYXN0eVwiLFxuICAgIFwibmF0aW9uXCIsXG4gICAgXCJuYXR1cmVcIixcbiAgICBcIm5lYXJcIixcbiAgICBcIm5lY2tcIixcbiAgICBcIm5lZWRcIixcbiAgICBcIm5lZ2F0aXZlXCIsXG4gICAgXCJuZWdsZWN0XCIsXG4gICAgXCJuZWl0aGVyXCIsXG4gICAgXCJuZXBoZXdcIixcbiAgICBcIm5lcnZlXCIsXG4gICAgXCJuZXN0XCIsXG4gICAgXCJuZXRcIixcbiAgICBcIm5ldHdvcmtcIixcbiAgICBcIm5ldXRyYWxcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJuZXdzXCIsXG4gICAgXCJuZXh0XCIsXG4gICAgXCJuaWNlXCIsXG4gICAgXCJuaWdodFwiLFxuICAgIFwibm9ibGVcIixcbiAgICBcIm5vaXNlXCIsXG4gICAgXCJub21pbmVlXCIsXG4gICAgXCJub29kbGVcIixcbiAgICBcIm5vcm1hbFwiLFxuICAgIFwibm9ydGhcIixcbiAgICBcIm5vc2VcIixcbiAgICBcIm5vdGFibGVcIixcbiAgICBcIm5vdGVcIixcbiAgICBcIm5vdGhpbmdcIixcbiAgICBcIm5vdGljZVwiLFxuICAgIFwibm92ZWxcIixcbiAgICBcIm5vd1wiLFxuICAgIFwibnVjbGVhclwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJudXJzZVwiLFxuICAgIFwibnV0XCIsXG4gICAgXCJvYWtcIixcbiAgICBcIm9iZXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwib2JsaWdlXCIsXG4gICAgXCJvYnNjdXJlXCIsXG4gICAgXCJvYnNlcnZlXCIsXG4gICAgXCJvYnRhaW5cIixcbiAgICBcIm9idmlvdXNcIixcbiAgICBcIm9jY3VyXCIsXG4gICAgXCJvY2VhblwiLFxuICAgIFwib2N0b2JlclwiLFxuICAgIFwib2RvclwiLFxuICAgIFwib2ZmXCIsXG4gICAgXCJvZmZlclwiLFxuICAgIFwib2ZmaWNlXCIsXG4gICAgXCJvZnRlblwiLFxuICAgIFwib2lsXCIsXG4gICAgXCJva2F5XCIsXG4gICAgXCJvbGRcIixcbiAgICBcIm9saXZlXCIsXG4gICAgXCJvbHltcGljXCIsXG4gICAgXCJvbWl0XCIsXG4gICAgXCJvbmNlXCIsXG4gICAgXCJvbmVcIixcbiAgICBcIm9uaW9uXCIsXG4gICAgXCJvbmxpbmVcIixcbiAgICBcIm9ubHlcIixcbiAgICBcIm9wZW5cIixcbiAgICBcIm9wZXJhXCIsXG4gICAgXCJvcGluaW9uXCIsXG4gICAgXCJvcHBvc2VcIixcbiAgICBcIm9wdGlvblwiLFxuICAgIFwib3JhbmdlXCIsXG4gICAgXCJvcmJpdFwiLFxuICAgIFwib3JjaGFyZFwiLFxuICAgIFwib3JkZXJcIixcbiAgICBcIm9yZGluYXJ5XCIsXG4gICAgXCJvcmdhblwiLFxuICAgIFwib3JpZW50XCIsXG4gICAgXCJvcmlnaW5hbFwiLFxuICAgIFwib3JwaGFuXCIsXG4gICAgXCJvc3RyaWNoXCIsXG4gICAgXCJvdGhlclwiLFxuICAgIFwib3V0ZG9vclwiLFxuICAgIFwib3V0ZXJcIixcbiAgICBcIm91dHB1dFwiLFxuICAgIFwib3V0c2lkZVwiLFxuICAgIFwib3ZhbFwiLFxuICAgIFwib3ZlblwiLFxuICAgIFwib3ZlclwiLFxuICAgIFwib3duXCIsXG4gICAgXCJvd25lclwiLFxuICAgIFwib3h5Z2VuXCIsXG4gICAgXCJveXN0ZXJcIixcbiAgICBcIm96b25lXCIsXG4gICAgXCJwYWN0XCIsXG4gICAgXCJwYWRkbGVcIixcbiAgICBcInBhZ2VcIixcbiAgICBcInBhaXJcIixcbiAgICBcInBhbGFjZVwiLFxuICAgIFwicGFsbVwiLFxuICAgIFwicGFuZGFcIixcbiAgICBcInBhbmVsXCIsXG4gICAgXCJwYW5pY1wiLFxuICAgIFwicGFudGhlclwiLFxuICAgIFwicGFwZXJcIixcbiAgICBcInBhcmFkZVwiLFxuICAgIFwicGFyZW50XCIsXG4gICAgXCJwYXJrXCIsXG4gICAgXCJwYXJyb3RcIixcbiAgICBcInBhcnR5XCIsXG4gICAgXCJwYXNzXCIsXG4gICAgXCJwYXRjaFwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0aWVudFwiLFxuICAgIFwicGF0cm9sXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJwYXVzZVwiLFxuICAgIFwicGF2ZVwiLFxuICAgIFwicGF5bWVudFwiLFxuICAgIFwicGVhY2VcIixcbiAgICBcInBlYW51dFwiLFxuICAgIFwicGVhclwiLFxuICAgIFwicGVhc2FudFwiLFxuICAgIFwicGVsaWNhblwiLFxuICAgIFwicGVuXCIsXG4gICAgXCJwZW5hbHR5XCIsXG4gICAgXCJwZW5jaWxcIixcbiAgICBcInBlb3BsZVwiLFxuICAgIFwicGVwcGVyXCIsXG4gICAgXCJwZXJmZWN0XCIsXG4gICAgXCJwZXJtaXRcIixcbiAgICBcInBlcnNvblwiLFxuICAgIFwicGV0XCIsXG4gICAgXCJwaG9uZVwiLFxuICAgIFwicGhvdG9cIixcbiAgICBcInBocmFzZVwiLFxuICAgIFwicGh5c2ljYWxcIixcbiAgICBcInBpYW5vXCIsXG4gICAgXCJwaWNuaWNcIixcbiAgICBcInBpY3R1cmVcIixcbiAgICBcInBpZWNlXCIsXG4gICAgXCJwaWdcIixcbiAgICBcInBpZ2VvblwiLFxuICAgIFwicGlsbFwiLFxuICAgIFwicGlsb3RcIixcbiAgICBcInBpbmtcIixcbiAgICBcInBpb25lZXJcIixcbiAgICBcInBpcGVcIixcbiAgICBcInBpc3RvbFwiLFxuICAgIFwicGl0Y2hcIixcbiAgICBcInBpenphXCIsXG4gICAgXCJwbGFjZVwiLFxuICAgIFwicGxhbmV0XCIsXG4gICAgXCJwbGFzdGljXCIsXG4gICAgXCJwbGF0ZVwiLFxuICAgIFwicGxheVwiLFxuICAgIFwicGxlYXNlXCIsXG4gICAgXCJwbGVkZ2VcIixcbiAgICBcInBsdWNrXCIsXG4gICAgXCJwbHVnXCIsXG4gICAgXCJwbHVuZ2VcIixcbiAgICBcInBvZW1cIixcbiAgICBcInBvZXRcIixcbiAgICBcInBvaW50XCIsXG4gICAgXCJwb2xhclwiLFxuICAgIFwicG9sZVwiLFxuICAgIFwicG9saWNlXCIsXG4gICAgXCJwb25kXCIsXG4gICAgXCJwb255XCIsXG4gICAgXCJwb29sXCIsXG4gICAgXCJwb3B1bGFyXCIsXG4gICAgXCJwb3J0aW9uXCIsXG4gICAgXCJwb3NpdGlvblwiLFxuICAgIFwicG9zc2libGVcIixcbiAgICBcInBvc3RcIixcbiAgICBcInBvdGF0b1wiLFxuICAgIFwicG90dGVyeVwiLFxuICAgIFwicG92ZXJ0eVwiLFxuICAgIFwicG93ZGVyXCIsXG4gICAgXCJwb3dlclwiLFxuICAgIFwicHJhY3RpY2VcIixcbiAgICBcInByYWlzZVwiLFxuICAgIFwicHJlZGljdFwiLFxuICAgIFwicHJlZmVyXCIsXG4gICAgXCJwcmVwYXJlXCIsXG4gICAgXCJwcmVzZW50XCIsXG4gICAgXCJwcmV0dHlcIixcbiAgICBcInByZXZlbnRcIixcbiAgICBcInByaWNlXCIsXG4gICAgXCJwcmlkZVwiLFxuICAgIFwicHJpbWFyeVwiLFxuICAgIFwicHJpbnRcIixcbiAgICBcInByaW9yaXR5XCIsXG4gICAgXCJwcmlzb25cIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInByaXplXCIsXG4gICAgXCJwcm9ibGVtXCIsXG4gICAgXCJwcm9jZXNzXCIsXG4gICAgXCJwcm9kdWNlXCIsXG4gICAgXCJwcm9maXRcIixcbiAgICBcInByb2dyYW1cIixcbiAgICBcInByb2plY3RcIixcbiAgICBcInByb21vdGVcIixcbiAgICBcInByb29mXCIsXG4gICAgXCJwcm9wZXJ0eVwiLFxuICAgIFwicHJvc3BlclwiLFxuICAgIFwicHJvdGVjdFwiLFxuICAgIFwicHJvdWRcIixcbiAgICBcInByb3ZpZGVcIixcbiAgICBcInB1YmxpY1wiLFxuICAgIFwicHVkZGluZ1wiLFxuICAgIFwicHVsbFwiLFxuICAgIFwicHVscFwiLFxuICAgIFwicHVsc2VcIixcbiAgICBcInB1bXBraW5cIixcbiAgICBcInB1bmNoXCIsXG4gICAgXCJwdXBpbFwiLFxuICAgIFwicHVwcHlcIixcbiAgICBcInB1cmNoYXNlXCIsXG4gICAgXCJwdXJpdHlcIixcbiAgICBcInB1cnBvc2VcIixcbiAgICBcInB1cnNlXCIsXG4gICAgXCJwdXNoXCIsXG4gICAgXCJwdXRcIixcbiAgICBcInB1enpsZVwiLFxuICAgIFwicHlyYW1pZFwiLFxuICAgIFwicXVhbGl0eVwiLFxuICAgIFwicXVhbnR1bVwiLFxuICAgIFwicXVhcnRlclwiLFxuICAgIFwicXVlc3Rpb25cIixcbiAgICBcInF1aWNrXCIsXG4gICAgXCJxdWl0XCIsXG4gICAgXCJxdWl6XCIsXG4gICAgXCJxdW90ZVwiLFxuICAgIFwicmFiYml0XCIsXG4gICAgXCJyYWNjb29uXCIsXG4gICAgXCJyYWNlXCIsXG4gICAgXCJyYWNrXCIsXG4gICAgXCJyYWRhclwiLFxuICAgIFwicmFkaW9cIixcbiAgICBcInJhaWxcIixcbiAgICBcInJhaW5cIixcbiAgICBcInJhaXNlXCIsXG4gICAgXCJyYWxseVwiLFxuICAgIFwicmFtcFwiLFxuICAgIFwicmFuY2hcIixcbiAgICBcInJhbmRvbVwiLFxuICAgIFwicmFuZ2VcIixcbiAgICBcInJhcGlkXCIsXG4gICAgXCJyYXJlXCIsXG4gICAgXCJyYXRlXCIsXG4gICAgXCJyYXRoZXJcIixcbiAgICBcInJhdmVuXCIsXG4gICAgXCJyYXdcIixcbiAgICBcInJhem9yXCIsXG4gICAgXCJyZWFkeVwiLFxuICAgIFwicmVhbFwiLFxuICAgIFwicmVhc29uXCIsXG4gICAgXCJyZWJlbFwiLFxuICAgIFwicmVidWlsZFwiLFxuICAgIFwicmVjYWxsXCIsXG4gICAgXCJyZWNlaXZlXCIsXG4gICAgXCJyZWNpcGVcIixcbiAgICBcInJlY29yZFwiLFxuICAgIFwicmVjeWNsZVwiLFxuICAgIFwicmVkdWNlXCIsXG4gICAgXCJyZWZsZWN0XCIsXG4gICAgXCJyZWZvcm1cIixcbiAgICBcInJlZnVzZVwiLFxuICAgIFwicmVnaW9uXCIsXG4gICAgXCJyZWdyZXRcIixcbiAgICBcInJlZ3VsYXJcIixcbiAgICBcInJlamVjdFwiLFxuICAgIFwicmVsYXhcIixcbiAgICBcInJlbGVhc2VcIixcbiAgICBcInJlbGllZlwiLFxuICAgIFwicmVseVwiLFxuICAgIFwicmVtYWluXCIsXG4gICAgXCJyZW1lbWJlclwiLFxuICAgIFwicmVtaW5kXCIsXG4gICAgXCJyZW1vdmVcIixcbiAgICBcInJlbmRlclwiLFxuICAgIFwicmVuZXdcIixcbiAgICBcInJlbnRcIixcbiAgICBcInJlb3BlblwiLFxuICAgIFwicmVwYWlyXCIsXG4gICAgXCJyZXBlYXRcIixcbiAgICBcInJlcGxhY2VcIixcbiAgICBcInJlcG9ydFwiLFxuICAgIFwicmVxdWlyZVwiLFxuICAgIFwicmVzY3VlXCIsXG4gICAgXCJyZXNlbWJsZVwiLFxuICAgIFwicmVzaXN0XCIsXG4gICAgXCJyZXNvdXJjZVwiLFxuICAgIFwicmVzcG9uc2VcIixcbiAgICBcInJlc3VsdFwiLFxuICAgIFwicmV0aXJlXCIsXG4gICAgXCJyZXRyZWF0XCIsXG4gICAgXCJyZXR1cm5cIixcbiAgICBcInJldW5pb25cIixcbiAgICBcInJldmVhbFwiLFxuICAgIFwicmV2aWV3XCIsXG4gICAgXCJyZXdhcmRcIixcbiAgICBcInJoeXRobVwiLFxuICAgIFwicmliXCIsXG4gICAgXCJyaWJib25cIixcbiAgICBcInJpY2VcIixcbiAgICBcInJpY2hcIixcbiAgICBcInJpZGVcIixcbiAgICBcInJpZGdlXCIsXG4gICAgXCJyaWZsZVwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcInJpZ2lkXCIsXG4gICAgXCJyaW5nXCIsXG4gICAgXCJyaW90XCIsXG4gICAgXCJyaXBwbGVcIixcbiAgICBcInJpc2tcIixcbiAgICBcInJpdHVhbFwiLFxuICAgIFwicml2YWxcIixcbiAgICBcInJpdmVyXCIsXG4gICAgXCJyb2FkXCIsXG4gICAgXCJyb2FzdFwiLFxuICAgIFwicm9ib3RcIixcbiAgICBcInJvYnVzdFwiLFxuICAgIFwicm9ja2V0XCIsXG4gICAgXCJyb21hbmNlXCIsXG4gICAgXCJyb29mXCIsXG4gICAgXCJyb29raWVcIixcbiAgICBcInJvb21cIixcbiAgICBcInJvc2VcIixcbiAgICBcInJvdGF0ZVwiLFxuICAgIFwicm91Z2hcIixcbiAgICBcInJvdW5kXCIsXG4gICAgXCJyb3V0ZVwiLFxuICAgIFwicm95YWxcIixcbiAgICBcInJ1YmJlclwiLFxuICAgIFwicnVkZVwiLFxuICAgIFwicnVnXCIsXG4gICAgXCJydWxlXCIsXG4gICAgXCJydW5cIixcbiAgICBcInJ1bndheVwiLFxuICAgIFwicnVyYWxcIixcbiAgICBcInNhZFwiLFxuICAgIFwic2FkZGxlXCIsXG4gICAgXCJzYWRuZXNzXCIsXG4gICAgXCJzYWZlXCIsXG4gICAgXCJzYWlsXCIsXG4gICAgXCJzYWxhZFwiLFxuICAgIFwic2FsbW9uXCIsXG4gICAgXCJzYWxvblwiLFxuICAgIFwic2FsdFwiLFxuICAgIFwic2FsdXRlXCIsXG4gICAgXCJzYW1lXCIsXG4gICAgXCJzYW1wbGVcIixcbiAgICBcInNhbmRcIixcbiAgICBcInNhdGlzZnlcIixcbiAgICBcInNhdG9zaGlcIixcbiAgICBcInNhdWNlXCIsXG4gICAgXCJzYXVzYWdlXCIsXG4gICAgXCJzYXZlXCIsXG4gICAgXCJzYXlcIixcbiAgICBcInNjYWxlXCIsXG4gICAgXCJzY2FuXCIsXG4gICAgXCJzY2FyZVwiLFxuICAgIFwic2NhdHRlclwiLFxuICAgIFwic2NlbmVcIixcbiAgICBcInNjaGVtZVwiLFxuICAgIFwic2Nob29sXCIsXG4gICAgXCJzY2llbmNlXCIsXG4gICAgXCJzY2lzc29yc1wiLFxuICAgIFwic2NvcnBpb25cIixcbiAgICBcInNjb3V0XCIsXG4gICAgXCJzY3JhcFwiLFxuICAgIFwic2NyZWVuXCIsXG4gICAgXCJzY3JpcHRcIixcbiAgICBcInNjcnViXCIsXG4gICAgXCJzZWFcIixcbiAgICBcInNlYXJjaFwiLFxuICAgIFwic2Vhc29uXCIsXG4gICAgXCJzZWF0XCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcInNlY3JldFwiLFxuICAgIFwic2VjdGlvblwiLFxuICAgIFwic2VjdXJpdHlcIixcbiAgICBcInNlZWRcIixcbiAgICBcInNlZWtcIixcbiAgICBcInNlZ21lbnRcIixcbiAgICBcInNlbGVjdFwiLFxuICAgIFwic2VsbFwiLFxuICAgIFwic2VtaW5hclwiLFxuICAgIFwic2VuaW9yXCIsXG4gICAgXCJzZW5zZVwiLFxuICAgIFwic2VudGVuY2VcIixcbiAgICBcInNlcmllc1wiLFxuICAgIFwic2VydmljZVwiLFxuICAgIFwic2Vzc2lvblwiLFxuICAgIFwic2V0dGxlXCIsXG4gICAgXCJzZXR1cFwiLFxuICAgIFwic2V2ZW5cIixcbiAgICBcInNoYWRvd1wiLFxuICAgIFwic2hhZnRcIixcbiAgICBcInNoYWxsb3dcIixcbiAgICBcInNoYXJlXCIsXG4gICAgXCJzaGVkXCIsXG4gICAgXCJzaGVsbFwiLFxuICAgIFwic2hlcmlmZlwiLFxuICAgIFwic2hpZWxkXCIsXG4gICAgXCJzaGlmdFwiLFxuICAgIFwic2hpbmVcIixcbiAgICBcInNoaXBcIixcbiAgICBcInNoaXZlclwiLFxuICAgIFwic2hvY2tcIixcbiAgICBcInNob2VcIixcbiAgICBcInNob290XCIsXG4gICAgXCJzaG9wXCIsXG4gICAgXCJzaG9ydFwiLFxuICAgIFwic2hvdWxkZXJcIixcbiAgICBcInNob3ZlXCIsXG4gICAgXCJzaHJpbXBcIixcbiAgICBcInNocnVnXCIsXG4gICAgXCJzaHVmZmxlXCIsXG4gICAgXCJzaHlcIixcbiAgICBcInNpYmxpbmdcIixcbiAgICBcInNpY2tcIixcbiAgICBcInNpZGVcIixcbiAgICBcInNpZWdlXCIsXG4gICAgXCJzaWdodFwiLFxuICAgIFwic2lnblwiLFxuICAgIFwic2lsZW50XCIsXG4gICAgXCJzaWxrXCIsXG4gICAgXCJzaWxseVwiLFxuICAgIFwic2lsdmVyXCIsXG4gICAgXCJzaW1pbGFyXCIsXG4gICAgXCJzaW1wbGVcIixcbiAgICBcInNpbmNlXCIsXG4gICAgXCJzaW5nXCIsXG4gICAgXCJzaXJlblwiLFxuICAgIFwic2lzdGVyXCIsXG4gICAgXCJzaXR1YXRlXCIsXG4gICAgXCJzaXhcIixcbiAgICBcInNpemVcIixcbiAgICBcInNrYXRlXCIsXG4gICAgXCJza2V0Y2hcIixcbiAgICBcInNraVwiLFxuICAgIFwic2tpbGxcIixcbiAgICBcInNraW5cIixcbiAgICBcInNraXJ0XCIsXG4gICAgXCJza3VsbFwiLFxuICAgIFwic2xhYlwiLFxuICAgIFwic2xhbVwiLFxuICAgIFwic2xlZXBcIixcbiAgICBcInNsZW5kZXJcIixcbiAgICBcInNsaWNlXCIsXG4gICAgXCJzbGlkZVwiLFxuICAgIFwic2xpZ2h0XCIsXG4gICAgXCJzbGltXCIsXG4gICAgXCJzbG9nYW5cIixcbiAgICBcInNsb3RcIixcbiAgICBcInNsb3dcIixcbiAgICBcInNsdXNoXCIsXG4gICAgXCJzbWFsbFwiLFxuICAgIFwic21hcnRcIixcbiAgICBcInNtaWxlXCIsXG4gICAgXCJzbW9rZVwiLFxuICAgIFwic21vb3RoXCIsXG4gICAgXCJzbmFja1wiLFxuICAgIFwic25ha2VcIixcbiAgICBcInNuYXBcIixcbiAgICBcInNuaWZmXCIsXG4gICAgXCJzbm93XCIsXG4gICAgXCJzb2FwXCIsXG4gICAgXCJzb2NjZXJcIixcbiAgICBcInNvY2lhbFwiLFxuICAgIFwic29ja1wiLFxuICAgIFwic29kYVwiLFxuICAgIFwic29mdFwiLFxuICAgIFwic29sYXJcIixcbiAgICBcInNvbGRpZXJcIixcbiAgICBcInNvbGlkXCIsXG4gICAgXCJzb2x1dGlvblwiLFxuICAgIFwic29sdmVcIixcbiAgICBcInNvbWVvbmVcIixcbiAgICBcInNvbmdcIixcbiAgICBcInNvb25cIixcbiAgICBcInNvcnJ5XCIsXG4gICAgXCJzb3J0XCIsXG4gICAgXCJzb3VsXCIsXG4gICAgXCJzb3VuZFwiLFxuICAgIFwic291cFwiLFxuICAgIFwic291cmNlXCIsXG4gICAgXCJzb3V0aFwiLFxuICAgIFwic3BhY2VcIixcbiAgICBcInNwYXJlXCIsXG4gICAgXCJzcGF0aWFsXCIsXG4gICAgXCJzcGF3blwiLFxuICAgIFwic3BlYWtcIixcbiAgICBcInNwZWNpYWxcIixcbiAgICBcInNwZWVkXCIsXG4gICAgXCJzcGVsbFwiLFxuICAgIFwic3BlbmRcIixcbiAgICBcInNwaGVyZVwiLFxuICAgIFwic3BpY2VcIixcbiAgICBcInNwaWRlclwiLFxuICAgIFwic3Bpa2VcIixcbiAgICBcInNwaW5cIixcbiAgICBcInNwaXJpdFwiLFxuICAgIFwic3BsaXRcIixcbiAgICBcInNwb2lsXCIsXG4gICAgXCJzcG9uc29yXCIsXG4gICAgXCJzcG9vblwiLFxuICAgIFwic3BvcnRcIixcbiAgICBcInNwb3RcIixcbiAgICBcInNwcmF5XCIsXG4gICAgXCJzcHJlYWRcIixcbiAgICBcInNwcmluZ1wiLFxuICAgIFwic3B5XCIsXG4gICAgXCJzcXVhcmVcIixcbiAgICBcInNxdWVlemVcIixcbiAgICBcInNxdWlycmVsXCIsXG4gICAgXCJzdGFibGVcIixcbiAgICBcInN0YWRpdW1cIixcbiAgICBcInN0YWZmXCIsXG4gICAgXCJzdGFnZVwiLFxuICAgIFwic3RhaXJzXCIsXG4gICAgXCJzdGFtcFwiLFxuICAgIFwic3RhbmRcIixcbiAgICBcInN0YXJ0XCIsXG4gICAgXCJzdGF0ZVwiLFxuICAgIFwic3RheVwiLFxuICAgIFwic3RlYWtcIixcbiAgICBcInN0ZWVsXCIsXG4gICAgXCJzdGVtXCIsXG4gICAgXCJzdGVwXCIsXG4gICAgXCJzdGVyZW9cIixcbiAgICBcInN0aWNrXCIsXG4gICAgXCJzdGlsbFwiLFxuICAgIFwic3RpbmdcIixcbiAgICBcInN0b2NrXCIsXG4gICAgXCJzdG9tYWNoXCIsXG4gICAgXCJzdG9uZVwiLFxuICAgIFwic3Rvb2xcIixcbiAgICBcInN0b3J5XCIsXG4gICAgXCJzdG92ZVwiLFxuICAgIFwic3RyYXRlZ3lcIixcbiAgICBcInN0cmVldFwiLFxuICAgIFwic3RyaWtlXCIsXG4gICAgXCJzdHJvbmdcIixcbiAgICBcInN0cnVnZ2xlXCIsXG4gICAgXCJzdHVkZW50XCIsXG4gICAgXCJzdHVmZlwiLFxuICAgIFwic3R1bWJsZVwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInN1YmplY3RcIixcbiAgICBcInN1Ym1pdFwiLFxuICAgIFwic3Vid2F5XCIsXG4gICAgXCJzdWNjZXNzXCIsXG4gICAgXCJzdWNoXCIsXG4gICAgXCJzdWRkZW5cIixcbiAgICBcInN1ZmZlclwiLFxuICAgIFwic3VnYXJcIixcbiAgICBcInN1Z2dlc3RcIixcbiAgICBcInN1aXRcIixcbiAgICBcInN1bW1lclwiLFxuICAgIFwic3VuXCIsXG4gICAgXCJzdW5ueVwiLFxuICAgIFwic3Vuc2V0XCIsXG4gICAgXCJzdXBlclwiLFxuICAgIFwic3VwcGx5XCIsXG4gICAgXCJzdXByZW1lXCIsXG4gICAgXCJzdXJlXCIsXG4gICAgXCJzdXJmYWNlXCIsXG4gICAgXCJzdXJnZVwiLFxuICAgIFwic3VycHJpc2VcIixcbiAgICBcInN1cnJvdW5kXCIsXG4gICAgXCJzdXJ2ZXlcIixcbiAgICBcInN1c3BlY3RcIixcbiAgICBcInN1c3RhaW5cIixcbiAgICBcInN3YWxsb3dcIixcbiAgICBcInN3YW1wXCIsXG4gICAgXCJzd2FwXCIsXG4gICAgXCJzd2FybVwiLFxuICAgIFwic3dlYXJcIixcbiAgICBcInN3ZWV0XCIsXG4gICAgXCJzd2lmdFwiLFxuICAgIFwic3dpbVwiLFxuICAgIFwic3dpbmdcIixcbiAgICBcInN3aXRjaFwiLFxuICAgIFwic3dvcmRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwic3ltcHRvbVwiLFxuICAgIFwic3lydXBcIixcbiAgICBcInN5c3RlbVwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInRhY2tsZVwiLFxuICAgIFwidGFnXCIsXG4gICAgXCJ0YWlsXCIsXG4gICAgXCJ0YWxlbnRcIixcbiAgICBcInRhbGtcIixcbiAgICBcInRhbmtcIixcbiAgICBcInRhcGVcIixcbiAgICBcInRhcmdldFwiLFxuICAgIFwidGFza1wiLFxuICAgIFwidGFzdGVcIixcbiAgICBcInRhdHRvb1wiLFxuICAgIFwidGF4aVwiLFxuICAgIFwidGVhY2hcIixcbiAgICBcInRlYW1cIixcbiAgICBcInRlbGxcIixcbiAgICBcInRlblwiLFxuICAgIFwidGVuYW50XCIsXG4gICAgXCJ0ZW5uaXNcIixcbiAgICBcInRlbnRcIixcbiAgICBcInRlcm1cIixcbiAgICBcInRlc3RcIixcbiAgICBcInRleHRcIixcbiAgICBcInRoYW5rXCIsXG4gICAgXCJ0aGF0XCIsXG4gICAgXCJ0aGVtZVwiLFxuICAgIFwidGhlblwiLFxuICAgIFwidGhlb3J5XCIsXG4gICAgXCJ0aGVyZVwiLFxuICAgIFwidGhleVwiLFxuICAgIFwidGhpbmdcIixcbiAgICBcInRoaXNcIixcbiAgICBcInRob3VnaHRcIixcbiAgICBcInRocmVlXCIsXG4gICAgXCJ0aHJpdmVcIixcbiAgICBcInRocm93XCIsXG4gICAgXCJ0aHVtYlwiLFxuICAgIFwidGh1bmRlclwiLFxuICAgIFwidGlja2V0XCIsXG4gICAgXCJ0aWRlXCIsXG4gICAgXCJ0aWdlclwiLFxuICAgIFwidGlsdFwiLFxuICAgIFwidGltYmVyXCIsXG4gICAgXCJ0aW1lXCIsXG4gICAgXCJ0aW55XCIsXG4gICAgXCJ0aXBcIixcbiAgICBcInRpcmVkXCIsXG4gICAgXCJ0aXNzdWVcIixcbiAgICBcInRpdGxlXCIsXG4gICAgXCJ0b2FzdFwiLFxuICAgIFwidG9iYWNjb1wiLFxuICAgIFwidG9kYXlcIixcbiAgICBcInRvZGRsZXJcIixcbiAgICBcInRvZVwiLFxuICAgIFwidG9nZXRoZXJcIixcbiAgICBcInRvaWxldFwiLFxuICAgIFwidG9rZW5cIixcbiAgICBcInRvbWF0b1wiLFxuICAgIFwidG9tb3Jyb3dcIixcbiAgICBcInRvbmVcIixcbiAgICBcInRvbmd1ZVwiLFxuICAgIFwidG9uaWdodFwiLFxuICAgIFwidG9vbFwiLFxuICAgIFwidG9vdGhcIixcbiAgICBcInRvcFwiLFxuICAgIFwidG9waWNcIixcbiAgICBcInRvcHBsZVwiLFxuICAgIFwidG9yY2hcIixcbiAgICBcInRvcm5hZG9cIixcbiAgICBcInRvcnRvaXNlXCIsXG4gICAgXCJ0b3NzXCIsXG4gICAgXCJ0b3RhbFwiLFxuICAgIFwidG91cmlzdFwiLFxuICAgIFwidG93YXJkXCIsXG4gICAgXCJ0b3dlclwiLFxuICAgIFwidG93blwiLFxuICAgIFwidG95XCIsXG4gICAgXCJ0cmFja1wiLFxuICAgIFwidHJhZGVcIixcbiAgICBcInRyYWZmaWNcIixcbiAgICBcInRyYWdpY1wiLFxuICAgIFwidHJhaW5cIixcbiAgICBcInRyYW5zZmVyXCIsXG4gICAgXCJ0cmFwXCIsXG4gICAgXCJ0cmFzaFwiLFxuICAgIFwidHJhdmVsXCIsXG4gICAgXCJ0cmF5XCIsXG4gICAgXCJ0cmVhdFwiLFxuICAgIFwidHJlZVwiLFxuICAgIFwidHJlbmRcIixcbiAgICBcInRyaWFsXCIsXG4gICAgXCJ0cmliZVwiLFxuICAgIFwidHJpY2tcIixcbiAgICBcInRyaWdnZXJcIixcbiAgICBcInRyaW1cIixcbiAgICBcInRyaXBcIixcbiAgICBcInRyb3BoeVwiLFxuICAgIFwidHJvdWJsZVwiLFxuICAgIFwidHJ1Y2tcIixcbiAgICBcInRydWVcIixcbiAgICBcInRydWx5XCIsXG4gICAgXCJ0cnVtcGV0XCIsXG4gICAgXCJ0cnVzdFwiLFxuICAgIFwidHJ1dGhcIixcbiAgICBcInRyeVwiLFxuICAgIFwidHViZVwiLFxuICAgIFwidHVpdGlvblwiLFxuICAgIFwidHVtYmxlXCIsXG4gICAgXCJ0dW5hXCIsXG4gICAgXCJ0dW5uZWxcIixcbiAgICBcInR1cmtleVwiLFxuICAgIFwidHVyblwiLFxuICAgIFwidHVydGxlXCIsXG4gICAgXCJ0d2VsdmVcIixcbiAgICBcInR3ZW50eVwiLFxuICAgIFwidHdpY2VcIixcbiAgICBcInR3aW5cIixcbiAgICBcInR3aXN0XCIsXG4gICAgXCJ0d29cIixcbiAgICBcInR5cGVcIixcbiAgICBcInR5cGljYWxcIixcbiAgICBcInVnbHlcIixcbiAgICBcInVtYnJlbGxhXCIsXG4gICAgXCJ1bmFibGVcIixcbiAgICBcInVuYXdhcmVcIixcbiAgICBcInVuY2xlXCIsXG4gICAgXCJ1bmNvdmVyXCIsXG4gICAgXCJ1bmRlclwiLFxuICAgIFwidW5kb1wiLFxuICAgIFwidW5mYWlyXCIsXG4gICAgXCJ1bmZvbGRcIixcbiAgICBcInVuaGFwcHlcIixcbiAgICBcInVuaWZvcm1cIixcbiAgICBcInVuaXF1ZVwiLFxuICAgIFwidW5pdFwiLFxuICAgIFwidW5pdmVyc2VcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInVubG9ja1wiLFxuICAgIFwidW50aWxcIixcbiAgICBcInVudXN1YWxcIixcbiAgICBcInVudmVpbFwiLFxuICAgIFwidXBkYXRlXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ1cGhvbGRcIixcbiAgICBcInVwb25cIixcbiAgICBcInVwcGVyXCIsXG4gICAgXCJ1cHNldFwiLFxuICAgIFwidXJiYW5cIixcbiAgICBcInVyZ2VcIixcbiAgICBcInVzYWdlXCIsXG4gICAgXCJ1c2VcIixcbiAgICBcInVzZWRcIixcbiAgICBcInVzZWZ1bFwiLFxuICAgIFwidXNlbGVzc1wiLFxuICAgIFwidXN1YWxcIixcbiAgICBcInV0aWxpdHlcIixcbiAgICBcInZhY2FudFwiLFxuICAgIFwidmFjdXVtXCIsXG4gICAgXCJ2YWd1ZVwiLFxuICAgIFwidmFsaWRcIixcbiAgICBcInZhbGxleVwiLFxuICAgIFwidmFsdmVcIixcbiAgICBcInZhblwiLFxuICAgIFwidmFuaXNoXCIsXG4gICAgXCJ2YXBvclwiLFxuICAgIFwidmFyaW91c1wiLFxuICAgIFwidmFzdFwiLFxuICAgIFwidmF1bHRcIixcbiAgICBcInZlaGljbGVcIixcbiAgICBcInZlbHZldFwiLFxuICAgIFwidmVuZG9yXCIsXG4gICAgXCJ2ZW50dXJlXCIsXG4gICAgXCJ2ZW51ZVwiLFxuICAgIFwidmVyYlwiLFxuICAgIFwidmVyaWZ5XCIsXG4gICAgXCJ2ZXJzaW9uXCIsXG4gICAgXCJ2ZXJ5XCIsXG4gICAgXCJ2ZXNzZWxcIixcbiAgICBcInZldGVyYW5cIixcbiAgICBcInZpYWJsZVwiLFxuICAgIFwidmlicmFudFwiLFxuICAgIFwidmljaW91c1wiLFxuICAgIFwidmljdG9yeVwiLFxuICAgIFwidmlkZW9cIixcbiAgICBcInZpZXdcIixcbiAgICBcInZpbGxhZ2VcIixcbiAgICBcInZpbnRhZ2VcIixcbiAgICBcInZpb2xpblwiLFxuICAgIFwidmlydHVhbFwiLFxuICAgIFwidmlydXNcIixcbiAgICBcInZpc2FcIixcbiAgICBcInZpc2l0XCIsXG4gICAgXCJ2aXN1YWxcIixcbiAgICBcInZpdGFsXCIsXG4gICAgXCJ2aXZpZFwiLFxuICAgIFwidm9jYWxcIixcbiAgICBcInZvaWNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJ2b2xjYW5vXCIsXG4gICAgXCJ2b2x1bWVcIixcbiAgICBcInZvdGVcIixcbiAgICBcInZveWFnZVwiLFxuICAgIFwid2FnZVwiLFxuICAgIFwid2Fnb25cIixcbiAgICBcIndhaXRcIixcbiAgICBcIndhbGtcIixcbiAgICBcIndhbGxcIixcbiAgICBcIndhbG51dFwiLFxuICAgIFwid2FudFwiLFxuICAgIFwid2FyZmFyZVwiLFxuICAgIFwid2FybVwiLFxuICAgIFwid2FycmlvclwiLFxuICAgIFwid2FzaFwiLFxuICAgIFwid2FzcFwiLFxuICAgIFwid2FzdGVcIixcbiAgICBcIndhdGVyXCIsXG4gICAgXCJ3YXZlXCIsXG4gICAgXCJ3YXlcIixcbiAgICBcIndlYWx0aFwiLFxuICAgIFwid2VhcG9uXCIsXG4gICAgXCJ3ZWFyXCIsXG4gICAgXCJ3ZWFzZWxcIixcbiAgICBcIndlYXRoZXJcIixcbiAgICBcIndlYlwiLFxuICAgIFwid2VkZGluZ1wiLFxuICAgIFwid2Vla2VuZFwiLFxuICAgIFwid2VpcmRcIixcbiAgICBcIndlbGNvbWVcIixcbiAgICBcIndlc3RcIixcbiAgICBcIndldFwiLFxuICAgIFwid2hhbGVcIixcbiAgICBcIndoYXRcIixcbiAgICBcIndoZWF0XCIsXG4gICAgXCJ3aGVlbFwiLFxuICAgIFwid2hlblwiLFxuICAgIFwid2hlcmVcIixcbiAgICBcIndoaXBcIixcbiAgICBcIndoaXNwZXJcIixcbiAgICBcIndpZGVcIixcbiAgICBcIndpZHRoXCIsXG4gICAgXCJ3aWZlXCIsXG4gICAgXCJ3aWxkXCIsXG4gICAgXCJ3aWxsXCIsXG4gICAgXCJ3aW5cIixcbiAgICBcIndpbmRvd1wiLFxuICAgIFwid2luZVwiLFxuICAgIFwid2luZ1wiLFxuICAgIFwid2lua1wiLFxuICAgIFwid2lubmVyXCIsXG4gICAgXCJ3aW50ZXJcIixcbiAgICBcIndpcmVcIixcbiAgICBcIndpc2RvbVwiLFxuICAgIFwid2lzZVwiLFxuICAgIFwid2lzaFwiLFxuICAgIFwid2l0bmVzc1wiLFxuICAgIFwid29sZlwiLFxuICAgIFwid29tYW5cIixcbiAgICBcIndvbmRlclwiLFxuICAgIFwid29vZFwiLFxuICAgIFwid29vbFwiLFxuICAgIFwid29yZFwiLFxuICAgIFwid29ya1wiLFxuICAgIFwid29ybGRcIixcbiAgICBcIndvcnJ5XCIsXG4gICAgXCJ3b3J0aFwiLFxuICAgIFwid3JhcFwiLFxuICAgIFwid3JlY2tcIixcbiAgICBcIndyZXN0bGVcIixcbiAgICBcIndyaXN0XCIsXG4gICAgXCJ3cml0ZVwiLFxuICAgIFwid3JvbmdcIixcbiAgICBcInlhcmRcIixcbiAgICBcInllYXJcIixcbiAgICBcInllbGxvd1wiLFxuICAgIFwieW91XCIsXG4gICAgXCJ5b3VuZ1wiLFxuICAgIFwieW91dGhcIixcbiAgICBcInplYnJhXCIsXG4gICAgXCJ6ZXJvXCIsXG4gICAgXCJ6b25lXCIsXG4gICAgXCJ6b29cIlxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbmdsaXNoOyIsImNvbnN0IG5hY2wgPSByZXF1aXJlKCcuL25hY2wvbmFjbFdyYXBwZXJzJyk7XG5jb25zdCBhZGRyZXNzID0gcmVxdWlyZSgnLi9lbmNvZGluZy9hZGRyZXNzJyk7XG5jb25zdCBlbmNvZGluZyA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvZW5jb2RpbmcnKTtcbmNvbnN0IHR4bkJ1aWxkZXIgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4gVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgbXVsdGlzaWcgdHJhbnNhY3Rpb24gYmxvYnMuXG4gKi9cblxuY29uc3QgRVJST1JfTVVMVElTSUdfTUVSR0VfTEVTU1RIQU5UV08gPSBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIG11bHRpc2lnIHRyYW5zYWN0aW9ucyB0byBtZXJnZS4gTmVlZCBhdCBsZWFzdCB0d29cIik7XG5jb25zdCBFUlJPUl9NVUxUSVNJR19NRVJHRV9NSVNNQVRDSCA9IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0eHMuIHR4SURzIGRpZmZlclwiKTtcbmNvbnN0IEVSUk9SX01VTFRJU0lHX01FUkdFX1dST05HX1BSRUlNQUdFID0gbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHR4cy4gTXVsdGlzaWcgcHJlaW1hZ2VzIGRpZmZlclwiKTtcbmNvbnN0IEVSUk9SX01VTFRJU0lHX01FUkdFX1NJR19NSVNNQVRDSCA9IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0eHMuIHN1YnNpZ3MgYXJlIG1pc21hdGNoZWQuXCIpO1xuY29uc3QgRVJST1JfTVVMVElTSUdfQkFEX0ZST01fRklFTEQgPSBuZXcgRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb24gZnJvbSBmaWVsZCBhbmQgbXVsdGlzaWcgcHJlaW1hZ2UgZG8gbm90IG1hdGNoLlwiKTtcbmNvbnN0IEVSUk9SX01VTFRJU0lHX0tFWV9OT1RfRVhJU1QgPSBuZXcgRXJyb3IoXCJLZXkgZG9lcyBub3QgZXhpc3RcIik7XG5cbi8qKlxuICogTXVsdGlzaWdUcmFuc2FjdGlvbiBpcyBhIFRyYW5zYWN0aW9uIHRoYXQgYWxzbyBzdXBwb3J0cyBjcmVhdGluZyBwYXJ0aWFsbHktc2lnbmVkIG11bHRpc2lnIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgTXVsdGlzaWdUcmFuc2FjdGlvbiBleHRlbmRzIHR4bkJ1aWxkZXIuVHJhbnNhY3Rpb24ge1xuICAgIGdldF9vYmpfZm9yX2VuY29kaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcIm9iakZvckVuY29kaW5nXCIpKSB7XG4gICAgICAgICAgICAvLyBpZiBzZXQsIHVzZSB0aGUgdmFsdWUgZm9yIGVuY29kaW5nLiBUaGlzIGFsbG93cyB1cyB0byBzaWduIGV4aXN0aW5nIG5vbi1wYXltZW50IHR5cGUgdHJhbnNhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqRm9yRW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldF9vYmpfZm9yX2VuY29kaW5nKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21fb2JqX2Zvcl9lbmNvZGluZyh0eG5Gb3JFbmMpIHtcbiAgICAgICAgaWYgKHR4bkZvckVuYy50eXBlICE9PSBcInBheVwiKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IGRlY29kaW5nIHRoaXMgdHhuIHlldCAtIGJ1dCB3ZSBjYW4ga2VlcCBzaWduaW5nIGl0IHNpbmNlIHdlIGhhdmUgdGhlXG4gICAgICAgICAgICAvLyBlbmNvZGVkIGZvcm1hdC4gV2UgdHJ1c3QgdGhhdCB0aGUgY2FsbGVyIGtub3dzIHdoYXQgdGhleSBhcmUgdHJ5aW5nIHRvIHNpZ24uXG4gICAgICAgICAgICBsZXQgdHhuID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB0eG4ubmFtZSA9IFwiVHJhbnNhY3Rpb25cIjtcbiAgICAgICAgICAgIHR4bi50YWcgPSBCdWZmZXIuZnJvbShbODQsIDg4XSk7IC8vIFwiVFhcIlxuXG4gICAgICAgICAgICB0eG4ub2JqRm9yRW5jb2RpbmcgPSB0eG5Gb3JFbmM7XG4gICAgICAgICAgICByZXR1cm4gdHhuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5mcm9tX29ial9mb3JfZW5jb2RpbmcodHhuRm9yRW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXJ0aWFsU2lnblR4biBwYXJ0aWFsbHkgc2lnbnMgdGhpcyB0cmFuc2FjdGlvbiBhbmQgcmV0dXJucyBhIHBhcnRpYWxseS1zaWduZWQgbXVsdGlzaWcgdHJhbnNhY3Rpb24sXG4gICAgICogZW5jb2RlZCB3aXRoIG1zZ3BhY2sgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBtdWx0aXNpZyB2ZXJzaW9uXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCBtdWx0aXNpZyB0aHJlc2hvbGRcbiAgICAgKiBAcGFyYW0gcGtzIG11bHRpc2lnIHB1YmxpYyBrZXkgbGlzdCwgb3JkZXIgaXMgaW1wb3J0YW50LlxuICAgICAqIEBwYXJhbSBzayBhbiBBbGdvcmFuZCBzZWNyZXQga2V5IHRvIHNpZ24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyBhbiBlbmNvZGVkLCBwYXJ0aWFsbHkgc2lnbmVkIG11bHRpc2lnIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHBhcnRpYWxTaWduVHhuKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIHBrc30sIHNrKSB7XG4gICAgICAgIC8vIHZlcmlmeSBvbmUgbW9yZSB0aW1lIHRoYXQgdGhlIGZyb20gZmllbGQgaXMgY29ycmVjdFxuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoXCJvYmpGb3JFbmNvZGluZ1wiKSkge1xuICAgICAgICAgICAgbGV0IGV4cGVjdGVkRnJvbVJhdyA9IGFkZHJlc3MuZnJvbU11bHRpc2lnUHJlSW1nKHt2ZXJzaW9uLCB0aHJlc2hvbGQsIHBrc30pO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MuZW5jb2RlKHRoaXMuZnJvbS5wdWJsaWNLZXkpICE9PSBhZGRyZXNzLmVuY29kZShleHBlY3RlZEZyb21SYXcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfTVVMVElTSUdfQkFEX0ZST01fRklFTEQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHNpZ25hdHVyZSB2ZXJpZmllclxuICAgICAgICBsZXQgbXlQayA9IG5hY2wua2V5UGFpckZyb21TZWNyZXRLZXkoc2spLnB1YmxpY0tleTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU11bHRpc2lnVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmdldF9vYmpfZm9yX2VuY29kaW5nKCksXG4gICAgICAgICAgICB7XCJyYXdTaWdcIjogdGhpcy5yYXdTaWduVHhuKHNrKSwgbXlQa30sXG4gICAgICAgICAgICB7dmVyc2lvbiwgdGhyZXNob2xkLCBwa3N9LFxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjcmVhdGVNdWx0aXNpZ1RyYW5zYWN0aW9uIGNyZWF0ZXMgYSBtdWx0aXNpZyB0cmFuc2FjdGlvbiBibG9iLlxuICogQHBhcmFtIHR4bkZvckVuY29kaW5nIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24gdG8gc2lnbi5cbiAqIEBwYXJhbSByYXdTaWcgYSBCdWZmZXIgcmF3IHNpZ25hdHVyZSBvZiB0aGF0IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gbXlQayBhIHB1YmxpYyBrZXkgdGhhdCBjb3JyZXNwb25kcyB3aXRoIHJhd1NpZ1xuICogQHBhcmFtIHZlcnNpb24gbXVsdGlzaWcgdmVyc2lvblxuICogQHBhcmFtIHRocmVzaG9sZCBtdXRsaXNpZyB0aHJlc2hvbGRcbiAqIEBwYXJhbSBwa3Mgb3JkZXJlZCBsaXN0IG9mIHB1YmxpYyBrZXlzIGluIHRoaXMgbXVsdGlzaWdcbiAqIEByZXR1cm5zIGVuY29kZWQgbXVsdGlzaWcgYmxvYlxuICovXG5mdW5jdGlvbiBjcmVhdGVNdWx0aXNpZ1RyYW5zYWN0aW9uKHR4bkZvckVuY29kaW5nLCB7cmF3U2lnLCBteVBrfSwge3ZlcnNpb24sIHRocmVzaG9sZCwgcGtzfSkge1xuICAgIGxldCBrZXlFeGlzdCA9IGZhbHNlO1xuICAgIC8vIGNvbnN0cnVjdCB0aGUgYXBwZW5kYWJsZSBtdWx0aXNpZ25lZCB0cmFuc2FjdGlvbiBmb3JtYXRcbiAgICBsZXQgc3Vic2lncyA9IHBrcy5tYXAocGsgPT4ge1xuICAgICAgICBpZiAobmFjbC5ieXRlc0VxdWFsKHBrLCBteVBrKSkge1xuICAgICAgICAgICAga2V5RXhpc3QgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBcInBrXCI6IEJ1ZmZlci5mcm9tKHBrKSxcbiAgICAgICAgICAgICAgICBcInNcIiA6IHJhd1NpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcInBrXCI6IEJ1ZmZlci5mcm9tKHBrKX07XG4gICAgfSk7XG4gICAgaWYgKGtleUV4aXN0ID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBFUlJPUl9NVUxUSVNJR19LRVlfTk9UX0VYSVNUO1xuICAgIH1cbiAgICBsZXQgbXNpZyA9IHtcbiAgICAgICAgXCJ2XCI6IHZlcnNpb24sXG4gICAgICAgIFwidGhyXCI6IHRocmVzaG9sZCxcbiAgICAgICAgXCJzdWJzaWdcIjogc3Vic2lncyxcbiAgICB9O1xuICAgIGxldCBzVHhuID0ge1xuICAgICAgICBcIm1zaWdcIjogbXNpZyxcbiAgICAgICAgXCJ0eG5cIjogdHhuRm9yRW5jb2RpbmcsXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jb2RpbmcuZW5jb2RlKHNUeG4pKTtcbn1cblxuLyoqXG4gKiBtZXJnZU11bHRpc2lnVHJhbnNhY3Rpb25zIHRha2VzIGEgbGlzdCBvZiBtdWx0aXNpZyB0cmFuc2FjdGlvbiBibG9icywgYW5kIG1lcmdlcyB0aGVtLlxuICogQHBhcmFtIG11bHRpc2lnVHhuQmxvYnMgYSBsaXN0IG9mIGJsb2JzIHJlcHJlc2VudGluZyBlbmNvZGVkIG11bHRpc2lnIHR4bnNcbiAqIEByZXR1cm5zIHR5cGVkIGFycmF5IG1zZy1wYWNrIGVuY29kZWQgbXVsdGlzaWcgdHhuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTXVsdGlzaWdUcmFuc2FjdGlvbnMobXVsdGlzaWdUeG5CbG9icykge1xuICAgIGlmIChtdWx0aXNpZ1R4bkJsb2JzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfTVVMVElTSUdfTUVSR0VfTEVTU1RIQU5UV087XG4gICAgfVxuICAgIGNvbnN0IHJlZlNpZ1R4ID0gZW5jb2RpbmcuZGVjb2RlKG11bHRpc2lnVHhuQmxvYnNbMF0pO1xuICAgIGNvbnN0IHJlZlNpZ0FsZ29UeCA9IE11bHRpc2lnVHJhbnNhY3Rpb24uZnJvbV9vYmpfZm9yX2VuY29kaW5nKHJlZlNpZ1R4LnR4bik7XG4gICAgY29uc3QgcmVmVHhJRFN0ciA9IHJlZlNpZ0FsZ29UeC50eElEKCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmcm9tID0gYWRkcmVzcy5lbmNvZGUocmVmU2lnVHgudHhuLnNuZCk7XG5cbiAgICBsZXQgbmV3U3Vic2lncyA9IHJlZlNpZ1R4Lm1zaWcuc3Vic2lnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXVsdGlzaWdUeG5CbG9icy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdW5pc2lnID0gZW5jb2RpbmcuZGVjb2RlKG11bHRpc2lnVHhuQmxvYnNbaV0pO1xuICAgICAgICBsZXQgdW5pc2lnQWxnb1R4biA9IE11bHRpc2lnVHJhbnNhY3Rpb24uZnJvbV9vYmpfZm9yX2VuY29kaW5nKHVuaXNpZy50eG4pO1xuICAgICAgICBpZiAodW5pc2lnQWxnb1R4bi50eElEKCkudG9TdHJpbmcoKSAhPT0gcmVmVHhJRFN0cikge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfTVVMVElTSUdfTUVSR0VfTUlTTUFUQ0g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgbXVsdGlzaWcgaGFzIHNhbWUgcHJlaW1hZ2UgYXMgcmVmZXJlbmNlXG4gICAgICAgIGlmICh1bmlzaWcubXNpZy5zdWJzaWcubGVuZ3RoICE9PSByZWZTaWdUeC5tc2lnLnN1YnNpZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX01VTFRJU0lHX01FUkdFX1dST05HX1BSRUlNQUdFO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVpbWcgPSB7XG4gICAgICAgICAgICBcInZlcnNpb25cIjogdW5pc2lnLm1zaWcudixcbiAgICAgICAgICAgIFwidGhyZXNob2xkXCI6IHVuaXNpZy5tc2lnLnRocixcbiAgICAgICAgICAgIFwicGtzXCI6IHVuaXNpZy5tc2lnLnN1YnNpZy5tYXAoc3Vic2lnID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2lnLnBrO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmcm9tICE9PSBhZGRyZXNzLmVuY29kZShhZGRyZXNzLmZyb21NdWx0aXNpZ1ByZUltZyhwcmVpbWcpKSkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfTVVMVElTSUdfTUVSR0VfV1JPTkdfUFJFSU1BR0U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93LCB3ZSBjYW4gbWVyZ2VcbiAgICAgICAgbmV3U3Vic2lncyA9IHVuaXNpZy5tc2lnLnN1YnNpZy5tYXAoKHVuaVN1YnNpZywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gbmV3U3Vic2lnc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoY3VycmVudC5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaVN1YnNpZy5zICYmIEJ1ZmZlci5jb21wYXJlKHVuaVN1YnNpZy5zLCBjdXJyZW50LnMpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVSUk9SX01VTFRJU0lHX01FUkdFX1NJR19NSVNNQVRDSDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgXCJwa1wiOiBjdXJyZW50LnBrLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogY3VycmVudC5zLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pU3Vic2lnLnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBcInBrXCI6IGN1cnJlbnQucGssXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiB1bmlTdWJzaWcucyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBtc2lnID0ge1xuICAgICAgICBcInZcIjogcmVmU2lnVHgubXNpZy52LFxuICAgICAgICBcInRoclwiOiByZWZTaWdUeC5tc2lnLnRocixcbiAgICAgICAgXCJzdWJzaWdcIjogbmV3U3Vic2lncyxcbiAgICB9O1xuICAgIGxldCBzVHhuID0ge1xuICAgICAgICBcIm1zaWdcIjogbXNpZyxcbiAgICAgICAgXCJ0eG5cIjogcmVmU2lnVHgudHhuLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGVuY29kaW5nLmVuY29kZShzVHhuKSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeU11bHRpc2lnKHRvQmVWZXJpZmllZCwgbXNpZywgcHVibGljS2V5KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1zaWcudjtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBtc2lnLnRocjtcbiAgICBjb25zdCBzdWJzaWdzID0gbXNpZy5zdWJzaWc7XG5cbiAgICBsZXQgcGtzID0gc3Vic2lncy5tYXAoXG4gICAgICAgIChzdWJzaWcpID0+IHN1YnNpZy5wa1xuICAgICk7XG4gICAgaWYgKG1zaWcuc3Vic2lnLmxlbmd0aCA8IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHBrO1xuICAgIHRyeSB7XG4gICAgICAgIHBrID0gYWRkcmVzcy5mcm9tTXVsdGlzaWdQcmVJbWcoe3ZlcnNpb24sIHRocmVzaG9sZCwgcGtzfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlscy5hcnJheUVxdWFsKHBrLCBwdWJsaWNLZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChsZXQgc3Vic2lnIG9mIHN1YnNpZ3MpIHtcbiAgICAgICAgaWYgKHN1YnNpZy5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY291bnRlciA8IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHZlcmlmaWVkQ291bnRlciA9IDA7XG4gICAgZm9yIChsZXQgc3Vic2lnIG9mIHN1YnNpZ3MpIHtcbiAgICAgICAgaWYgKHN1YnNpZy5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChuYWNsLnZlcmlmeSh0b0JlVmVyaWZpZWQsIHN1YnNpZy5zLCBzdWJzaWcucGspKSB7XG4gICAgICAgICAgICAgICAgdmVyaWZpZWRDb3VudGVyICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmVyaWZpZWRDb3VudGVyIDwgdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTXVsdGlzaWdUcmFuc2FjdGlvbixcbiAgICBtZXJnZU11bHRpc2lnVHJhbnNhY3Rpb25zLFxuICAgIGNyZWF0ZU11bHRpc2lnVHJhbnNhY3Rpb24sXG4gICAgdmVyaWZ5TXVsdGlzaWcsXG4gICAgRVJST1JfTVVMVElTSUdfTUVSR0VfTEVTU1RIQU5UV08sXG4gICAgRVJST1JfTVVMVElTSUdfTUVSR0VfTUlTTUFUQ0gsXG4gICAgRVJST1JfTVVMVElTSUdfTUVSR0VfV1JPTkdfUFJFSU1BR0UsXG4gICAgRVJST1JfTVVMVElTSUdfTUVSR0VfU0lHX01JU01BVENILFxufTtcbiIsImNvbnN0IG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKTtcbmNvbnN0IHNoYTUxMiA9IHJlcXVpcmUoJ2pzLXNoYTUxMicpO1xuXG5mdW5jdGlvbiBnZW5lcmljSGFzaChhcnIpIHtcbiAgICByZXR1cm4gc2hhNTEyLnNoYTUxMl8yNTYuYXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5hY2wucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24ga2V5UGFpcigpIHtcbiAgICBsZXQgc2VlZCA9IHJhbmRvbUJ5dGVzKG5hY2wuYm94LnNlY3JldEtleUxlbmd0aCk7XG4gICAgcmV0dXJuIGtleVBhaXJGcm9tU2VlZChzZWVkKTtcbn1cblxuZnVuY3Rpb24ga2V5UGFpckZyb21TZWVkKHNlZWQpIHtcbiAgICByZXR1cm4gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGtleVBhaXJGcm9tU2VjcmV0S2V5KHNrKSB7XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkoc2spO1xufVxuXG5mdW5jdGlvbiBzaWduKG1zZywgc2VjcmV0S2V5KSB7XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZChtc2csIHNlY3JldEtleSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBuYWNsLnZlcmlmeShhLCBiKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgdmVyaWZ5S2V5KSB7XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCB2ZXJpZnlLZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtnZW5lcmljSGFzaCwgcmFuZG9tQnl0ZXMsIGtleVBhaXIsIHNpZ24sIGtleVBhaXJGcm9tU2VlZCwga2V5UGFpckZyb21TZWNyZXRLZXksIGJ5dGVzRXF1YWwsIHZlcmlmeX07XG5cbi8vIGNvbnN0YW50c1xubW9kdWxlLmV4cG9ydHMuUFVCTElDX0tFWV9MRU5HVEggPSBuYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoO1xubW9kdWxlLmV4cG9ydHMuU0VDUkVUX0tFWV9MRU5HVEggPSBuYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoO1xubW9kdWxlLmV4cG9ydHMuSEFTSF9CWVRFU19MRU5HVEggPSAzMjtcbm1vZHVsZS5leHBvcnRzLlNFRURfQlRZRVNfTEVOR1RIID0gMzI7IiwiY29uc3QgYWRkcmVzcyA9IHJlcXVpcmUoXCIuL2VuY29kaW5nL2FkZHJlc3NcIik7XG5jb25zdCBlbmNvZGluZyA9IHJlcXVpcmUoXCIuL2VuY29kaW5nL2VuY29kaW5nXCIpO1xuY29uc3QgbmFjbCA9IHJlcXVpcmUoXCIuL25hY2wvbmFjbFdyYXBwZXJzXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy91dGlsc1wiKTtcbmNvbnN0IGJhc2UzMiA9IHJlcXVpcmUoJ2hpLWJhc2UzMicpO1xuXG5jb25zdCBBTEdPUkFORF9UUkFOU0FDVElPTl9MRU5HVEggPSA1MjtcbmNvbnN0IEFMR09SQU5EX01JTl9UWF9GRUUgPSAxMDAwOyAvLyB2ZXJzaW9uIHY1XG5jb25zdCBBTEdPUkFORF9UUkFOU0FDVElPTl9MRUFTRV9MRU5HVEggPSAzMjtcbmNvbnN0IEFMR09SQU5EX01BWF9UWF9HUk9VUF9TSVpFID0gMTY7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZW5hYmxlcyBjb25zdHJ1Y3Rpb24gb2YgQWxnb3JhbmQgdHJhbnNhY3Rpb25zXG4gKiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHtmcm9tLCB0bywgZmVlLCBhbW91bnQsIGZpcnN0Um91bmQsIGxhc3RSb3VuZCwgbm90ZSwgZ2VuZXNpc0lELCBnZW5lc2lzSGFzaCwgbGVhc2UsXG4gICAgICAgICAgICAgICAgIGNsb3NlUmVtYWluZGVyVG8sIHZvdGVLZXksIHNlbGVjdGlvbktleSwgdm90ZUZpcnN0LCB2b3RlTGFzdCwgdm90ZUtleURpbHV0aW9uLCBcbiAgICAgICAgICAgICAgICAgYXNzZXRJbmRleCwgYXNzZXRUb3RhbCwgYXNzZXREZWZhdWx0RnJvemVuLCBhc3NldE1hbmFnZXIsIGFzc2V0UmVzZXJ2ZSxcbiAgICAgICAgICAgICAgICAgYXNzZXRGcmVlemUsIGFzc2V0Q2xhd2JhY2ssIGFzc2V0VW5pdE5hbWUsIGFzc2V0TmFtZSwgYXNzZXRVUkwsIGFzc2V0TWV0YWRhdGFIYXNoLFxuICAgICAgICAgICAgICAgICBmcmVlemVBY2NvdW50LCBmcmVlemVTdGF0ZSwgYXNzZXRSZXZvY2F0aW9uVGFyZ2V0LCB0eXBlPVwicGF5XCIsIGZsYXRGZWU9ZmFsc2V9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiVHJhbnNhY3Rpb25cIjtcbiAgICAgICAgdGhpcy50YWcgPSBCdWZmZXIuZnJvbShcIlRYXCIpO1xuXG4gICAgICAgIGZyb20gPSBhZGRyZXNzLmRlY29kZShmcm9tKTtcbiAgICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHRvID0gYWRkcmVzcy5kZWNvZGUodG8pO1xuICAgICAgICBpZiAoY2xvc2VSZW1haW5kZXJUbyAhPT0gdW5kZWZpbmVkKSBjbG9zZVJlbWFpbmRlclRvID0gYWRkcmVzcy5kZWNvZGUoY2xvc2VSZW1haW5kZXJUbyk7XG4gICAgICAgIGlmIChhc3NldE1hbmFnZXIgIT09IHVuZGVmaW5lZCkgYXNzZXRNYW5hZ2VyID0gYWRkcmVzcy5kZWNvZGUoYXNzZXRNYW5hZ2VyKTtcbiAgICAgICAgaWYgKGFzc2V0UmVzZXJ2ZSAhPT0gdW5kZWZpbmVkKSBhc3NldFJlc2VydmUgPSBhZGRyZXNzLmRlY29kZShhc3NldFJlc2VydmUpO1xuICAgICAgICBpZiAoYXNzZXRGcmVlemUgIT09IHVuZGVmaW5lZCkgYXNzZXRGcmVlemUgPSBhZGRyZXNzLmRlY29kZShhc3NldEZyZWV6ZSk7XG4gICAgICAgIGlmIChhc3NldENsYXdiYWNrICE9PSB1bmRlZmluZWQpIGFzc2V0Q2xhd2JhY2sgPSBhZGRyZXNzLmRlY29kZShhc3NldENsYXdiYWNrKTtcbiAgICAgICAgaWYgKGFzc2V0UmV2b2NhdGlvblRhcmdldCAhPT0gdW5kZWZpbmVkKSBhc3NldFJldm9jYXRpb25UYXJnZXQgPSBhZGRyZXNzLmRlY29kZShhc3NldFJldm9jYXRpb25UYXJnZXQpO1xuICAgICAgICBpZiAoZnJlZXplQWNjb3VudCAhPT0gdW5kZWZpbmVkKSBmcmVlemVBY2NvdW50ID0gYWRkcmVzcy5kZWNvZGUoZnJlZXplQWNjb3VudCk7XG4gICAgICAgIGlmIChnZW5lc2lzSGFzaCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBFcnJvcihcImdlbmVzaXMgaGFzaCBtdXN0IGJlIHNwZWNpZmllZCBhbmQgaW4gYSBiYXNlNjQgc3RyaW5nLlwiKTtcblxuICAgICAgICBnZW5lc2lzSGFzaCA9IEJ1ZmZlci5mcm9tKGdlbmVzaXNIYXNoLCAnYmFzZTY0Jyk7XG5cbiAgICAgICAgaWYgKGFtb3VudCAhPT0gdW5kZWZpbmVkICYmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYW1vdW50KSB8fCBhbW91bnQgPCAwKSkgdGhyb3cgRXJyb3IoXCJBbW91bnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciBhbmQgc21hbGxlciB0aGFuIDJeNTMtMVwiKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihmZWUpIHx8IGZlZSA8IDApIHRocm93IEVycm9yKFwiZmVlIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIgYW5kIHNtYWxsZXIgdGhhbiAyXjUzLTFcIik7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZmlyc3RSb3VuZCkgfHwgZmlyc3RSb3VuZCA8IDApIHRocm93IEVycm9yKFwiZmlyc3RSb3VuZCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGxhc3RSb3VuZCkgfHwgbGFzdFJvdW5kIDwgMCkgdGhyb3cgRXJyb3IoXCJsYXN0Um91bmQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgaWYgKGFzc2V0VG90YWwgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGFzc2V0VG90YWwpIHx8IGFzc2V0VG90YWwgPCAwKSkgdGhyb3cgRXJyb3IoXCJUb3RhbCBhc3NldCBpc3N1YW5jZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIGFuZCBzbWFsbGVyIHRoYW4gMl41My0xXCIpO1xuICAgICAgICBpZiAoYXNzZXRJbmRleCAhPT0gdW5kZWZpbmVkICYmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXNzZXRJbmRleCkgfHwgYXNzZXRJbmRleCA8IDApKSB0aHJvdyBFcnJvcihcIkFzc2V0IGluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIgYW5kIHNtYWxsZXIgdGhhbiAyXjUzLTFcIik7XG5cbiAgICAgICAgaWYgKG5vdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG5vdGUuY29uc3RydWN0b3IgIT09IFVpbnQ4QXJyYXkpIHRocm93IEVycm9yKFwibm90ZSBtdXN0IGJlIGEgVWludDhBcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbm90ZSA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobGVhc2UuY29uc3RydWN0b3IgIT09IFVpbnQ4QXJyYXkpIHRocm93IEVycm9yKFwibGVhc2UgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuXCIpO1xuICAgICAgICAgICAgaWYgKGxlYXNlLmxlbmd0aCAhPT0gQUxHT1JBTkRfVFJBTlNBQ1RJT05fTEVBU0VfTEVOR1RIKSB0aHJvdyBFcnJvcihcImxlYXNlIG11c3QgYmUgb2YgbGVuZ3RoIFwiICsgQUxHT1JBTkRfVFJBTlNBQ1RJT05fTEVBU0VfTEVOR1RILnRvU3RyaW5nKCkgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWFzZSA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b3RlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZvdGVLZXkgPSBCdWZmZXIuZnJvbSh2b3RlS2V5LCBcImJhc2U2NFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0aW9uS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbktleSA9IEJ1ZmZlci5mcm9tKHNlbGVjdGlvbktleSwgXCJiYXNlNjRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIGZyb20sIHRvLCBmZWUsIGFtb3VudCwgZmlyc3RSb3VuZCwgbGFzdFJvdW5kLCBub3RlLCBnZW5lc2lzSUQsIGdlbmVzaXNIYXNoLCBsZWFzZSxcbiAgICAgICAgICAgIGNsb3NlUmVtYWluZGVyVG8sIHZvdGVLZXksIHNlbGVjdGlvbktleSwgdm90ZUZpcnN0LCB2b3RlTGFzdCwgdm90ZUtleURpbHV0aW9uLFxuICAgICAgICAgICAgYXNzZXRJbmRleCwgYXNzZXRUb3RhbCwgYXNzZXREZWZhdWx0RnJvemVuLCBhc3NldE1hbmFnZXIsIGFzc2V0UmVzZXJ2ZSxcbiAgICAgICAgICAgIGFzc2V0RnJlZXplLCBhc3NldENsYXdiYWNrLCBhc3NldFVuaXROYW1lLCBhc3NldE5hbWUsIGFzc2V0VVJMLCBhc3NldE1ldGFkYXRhSGFzaCxcbiAgICAgICAgICAgIGZyZWV6ZUFjY291bnQsIGZyZWV6ZVN0YXRlLCBhc3NldFJldm9jYXRpb25UYXJnZXQsIHR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTW9kaWZ5IEZlZVxuICAgICAgICBpZiAoIWZsYXRGZWUpe1xuICAgICAgICAgICAgdGhpcy5mZWUgKj0gdGhpcy5lc3RpbWF0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzdWdnZXN0ZWQgZmVlIHRvbyBzbWFsbCBhbmQgd2lsbCBiZSByZWplY3RlZCwgc2V0IHRvIG1pbiB0eCBmZWVcbiAgICAgICAgaWYgKHRoaXMuZmVlIDwgQUxHT1JBTkRfTUlOX1RYX0ZFRSkge1xuICAgICAgICAgICAgdGhpcy5mZWUgPSBBTEdPUkFORF9NSU5fVFhfRkVFO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F5IHdlIGFyZSBhd2FyZSBvZiBncm91cHNcbiAgICAgICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRfb2JqX2Zvcl9lbmNvZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInBheVwiKSB7XG4gICAgICAgICAgICBsZXQgdHhuID0ge1xuICAgICAgICAgICAgICAgIFwiYW10XCI6IHRoaXMuYW1vdW50LFxuICAgICAgICAgICAgICAgIFwiZmVlXCI6IHRoaXMuZmVlLFxuICAgICAgICAgICAgICAgIFwiZnZcIjogdGhpcy5maXJzdFJvdW5kLFxuICAgICAgICAgICAgICAgIFwibHZcIjogdGhpcy5sYXN0Um91bmQsXG4gICAgICAgICAgICAgICAgXCJub3RlXCI6IEJ1ZmZlci5mcm9tKHRoaXMubm90ZSksXG4gICAgICAgICAgICAgICAgXCJyY3ZcIjogQnVmZmVyLmZyb20odGhpcy50by5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIFwic25kXCI6IEJ1ZmZlci5mcm9tKHRoaXMuZnJvbS5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInBheVwiLFxuICAgICAgICAgICAgICAgIFwiZ2VuXCI6IHRoaXMuZ2VuZXNpc0lELFxuICAgICAgICAgICAgICAgIFwiZ2hcIjogdGhpcy5nZW5lc2lzSGFzaCxcbiAgICAgICAgICAgICAgICBcImx4XCI6IEJ1ZmZlci5mcm9tKHRoaXMubGVhc2UpLFxuICAgICAgICAgICAgICAgIFwiZ3JwXCI6IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBwYXJzZSBjbG9zZSBhZGRyZXNzXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZVJlbWFpbmRlclRvICE9PSB1bmRlZmluZWQpIHR4bi5jbG9zZSA9IEJ1ZmZlci5mcm9tKHRoaXMuY2xvc2VSZW1haW5kZXJUby5wdWJsaWNLZXkpO1xuXG4gICAgICAgICAgICAvLyBhbGxvd2VkIHplcm8gdmFsdWVzXG4gICAgICAgICAgICBpZiAoIXR4bi5ub3RlLmxlbmd0aCkgZGVsZXRlIHR4bi5ub3RlO1xuICAgICAgICAgICAgaWYgKCF0eG4uYW10KSBkZWxldGUgdHhuLmFtdDtcbiAgICAgICAgICAgIGlmICghdHhuLmZlZSkgZGVsZXRlIHR4bi5mZWU7XG4gICAgICAgICAgICBpZiAoIXR4bi5nZW4pIGRlbGV0ZSB0eG4uZ2VuO1xuICAgICAgICAgICAgaWYgKHR4bi5ncnAgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHR4bi5ncnA7XG4gICAgICAgICAgICBpZiAoIXR4bi5seC5sZW5ndGgpIGRlbGV0ZSB0eG4ubHg7XG5cbiAgICAgICAgICAgIHJldHVybiB0eG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09IFwia2V5cmVnXCIpIHtcbiAgICAgICAgICAgIGxldCB0eG4gPSB7XG4gICAgICAgICAgICAgICAgXCJmZWVcIjogdGhpcy5mZWUsXG4gICAgICAgICAgICAgICAgXCJmdlwiOiB0aGlzLmZpcnN0Um91bmQsXG4gICAgICAgICAgICAgICAgXCJsdlwiOiB0aGlzLmxhc3RSb3VuZCxcbiAgICAgICAgICAgICAgICBcIm5vdGVcIjogQnVmZmVyLmZyb20odGhpcy5ub3RlKSxcbiAgICAgICAgICAgICAgICBcInNuZFwiOiBCdWZmZXIuZnJvbSh0aGlzLmZyb20ucHVibGljS2V5KSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIFwiZ2VuXCI6IHRoaXMuZ2VuZXNpc0lELFxuICAgICAgICAgICAgICAgIFwiZ2hcIjogdGhpcy5nZW5lc2lzSGFzaCxcbiAgICAgICAgICAgICAgICBcImx4XCI6IEJ1ZmZlci5mcm9tKHRoaXMubGVhc2UpLFxuICAgICAgICAgICAgICAgIFwiZ3JwXCI6IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgICAgICAgXCJ2b3Rla2V5XCI6IHRoaXMudm90ZUtleSxcbiAgICAgICAgICAgICAgICBcInNlbGtleVwiOiB0aGlzLnNlbGVjdGlvbktleSxcbiAgICAgICAgICAgICAgICBcInZvdGVmc3RcIjogdGhpcy52b3RlRmlyc3QsXG4gICAgICAgICAgICAgICAgXCJ2b3RlbHN0XCI6IHRoaXMudm90ZUxhc3QsXG4gICAgICAgICAgICAgICAgXCJ2b3Rla2RcIjogdGhpcy52b3RlS2V5RGlsdXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBhbGxvd2VkIHplcm8gdmFsdWVzXG4gICAgICAgICAgICBpZiAoIXR4bi5ub3RlLmxlbmd0aCkgZGVsZXRlIHR4bi5ub3RlO1xuICAgICAgICAgICAgaWYgKCF0eG4ubHgubGVuZ3RoKSBkZWxldGUgdHhuLmx4O1xuICAgICAgICAgICAgaWYgKCF0eG4uZmVlKSBkZWxldGUgdHhuLmZlZTtcbiAgICAgICAgICAgIGlmICghdHhuLmdlbikgZGVsZXRlIHR4bi5nZW47XG5cbiAgICAgICAgICAgIGlmICh0eG4uZ3JwID09PSB1bmRlZmluZWQpIGRlbGV0ZSB0eG4uZ3JwO1xuXG4gICAgICAgICAgICByZXR1cm4gdHhuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PSBcImFjZmdcIikge1xuICAgICAgICAgICAgLy8gYXNzZXQgY3JlYXRpb24sIG9yIGFzc2V0IHJlY29uZmlndXJlLCBvciBhc3NldCBkZXN0cnVjdGlvblxuICAgICAgICAgICAgbGV0IHR4biA9IHtcbiAgICAgICAgICAgICAgICBcImZlZVwiOiB0aGlzLmZlZSxcbiAgICAgICAgICAgICAgICBcImZ2XCI6IHRoaXMuZmlyc3RSb3VuZCxcbiAgICAgICAgICAgICAgICBcImx2XCI6IHRoaXMubGFzdFJvdW5kLFxuICAgICAgICAgICAgICAgIFwibm90ZVwiOiBCdWZmZXIuZnJvbSh0aGlzLm5vdGUpLFxuICAgICAgICAgICAgICAgIFwic25kXCI6IEJ1ZmZlci5mcm9tKHRoaXMuZnJvbS5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgXCJnZW5cIjogdGhpcy5nZW5lc2lzSUQsXG4gICAgICAgICAgICAgICAgXCJnaFwiOiB0aGlzLmdlbmVzaXNIYXNoLFxuICAgICAgICAgICAgICAgIFwibHhcIjogQnVmZmVyLmZyb20odGhpcy5sZWFzZSksXG4gICAgICAgICAgICAgICAgXCJjYWlkXCI6IHRoaXMuYXNzZXRJbmRleCxcbiAgICAgICAgICAgICAgICBcImFwYXJcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInRcIjogdGhpcy5hc3NldFRvdGFsLFxuICAgICAgICAgICAgICAgICAgICBcImRmXCI6IHRoaXMuYXNzZXREZWZhdWx0RnJvemVuLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NldE1hbmFnZXIgIT09IHVuZGVmaW5lZCkgdHhuLmFwYXIubSA9IEJ1ZmZlci5mcm9tKHRoaXMuYXNzZXRNYW5hZ2VyLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NldFJlc2VydmUgIT09IHVuZGVmaW5lZCkgdHhuLmFwYXIuciA9IEJ1ZmZlci5mcm9tKHRoaXMuYXNzZXRSZXNlcnZlLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NldEZyZWV6ZSAhPT0gdW5kZWZpbmVkKSB0eG4uYXBhci5mID0gQnVmZmVyLmZyb20odGhpcy5hc3NldEZyZWV6ZS5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNzZXRDbGF3YmFjayAhPT0gdW5kZWZpbmVkKSB0eG4uYXBhci5jID0gQnVmZmVyLmZyb20odGhpcy5hc3NldENsYXdiYWNrLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NldE5hbWUgIT09IHVuZGVmaW5lZCkgdHhuLmFwYXIuYW4gPXRoaXMuYXNzZXROYW1lO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNzZXRVbml0TmFtZSAhPT0gdW5kZWZpbmVkKSB0eG4uYXBhci51biA9IHRoaXMuYXNzZXRVbml0TmFtZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2V0VVJMICE9PSB1bmRlZmluZWQpIHR4bi5hcGFyLmF1ID0gdGhpcy5hc3NldFVSTDtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2V0TWV0YWRhdGFIYXNoICE9PSB1bmRlZmluZWQpIHR4bi5hcGFyLmFtID0gQnVmZmVyLmZyb20odGhpcy5hc3NldE1ldGFkYXRhSGFzaCk7XG5cbiAgICAgICAgICAgIC8vIGFsbG93ZWQgemVybyB2YWx1ZXNcbiAgICAgICAgICAgIGlmICghdHhuLm5vdGUubGVuZ3RoKSBkZWxldGUgdHhuLm5vdGU7XG4gICAgICAgICAgICBpZiAoIXR4bi5seC5sZW5ndGgpIGRlbGV0ZSB0eG4ubHg7XG4gICAgICAgICAgICBpZiAoIXR4bi5hbXQpIGRlbGV0ZSB0eG4uYW10O1xuICAgICAgICAgICAgaWYgKCF0eG4uZmVlKSBkZWxldGUgdHhuLmZlZTtcbiAgICAgICAgICAgIGlmICghdHhuLmdlbikgZGVsZXRlIHR4bi5nZW47XG5cblxuICAgICAgICAgICAgaWYgKCF0eG4uY2FpZCkgZGVsZXRlIHR4bi5jYWlkO1xuICAgICAgICAgICAgaWYgKCghdHhuLmFwYXIudCkgJiZcbiAgICAgICAgICAgICAgICAoIXR4bi5hcGFyLnVuKSAmJlxuICAgICAgICAgICAgICAgICghdHhuLmFwYXIuYW4pICYmXG4gICAgICAgICAgICAgICAgKCF0eG4uYXBhci5kZikgJiZcbiAgICAgICAgICAgICAgICAoIXR4bi5hcGFyLm0pICYmXG4gICAgICAgICAgICAgICAgKCF0eG4uYXBhci5yKSAmJlxuICAgICAgICAgICAgICAgICghdHhuLmFwYXIuZikgJiZcbiAgICAgICAgICAgICAgICAoIXR4bi5hcGFyLmMpICYmXG4gICAgICAgICAgICAgICAgKCF0eG4uYXBhci5hdSkgJiZcbiAgICAgICAgICAgICAgICAoIXR4bi5hcGFyLmFtKSl7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eG4uYXBhclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eG4uYXBhci50KSBkZWxldGUgdHhuLmFwYXIudDtcbiAgICAgICAgICAgICAgICBpZiAoIXR4bi5hcGFyLnVuKSBkZWxldGUgdHhuLmFwYXIudW47XG4gICAgICAgICAgICAgICAgaWYgKCF0eG4uYXBhci5hbikgZGVsZXRlIHR4bi5hcGFyLmFuO1xuICAgICAgICAgICAgICAgIGlmICghdHhuLmFwYXIuZGYpIGRlbGV0ZSB0eG4uYXBhci5kZjtcbiAgICAgICAgICAgICAgICBpZiAoIXR4bi5hcGFyLm0pIGRlbGV0ZSB0eG4uYXBhci5tO1xuICAgICAgICAgICAgICAgIGlmICghdHhuLmFwYXIucikgZGVsZXRlIHR4bi5hcGFyLnI7XG4gICAgICAgICAgICAgICAgaWYgKCF0eG4uYXBhci5mKSBkZWxldGUgdHhuLmFwYXIuZjtcbiAgICAgICAgICAgICAgICBpZiAoIXR4bi5hcGFyLmMpIGRlbGV0ZSB0eG4uYXBhci5jO1xuICAgICAgICAgICAgICAgIGlmICghdHhuLmFwYXIuYXUpIGRlbGV0ZSB0eG4uYXBhci5hdTtcbiAgICAgICAgICAgICAgICBpZiAoIXR4bi5hcGFyLmFtKSBkZWxldGUgdHhuLmFwYXIuYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHhuLmdycCA9PT0gdW5kZWZpbmVkKSBkZWxldGUgdHhuLmdycDtcblxuICAgICAgICAgICAgcmV0dXJuIHR4bjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gXCJheGZlclwiKSB7XG4gICAgICAgICAgICAvLyBhc3NldCB0cmFuc2ZlciwgYWNjZXB0YW5jZSwgcmV2b2NhdGlvbiwgbWludCwgb3IgYnVyblxuICAgICAgICAgICAgbGV0IHR4biA9IHtcbiAgICAgICAgICAgICAgICBcImFhbXRcIjogdGhpcy5hbW91bnQsXG4gICAgICAgICAgICAgICAgXCJmZWVcIjogdGhpcy5mZWUsXG4gICAgICAgICAgICAgICAgXCJmdlwiOiB0aGlzLmZpcnN0Um91bmQsXG4gICAgICAgICAgICAgICAgXCJsdlwiOiB0aGlzLmxhc3RSb3VuZCxcbiAgICAgICAgICAgICAgICBcIm5vdGVcIjogQnVmZmVyLmZyb20odGhpcy5ub3RlKSxcbiAgICAgICAgICAgICAgICBcInNuZFwiOiBCdWZmZXIuZnJvbSh0aGlzLmZyb20ucHVibGljS2V5KSxcbiAgICAgICAgICAgICAgICBcImFyY3ZcIjogQnVmZmVyLmZyb20odGhpcy50by5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgXCJnZW5cIjogdGhpcy5nZW5lc2lzSUQsXG4gICAgICAgICAgICAgICAgXCJnaFwiOiB0aGlzLmdlbmVzaXNIYXNoLFxuICAgICAgICAgICAgICAgIFwibHhcIjogQnVmZmVyLmZyb20odGhpcy5sZWFzZSksXG4gICAgICAgICAgICAgICAgXCJ4YWlkXCI6IHRoaXMuYXNzZXRJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlUmVtYWluZGVyVG8gIT09IHVuZGVmaW5lZCkgdHhuLmFjbG9zZSA9IEJ1ZmZlci5mcm9tKHRoaXMuY2xvc2VSZW1haW5kZXJUby5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNzZXRSZXZvY2F0aW9uVGFyZ2V0ICE9PSB1bmRlZmluZWQpIHR4bi5hc25kID0gQnVmZmVyLmZyb20odGhpcy5hc3NldFJldm9jYXRpb25UYXJnZXQucHVibGljS2V5KTtcbiAgICAgICAgICAgIC8vIGFsbG93ZWQgemVybyB2YWx1ZXNcbiAgICAgICAgICAgIGlmICghdHhuLm5vdGUubGVuZ3RoKSBkZWxldGUgdHhuLm5vdGU7XG4gICAgICAgICAgICBpZiAoIXR4bi5seC5sZW5ndGgpIGRlbGV0ZSB0eG4ubHg7XG4gICAgICAgICAgICBpZiAoIXR4bi5hYW10KSBkZWxldGUgdHhuLmFhbXQ7XG4gICAgICAgICAgICBpZiAoIXR4bi5hbXQpIGRlbGV0ZSB0eG4uYW10O1xuICAgICAgICAgICAgaWYgKCF0eG4uZmVlKSBkZWxldGUgdHhuLmZlZTtcbiAgICAgICAgICAgIGlmICghdHhuLmdlbikgZGVsZXRlIHR4bi5nZW47XG4gICAgICAgICAgICBpZiAodHhuLmdycCA9PT0gdW5kZWZpbmVkKSBkZWxldGUgdHhuLmdycDtcbiAgICAgICAgICAgIGlmICghdHhuLmFjbG9zZSkgZGVsZXRlIHR4bi5hY2xvc2U7XG4gICAgICAgICAgICBpZiAoIXR4bi5hc25kKSBkZWxldGUgdHhuLmFzbmQ7XG4gICAgICAgICAgICByZXR1cm4gdHhuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PSBcImFmcnpcIikge1xuICAgICAgICAgICAgLy8gYXNzZXQgZnJlZXplIG9yIHVuZnJlZXplXG4gICAgICAgICAgICBsZXQgdHhuID0ge1xuICAgICAgICAgICAgICAgIFwiZmVlXCI6IHRoaXMuZmVlLFxuICAgICAgICAgICAgICAgIFwiZnZcIjogdGhpcy5maXJzdFJvdW5kLFxuICAgICAgICAgICAgICAgIFwibHZcIjogdGhpcy5sYXN0Um91bmQsXG4gICAgICAgICAgICAgICAgXCJub3RlXCI6IEJ1ZmZlci5mcm9tKHRoaXMubm90ZSksXG4gICAgICAgICAgICAgICAgXCJzbmRcIjogQnVmZmVyLmZyb20odGhpcy5mcm9tLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBcImdlblwiOiB0aGlzLmdlbmVzaXNJRCxcbiAgICAgICAgICAgICAgICBcImdoXCI6IHRoaXMuZ2VuZXNpc0hhc2gsXG4gICAgICAgICAgICAgICAgXCJseFwiOiBCdWZmZXIuZnJvbSh0aGlzLmxlYXNlKSxcbiAgICAgICAgICAgICAgICBcImZhaWRcIjogdGhpcy5hc3NldEluZGV4LFxuICAgICAgICAgICAgICAgIFwiYWZyelwiOiB0aGlzLmZyZWV6ZVN0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplQWNjb3VudCAhPT0gdW5kZWZpbmVkKSB0eG4uZmFkZCA9IEJ1ZmZlci5mcm9tKHRoaXMuZnJlZXplQWNjb3VudC5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgLy8gYWxsb3dlZCB6ZXJvIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCF0eG4ubm90ZS5sZW5ndGgpIGRlbGV0ZSB0eG4ubm90ZTtcbiAgICAgICAgICAgIGlmICghdHhuLmx4Lmxlbmd0aCkgZGVsZXRlIHR4bi5seDtcbiAgICAgICAgICAgIGlmICghdHhuLmFtdCkgZGVsZXRlIHR4bi5hbXQ7XG4gICAgICAgICAgICBpZiAoIXR4bi5mZWUpIGRlbGV0ZSB0eG4uZmVlO1xuICAgICAgICAgICAgaWYgKCF0eG4uZ2VuKSBkZWxldGUgdHhuLmdlbjtcbiAgICAgICAgICAgIGlmICghdHhuLmFmcnopIGRlbGV0ZSB0eG4uYWZyejtcbiAgICAgICAgICAgIGlmICh0eG4uZ3JwID09PSB1bmRlZmluZWQpIGRlbGV0ZSB0eG4uZ3JwO1xuXG4gICAgICAgICAgICByZXR1cm4gdHhuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21fb2JqX2Zvcl9lbmNvZGluZyh0eG5Gb3JFbmMpIHtcbiAgICAgICAgbGV0IHR4biA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgICB0eG4ubmFtZSA9IFwiVHJhbnNhY3Rpb25cIjtcbiAgICAgICAgdHhuLnRhZyA9IEJ1ZmZlci5mcm9tKFwiVFhcIik7XG5cbiAgICAgICAgdHhuLmdlbmVzaXNJRCA9IHR4bkZvckVuYy5nZW47XG4gICAgICAgIHR4bi5nZW5lc2lzSGFzaCA9IEJ1ZmZlci5mcm9tKHR4bkZvckVuYy5naCk7XG4gICAgICAgIHR4bi50eXBlID0gdHhuRm9yRW5jLnR5cGU7XG4gICAgICAgIHR4bi5mZWUgPSB0eG5Gb3JFbmMuZmVlO1xuICAgICAgICB0eG4uZmlyc3RSb3VuZCA9IHR4bkZvckVuYy5mdjtcbiAgICAgICAgdHhuLmxhc3RSb3VuZCA9IHR4bkZvckVuYy5sdjtcbiAgICAgICAgdHhuLm5vdGUgPSBuZXcgVWludDhBcnJheSh0eG5Gb3JFbmMubm90ZSk7XG4gICAgICAgIHR4bi5sZWFzZSA9IG5ldyBVaW50OEFycmF5KHR4bkZvckVuYy5seCk7XG4gICAgICAgIHR4bi5mcm9tID0gYWRkcmVzcy5kZWNvZGUoYWRkcmVzcy5lbmNvZGUobmV3IFVpbnQ4QXJyYXkodHhuRm9yRW5jLnNuZCkpKTtcbiAgICAgICAgaWYgKHR4bkZvckVuYy5ncnAgIT09IHVuZGVmaW5lZCkgdHhuLmdyb3VwID0gQnVmZmVyLmZyb20odHhuRm9yRW5jLmdycCk7XG5cbiAgICAgICAgaWYgKHR4bkZvckVuYy50eXBlID09PSBcInBheVwiKSB7XG4gICAgICAgICAgICB0eG4uYW1vdW50ID0gdHhuRm9yRW5jLmFtdDtcbiAgICAgICAgICAgIHR4bi50byA9IGFkZHJlc3MuZGVjb2RlKGFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4bkZvckVuYy5yY3YpKSk7XG4gICAgICAgICAgICBpZiAodHhuRm9yRW5jLmNsb3NlICE9PSB1bmRlZmluZWQpIHR4bi5jbG9zZVJlbWFpbmRlclRvID0gYWRkcmVzcy5kZWNvZGUoYWRkcmVzcy5lbmNvZGUodHhuRm9yRW5jLmNsb3NlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHhuRm9yRW5jLnR5cGUgPT09IFwia2V5cmVnXCIpIHtcbiAgICAgICAgICAgIHR4bi52b3RlS2V5ID0gQnVmZmVyLmZyb20odHhuRm9yRW5jLnZvdGVrZXkpO1xuICAgICAgICAgICAgdHhuLnNlbGVjdGlvbktleSA9IEJ1ZmZlci5mcm9tKHR4bkZvckVuYy5zZWxrZXkpO1xuICAgICAgICAgICAgdHhuLnZvdGVLZXlEaWx1dGlvbiA9IHR4bkZvckVuYy52b3Rla2Q7XG4gICAgICAgICAgICB0eG4udm90ZUZpcnN0ID0gdHhuRm9yRW5jLnZvdGVmc3Q7XG4gICAgICAgICAgICB0eG4udm90ZUxhc3QgPSB0eG5Gb3JFbmMudm90ZWxzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eG5Gb3JFbmMudHlwZSA9PT0gXCJhY2ZnXCIpIHtcbiAgICAgICAgICAgIC8vIGFzc2V0IGNyZWF0aW9uLCBvciBhc3NldCByZWNvbmZpZ3VyZSwgb3IgYXNzZXQgZGVzdHJ1Y3Rpb25cbiAgICAgICAgICAgIGlmICh0eG5Gb3JFbmMuY2FpZCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0eG4uYXNzZXRJbmRleCA9IHR4bkZvckVuYy5jYWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIHR4bi5hc3NldFRvdGFsID0gdHhuRm9yRW5jLmFwYXIudDtcbiAgICAgICAgICAgICAgICB0eG4uYXNzZXREZWZhdWx0RnJvemVuID0gdHhuRm9yRW5jLmFwYXIuZGY7XG4gICAgICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyLm0gIT09IHVuZGVmaW5lZCkgdHhuLmFzc2V0TWFuYWdlciA9IGFkZHJlc3MuZGVjb2RlKGFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4bkZvckVuYy5hcGFyLm0pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyLnIgIT09IHVuZGVmaW5lZCkgdHhuLmFzc2V0UmVzZXJ2ZSA9IGFkZHJlc3MuZGVjb2RlKGFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4bkZvckVuYy5hcGFyLnIpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyLmYgIT09IHVuZGVmaW5lZCkgdHhuLmFzc2V0RnJlZXplID0gYWRkcmVzcy5kZWNvZGUoYWRkcmVzcy5lbmNvZGUobmV3IFVpbnQ4QXJyYXkodHhuRm9yRW5jLmFwYXIuZikpKTtcbiAgICAgICAgICAgICAgICBpZiAodHhuRm9yRW5jLmFwYXIuYyAhPT0gdW5kZWZpbmVkKSB0eG4uYXNzZXRDbGF3YmFjayA9IGFkZHJlc3MuZGVjb2RlKGFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4bkZvckVuYy5hcGFyLmMpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyLnVuICE9PSB1bmRlZmluZWQpIHR4bi5hc3NldFVuaXROYW1lID0gdHhuRm9yRW5jLmFwYXIudW47XG4gICAgICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyLmFuICE9PSB1bmRlZmluZWQpIHR4bi5hc3NldE5hbWUgPSB0eG5Gb3JFbmMuYXBhci5hbjtcbiAgICAgICAgICAgICAgICBpZiAodHhuRm9yRW5jLmFwYXIuYXUgIT09IHVuZGVmaW5lZCkgdHhuLmFzc2V0VVJMID0gdHhuRm9yRW5jLmFwYXIuYXU7XG4gICAgICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hcGFyLmFtICE9PSB1bmRlZmluZWQpIHR4bi5hc3NldE1ldGFkYXRhSGFzaCA9IHR4bkZvckVuYy5hcGFyLmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR4bkZvckVuYy50eXBlID09PSBcImF4ZmVyXCIpIHtcbiAgICAgICAgICAgIC8vIGFzc2V0IHRyYW5zZmVyLCBhY2NlcHRhbmNlLCByZXZvY2F0aW9uLCBtaW50LCBvciBidXJuXG4gICAgICAgICAgICBpZiAodHhuRm9yRW5jLnhhaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR4bi5hc3NldEluZGV4ID0gdHhuRm9yRW5jLnhhaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHhuRm9yRW5jLmFhbXQgIT09IHVuZGVmaW5lZCkgdHhuLmFtb3VudCA9IHR4bkZvckVuYy5hYW10O1xuICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5hY2xvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR4bi5jbG9zZVJlbWFpbmRlclRvID0gYWRkcmVzcy5kZWNvZGUoYWRkcmVzcy5lbmNvZGUobmV3IFVpbnQ4QXJyYXkodHhuRm9yRW5jLmFjbG9zZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eG5Gb3JFbmMuYXNuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHhuLmFzc2V0UmV2b2NhdGlvblRhcmdldCA9IGFkZHJlc3MuZGVjb2RlKGFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4bkZvckVuYy5hc25kKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHhuLnRvID0gYWRkcmVzcy5kZWNvZGUoYWRkcmVzcy5lbmNvZGUobmV3IFVpbnQ4QXJyYXkodHhuRm9yRW5jLmFyY3YpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHhuRm9yRW5jLnR5cGUgPT09IFwiYWZyelwiKSB7XG4gICAgICAgICAgICBpZiAodHhuRm9yRW5jLmFmcnogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR4bi5mcmVlemVTdGF0ZSA9IHR4bkZvckVuYy5hZnJ6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4bkZvckVuYy5mYWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eG4uYXNzZXRJbmRleCA9IHR4bkZvckVuYy5mYWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHhuLmZyZWV6ZUFjY291bnQgPSBhZGRyZXNzLmRlY29kZShhZGRyZXNzLmVuY29kZShuZXcgVWludDhBcnJheSh0eG5Gb3JFbmMuZmFkZCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHhuO1xuICAgIH1cblxuICAgIGVzdGltYXRlU2l6ZSgpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIGtleVxuICAgICAgICBsZXQga2V5ID0gbmFjbC5rZXlQYWlyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeG4oa2V5LnNlY3JldEtleSkubGVuZ3RoO1xuXG4gICAgfVxuXG4gICAgYnl0ZXNUb1NpZ24oKSB7XG4gICAgICAgIGxldCBlbmNvZGVkTXNnID0gdGhpcy50b0J5dGUoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHV0aWxzLmNvbmNhdEFycmF5cyh0aGlzLnRhZywgZW5jb2RlZE1zZykpO1xuICAgIH1cblxuICAgIHRvQnl0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nLmVuY29kZSh0aGlzLmdldF9vYmpfZm9yX2VuY29kaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgdGhlIHJhdyBzaWduYXR1cmVcbiAgICByYXdTaWduVHhuKHNrKSB7XG4gICAgICAgIGNvbnN0IHRvQmVTaWduZWQgPSB0aGlzLmJ5dGVzVG9TaWduKCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IG5hY2wuc2lnbih0b0JlU2lnbmVkLCBzayk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaWcpO1xuICAgIH1cblxuICAgIHNpZ25UeG4oc2spIHtcbiAgICAgICAgLy8gY29uc3RydWN0IHNpZ25lZCBtZXNzYWdlXG4gICAgICAgIGxldCBzVHhuID0ge1xuICAgICAgICAgICAgXCJzaWdcIjogdGhpcy5yYXdTaWduVHhuKHNrKSxcbiAgICAgICAgICAgIFwidHhuXCI6IHRoaXMuZ2V0X29ial9mb3JfZW5jb2RpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGVuY29kaW5nLmVuY29kZShzVHhuKSk7XG4gICAgfVxuXG4gICAgcmF3VHhJRCgpIHtcbiAgICAgICAgY29uc3QgZW5fbXNnID0gdGhpcy50b0J5dGUoKTtcbiAgICAgICAgY29uc3QgZ2ggPSBCdWZmZXIuZnJvbSh1dGlscy5jb25jYXRBcnJheXModGhpcy50YWcsIGVuX21zZykpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obmFjbC5nZW5lcmljSGFzaChnaCkpO1xuICAgIH1cblxuICAgIHR4SUQoKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLnJhd1R4SUQoKTtcbiAgICAgICAgcmV0dXJuIGJhc2UzMi5lbmNvZGUoaGFzaCkuc2xpY2UoMCwgQUxHT1JBTkRfVFJBTlNBQ1RJT05fTEVOR1RIKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSBsZWFzZSB0byBhIHRyYW5zYWN0aW9uIG5vdCB5ZXQgaGF2aW5nXG4gICAgLy8gc3VwcGx5IGZlZVBlckJ5dGUgdG8gaW5jcmVtZW50IGZlZSBhY2NvcmRpbmdseVxuICAgIGFkZExlYXNlKGxlYXNlLCBmZWVQZXJCeXRlPTApIHtcbiAgICAgICAgaWYgKGxlYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChsZWFzZS5jb25zdHJ1Y3RvciAhPT0gVWludDhBcnJheSkgdGhyb3cgRXJyb3IoXCJsZWFzZSBtdXN0IGJlIGEgVWludDhBcnJheS5cIik7XG4gICAgICAgICAgICBpZiAobGVhc2UubGVuZ3RoICE9PSBBTEdPUkFORF9UUkFOU0FDVElPTl9MRUFTRV9MRU5HVEgpIHRocm93IEVycm9yKFwibGVhc2UgbXVzdCBiZSBvZiBsZW5ndGggXCIgKyBBTEdPUkFORF9UUkFOU0FDVElPTl9MRUFTRV9MRU5HVEgudG9TdHJpbmcoKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlYXNlID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWFzZSA9IGxlYXNlO1xuICAgICAgICBpZiAoZmVlUGVyQnl0ZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mZWUgKz0gMzcgKiBmZWVQZXJCeXRlOyAvLyAzMiBieXRlcyArIDUgYnl0ZSBsYWJlbFxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEF1eCBjbGFzcyBmb3IgZ3JvdXAgaWQgY2FsY3VsYXRpb24gb2YgYSBncm91cCBvZiB0cmFuc2FjdGlvbnNcbiAqL1xuY2xhc3MgVHhHcm91cCB7XG4gICAgY29uc3RydWN0b3IoaGFzaGVzKSB7XG4gICAgICAgIGlmIChoYXNoZXMubGVuZ3RoID4gQUxHT1JBTkRfTUFYX1RYX0dST1VQX1NJWkUpIHtcbiAgICAgICAgICAgIGxldCBlcnJvck1zZyA9IGhhc2hlcy5sZW5ndGgudG9TdHJpbmcoKSArIFwiIHRyYW5zYWN0aW9ucyBncm91cGVkIHRvZ2V0aGVyIGJ1dCBtYXggZ3JvdXAgc2l6ZSBpcyBcIiArIEFMR09SQU5EX01BWF9UWF9HUk9VUF9TSVpFLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRyYW5zYWN0aW9uIGdyb3VwXCI7XG4gICAgICAgIHRoaXMudGFnID0gQnVmZmVyLmZyb20oXCJUR1wiKTtcblxuICAgICAgICB0aGlzLnR4R3JvdXBIYXNoZXMgPSBoYXNoZXM7XG4gICAgfVxuXG4gICAgZ2V0X29ial9mb3JfZW5jb2RpbmcoKSB7XG4gICAgICAgIGNvbnN0IHR4Z3JvdXAgPSB7XG4gICAgICAgICAgICBcInR4bGlzdFwiOiB0aGlzLnR4R3JvdXBIYXNoZXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHR4Z3JvdXA7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21fb2JqX2Zvcl9lbmNvZGluZyh0eGdyb3VwRm9yRW5jKSB7XG4gICAgICAgIGNvbnN0IHR4biA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgICB0eG4ubmFtZSA9IFwiVHJhbnNhY3Rpb24gZ3JvdXBcIjtcbiAgICAgICAgdHhuLnRhZyA9IEJ1ZmZlci5mcm9tKFwiVEdcIik7XG4gICAgICAgIHR4bi50eEdyb3VwSGFzaGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGhhc2ggb2YgdHhncm91cEZvckVuYy50eGxpc3QpIHtcbiAgICAgICAgICAgIHR4bi50eEdyb3VwSGFzaGVzLnB1c2gobmV3IEJ1ZmZlci5mcm9tKGhhc2gpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHhuO1xuICAgIH1cblxuICAgIHRvQnl0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nLmVuY29kZSh0aGlzLmdldF9vYmpfZm9yX2VuY29kaW5nKCkpO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtUcmFuc2FjdGlvbiwgVHhHcm91cH07XG4iLCIvKipcbiAqIEFycmF5RXF1YWwgdGFrZXMgdHdvIGFycmF5cyBhbmQgcmV0dXJuIHRydWUgaWYgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge3JldHVybiBmYWxzZTt9XG4gICAgcmV0dXJuIGEuZXZlcnkoKHZhbCwgaSkgPT4gdmFsID09PSBiW2ldKTtcbn1cblxuLyoqXG4gKiBDb25jYXRBcnJheXMgdGFrZXMgdHdvIGFycmF5IGFuZCByZXR1cm5zIGEgam9pbnQgYXJyYXkgb2YgYm90aFxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gW2EsYl1cbiAqL1xuZnVuY3Rpb24gY29uY2F0QXJyYXlzKGEsIGIpIHtcbiAgICBsZXQgYyA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGMuc2V0KGEpO1xuICAgIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7YXJyYXlFcXVhbCwgY29uY2F0QXJyYXlzfTsiXX0=
